<meta charset="UTF-8"><meta http-equiv="content-type" content="text/html;charset=UTF-8"><meta name="viewport" content="width=600, initial-scale=1"><style>span.md {width: 800;display: inline-block;}body{max-width:680px;margin:auto;padding:20px;text-align:justify;line-height:140%; -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;font-smoothing:antialiased;color:#222;font-family:Palatino,Georgia,"Times New Roman",serif}</style><style>@media print{*{-webkit-print-color-adjust:exact;text-shadow:none !important}}body{counter-reset: h1 h2 h3 h4 h5 h6 paragraph}@page{margin:0;size:auto}#mdContextMenu{position:absolute;background:#383838;cursor:default;border:1px solid #999;color:#fff;padding:4px 0px;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,"Helvetica Neue",sans-serif;font-size:85%;font-weight:600;border-radius:4px;box-shadow:0px 3px 10px rgba(0,0,0,35%)}#mdContextMenu div{padding:0px 20px}#mdContextMenu div:hover{background:#1659d1}.md code,.md pre{font-family:Menlo,Consolas,monospace;font-size:98%;text-align:left;line-height:140%}.md .mediumToc code,.md longToc code,.md .shortToc code,.md h1 code,.md h2 code,.md h3 code,.md h4 code,.md h5 code,.md h6 code{font-size:unset}.md div.title{font-size:26px;font-weight:800;line-height:120%;text-align:center}.md div.afterTitles{height:10px}.md div.subtitle{text-align:center}.md iframe.textinsert, .md object.textinsert,.md iframe:not(.markdeep){display:block;margin-top:10px;margin-bottom:10px;width:100%;height:75vh;border:1px solid #000;border-radius:4px;background:#f5f5f4}.md .image{display:inline-block}.md img{max-width:100%;page-break-inside:avoid}.md li{text-align:left;text-indent:0}.md pre.listing {width:100%;tab-size:4;-moz-tab-size:4;-o-tab-size:4;counter-reset:line;overflow-x:auto;resize:horizontal}.md pre.listing .linenumbers span.line:before{width:30px;margin-left:-28px;font-size:80%;text-align:right;counter-increment:line;content:counter(line);display:inline-block;padding-right:13px;margin-right:8px;color:#ccc}.md div.tilde{margin:20px 0 -10px;text-align:center}.md .imagecaption,.md .tablecaption,.md .listingcaption{display:inline-block;margin:7px 5px 12px;text-align:justify;font-style:italic}.md img.pixel{image-rendering:-moz-crisp-edges;image-rendering:pixelated}.md blockquote.fancyquote{margin:25px 0 25px;text-align:left;line-height:160%}.md blockquote.fancyquote::before{content:"“";color:#DDD;font-family:Times New Roman;font-size:45px;line-height:0;margin-right:6px;vertical-align:-0.3em}.md span.fancyquote{font-size:118%;color:#777;font-style:italic}.md span.fancyquote::after{content:"”";font-style:normal;color:#DDD;font-family:Times New Roman;font-size:45px;line-height:0;margin-left:6px;vertical-align:-0.3em}.md blockquote.fancyquote .author{width:100%;margin-top:10px;display:inline-block;text-align:right}.md small{font-size:60%}.md big{font-size:150%}.md div.title,contents,.md .tocHeader,.md h1,.md h2,.md h3,.md h4,.md h5,.md h6,.md .shortTOC,.md .mediumTOC,.nonumberh1,.nonumberh2,.nonumberh3,.nonumberh4,.nonumberh5,.nonumberh6{font-family:Verdana,Helvetica,Arial,sans-serif;margin:13.4px 0 13.4px;padding:15px 0 3px;border-top:none;clear:both}.md .tocTop {display:none}.md h1,.md h2,.md h3,.md h4,.md h5,.md h6,.md .nonumberh1,.md .nonumberh2,.md .nonumberh3,.md .nonumberh4,.md .nonumberh5,.md .nonumberh6{page-break-after:avoid;break-after:avoid}.md svg.diagram{display:block;font-family:Menlo,Consolas,monospace;font-size:98%;text-align:center;stroke-linecap:round;stroke-width:2px;page-break-inside:avoid;stroke:#000;fill:#000}.md svg.diagram .opendot{fill:#fff}.md svg.diagram .shadeddot{fill:#CCC}.md svg.diagram .dotteddot{stroke:#000;stroke-dasharray:4;fill:none}.md svg.diagram text{stroke:none}@media print{@page{margin:1in 5mm;transform: scale(150%)}}@media print{.md .pagebreak{page-break-after:always;visibility:hidden}}.md a{font-family:Georgia,Palatino,'Times New Roman'}.md h1,.md .tocHeader,.md .nonumberh1{border-bottom:3px solid;font-size:20px;font-weight:bold;}.md h1,.md .nonumberh1{counter-reset: h2 h3 h4 h5 h6}.md h2,.md .nonumberh2{counter-reset: h3 h4 h5 h6;border-bottom:2px solid #999;color:#555;font-weight:bold;font-size:18px;}.md h3,.md h4,.md h5,.md h6,.md .nonumberh3,.md .nonumberh4,.md .nonumberh5,.md .nonumberh6{font-family:Verdana,Helvetica,Arial,sans-serif;color:#555;font-size:16px;}.md h3{counter-reset:h4 h5 h6}.md h4{counter-reset:h5 h6}.md h5{counter-reset:h6}.md div.table{margin:16px 0 16px 0}.md table{border-collapse:collapse;line-height:140%;page-break-inside:avoid}.md table.table{margin:auto}.md table.calendar{width:100%;margin:auto;font-size:11px;font-family:Verdana,Helvetica,Arial,sans-serif}.md table.calendar th{font-size:16px}.md .today{background:#ECF8FA}.md .calendar .parenthesized{color:#999;font-style:italic}.md table.table th{color:#FFF;background-color:#AAA;border:1px solid #888;padding:8px 15px 8px 15px}.md table.table td{padding:5px 15px 5px 15px;border:1px solid #888}.md table.table tr:nth-child(even){background:#EEE}.md pre.tilde{border-top: 1px solid #CCC;border-bottom: 1px solid #CCC;padding: 5px 0 5px 20px;margin:0 0 0 0;background:#FCFCFC;page-break-inside:avoid}.md a.target{width:0px;height:0px;visibility:hidden;font-size:0px;display:inline-block}.md a:link, .md a:visited{color:#38A;text-decoration:none}.md a:link:hover{text-decoration:underline}.md dt{font-weight:700}.md dl>dd{margin-top:-8px; margin-bottom:8px}.md dl>table{margin:35px 0 30px}.md code{page-break-inside:avoid;} @media print{.md .listing code{white-space:pre-wrap}}.md .endnote{font-size:13px;line-height:15px;padding-left:10px;text-indent:-10px}.md .bib{padding-left:80px;text-indent:-80px;text-align:left}.markdeepFooter{font-size:9px;text-align:right;padding-top:80px;color:#999}.md .mediumTOC{float:right;font-size:12px;line-height:15px;border-left:1px solid #CCC;padding-left:15px;margin:15px 0px 15px 25px}.md .mediumTOC .level1{font-weight:600}.md .longTOC .level1{font-weight:600;display:block;padding-top:12px;margin:0 0 -20px}.md .shortTOC{text-align:center;font-weight:bold;margin-top:15px;font-size:14px}.md .admonition{position:relative;margin:1em 0;padding:.4rem 1rem;border-radius:.2rem;border-left:2.5rem solid rgba(68,138,255,.4);background-color:rgba(68,138,255,.15);}.md .admonition-title{font-weight:bold;border-bottom:solid 1px rgba(68,138,255,.4);padding-bottom:4px;margin-bottom:4px;margin-left: -1rem;padding-left:1rem;margin-right:-1rem;border-color:rgba(68,138,255,.4)}.md .admonition.tip{border-left:2.5rem solid rgba(50,255,90,.4);background-color:rgba(50,255,90,.15)}.md .admonition.tip::before{content:"\24d8";font-weight:bold;font-size:150%;position:relative;top:3px;color:rgba(26,128,46,.8);left:-2.95rem;display:block;width:0;height:0}.md .admonition.tip>.admonition-title{border-color:rgba(50,255,90,.4)}.md .admonition.warn,.md .admonition.warning{border-left:2.5rem solid rgba(255,145,0,.4);background-color:rgba(255,145,0,.15)}.md .admonition.warn::before,.md .admonition.warning::before{content:"\26A0";font-weight:bold;font-size:150%;position:relative;top:2px;color:rgba(128,73,0,.8);left:-2.95rem;display:block;width:0;height:0}.md .admonition.warn>.admonition-title,.md .admonition.warning>.admonition-title{border-color:rgba(255,145,0,.4)}.md .admonition.error{border-left: 2.5rem solid rgba(255,23,68,.4);background-color:rgba(255,23,68,.15)}.md .admonition.error>.admonition-title{border-color:rgba(255,23,68,.4)}.md .admonition.error::before{content: "\2612";font-family:"Arial";font-size:200%;position:relative;color:rgba(128,12,34,.8);top:-2px;left:-3rem;display:block;width:0;height:0}.md .admonition p:last-child{margin-bottom:0}.md li.checked,.md li.unchecked{list-style:none;overflow:visible;text-indent:-1.2em}.md li.checked:before,.md li.unchecked:before{content:"\2611";display:block;float:left;width:1em;font-size:120%}.md li.unchecked:before{content:"\2610"}</style><style>.md h1::before {
content:counter(h1) " ";
counter-increment: h1;margin-right:10px}.md h2::before {
content:counter(h1) "."counter(h2) " ";
counter-increment: h2;margin-right:10px}.md h3::before {
content:counter(h1) "."counter(h2) "."counter(h3) " ";
counter-increment: h3;margin-right:10px}.md h4::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) " ";
counter-increment: h4;margin-right:10px}.md h5::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) "."counter(h5) " ";
counter-increment: h5;margin-right:10px}.md h6::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) "."counter(h5) "."counter(h6) " ";
counter-increment: h6;margin-right:10px}</style><style>.hljs{display:block;overflow-x:auto;padding:0.5em;background:#fff;color:#000;-webkit-text-size-adjust:none}.hljs-comment{color:#006a00}.hljs-keyword{color:#02E}.hljs-literal,.nginx .hljs-title{color:#aa0d91}.method,.hljs-list .hljs-title,.hljs-tag .hljs-title,.setting .hljs-value,.hljs-winutils,.tex .hljs-command,.http .hljs-title,.hljs-request,.hljs-status,.hljs-name{color:#008}.hljs-envvar,.tex .hljs-special{color:#660}.hljs-string{color:#c41a16}.hljs-tag .hljs-value,.hljs-cdata,.hljs-filter .hljs-argument,.hljs-attr_selector,.apache .hljs-cbracket,.hljs-date,.hljs-regexp{color:#080}.hljs-sub .hljs-identifier,.hljs-pi,.hljs-tag,.hljs-tag .hljs-keyword,.hljs-decorator,.ini .hljs-title,.hljs-shebang,.hljs-prompt,.hljs-hexcolor,.hljs-rule .hljs-value,.hljs-symbol,.hljs-symbol .hljs-string,.hljs-number,.css .hljs-function,.hljs-function .hljs-title,.coffeescript .hljs-attribute{color:#A0C}.hljs-function .hljs-title{font-weight:bold;color:#000}.hljs-class .hljs-title,.smalltalk .hljs-class,.hljs-type,.hljs-typename,.hljs-tag .hljs-attribute,.hljs-doctype,.hljs-class .hljs-id,.hljs-built_in,.setting,.hljs-params,.clojure .hljs-attribute{color:#5c2699}.hljs-variable{color:#3f6e74}.css .hljs-tag,.hljs-rule .hljs-property,.hljs-pseudo,.hljs-subst{color:#000}.css .hljs-class,.css .hljs-id{color:#9b703f}.hljs-value .hljs-important{color:#ff7700;font-weight:bold}.hljs-rule .hljs-keyword{color:#c5af75}.hljs-annotation,.apache .hljs-sqbracket,.nginx .hljs-built_in{color:#9b859d}.hljs-preprocessor,.hljs-preprocessor *,.hljs-pragma{color:#643820}.tex .hljs-formula{background-color:#eee;font-style:italic}.diff .hljs-header,.hljs-chunk{color:#808080;font-weight:bold}.diff .hljs-change{background-color:#bccff9}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-comment .hljs-doctag{font-weight:bold}.method .hljs-id{color:#000}</style><style>div.title { padding-top: 40px; } div.afterTitles { height: 15px; }</style><meta charset="utf-8">
<link rel="stylesheet" href="../css/style.css">

<span class="md"><p><title>Day 2. Opening a Win32 Window</title><div class="title"> Day 2. Opening a Win32 Window </div>

<div class="afterTitles"></div>
<em class="underscore">Video Length: <a href="https://hero.handmade.network/episode/code/day002/">1h00</a></em>

</p><p>

Welcome to &ldquo;Handmade Hero Notes&rdquo;, the book where we follow the footsteps of <a href="https://handmadehero.org/">Handmade Hero</a> in making the complete game from scratch, with no external libraries. If you'd like to follow along, preorder the game on <a href="https://handmadehero.org/">handmadehero.org</a>, and you will receive access to the GitHub repository, containing complete source code (tagged day-by-day) as well as a variety of other useful resources.

</p><p>

<a href="day1.html">Last time</a>, we set up our dev environment allowing us to launch our text editor (we showcased <a href="https://4coder.itch.io/4coder">4coder</a> and <a href="https://code.visualstudio.com/">Visual Studio Code</a>). We then created a simple Win32 application launching a modest message box. We made a &ldquo;make file&rdquo; for it, just batch file compiling something directly into the <code>build</code> directory. We then learned how to launch the debugger (<a href="https://remedybg.itch.io/remedybg">RemedyBG</a> or Visual Studio), with some simple actions like stepping into our code. 

</p><p>

But a message box is not a very useful thing for a game to pop up; in fact, if you ever <em class="underscore">see</em> one pop up in a game, this usually means that the game has encountered a very serious error, and it's not something you'd ever want to have. What we'll try to do is to open a window which is a bit more useful. 

</p><p>

The window that we are going to open is a basic Windows one. All the programs go through a specific path for opening a window, and we're going to follow that path as well, for a while. But shortly after we are going to create a special <em class="underscore">buffer</em> in memory which we can write to ourselves, do all the rendering into and, once we're ready, display in the window.

</p><p>

<div class="admonition ">This is not exactly how a modern game would start up. Modern games pretty much exclusively let the graphics card do their work for them. While we will eventually get there, it's not a very good start for educational purposes. Unfortunately, the GPU is a pretty opaque resource where we have a very limited insight into what it's doing to render graphics for our game.</div>

</p>
<div class="longTOC">
    <p align="center">
        <span align="left"><a href="day1.html">Day 1</a></span>
        <a href="../index.html"><img src = "../media/logo.png"></a>
        <span align="right"><a href="day3.html">Day 3</a></span>
    </p>
    <p><a href="#" class="tocTop">(Top)</a><br/>
<a href="#windowclass" class="level1"><span class="tocNumber">1&nbsp; </span>Window Class</a><br/>
&nbsp;&nbsp;<a href="#windowclass/wndclassaimplementation" class="level2"><span class="tocNumber">1.1&nbsp; </span>WNDCLASSA Implementation</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#windowclass/wndclassaimplementation/windowclassvaluesbeforeandafterinitialization" class="level3"><span class="tocNumber">1.1.1&nbsp; </span>WindowClass Values Before and After Initialization</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#windowclass/wndclassaimplementation/fillingoutthewindowclass" class="level3"><span class="tocNumber">1.1.2&nbsp; </span>Filling out the WindowClass</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#windowclass/wndclassaimplementation/windowclassstyle" class="level3"><span class="tocNumber">1.1.3&nbsp; </span>Window Class Style</a><br/>
<a href="#mainwindowcallback" class="level1"><span class="tocNumber">2&nbsp; </span>Main Window Callback</a><br/>
&nbsp;&nbsp;<a href="#mainwindowcallback/refactoring:renamevariables" class="level2"><span class="tocNumber">2.1&nbsp; </span>Refactoring: Rename Variables</a><br/>
&nbsp;&nbsp;<a href="#mainwindowcallback/processsomemessages" class="level2"><span class="tocNumber">2.2&nbsp; </span>Process Some Messages</a><br/>
&nbsp;&nbsp;<a href="#mainwindowcallback/getaresult" class="level2"><span class="tocNumber">2.3&nbsp; </span>Get a Result</a><br/>
<a href="#registerthewindowclass" class="level1"><span class="tocNumber">3&nbsp; </span>Register the WindowClass</a><br/>
<a href="#createawindow" class="level1"><span class="tocNumber">4&nbsp; </span>Create a Window</a><br/>
&nbsp;&nbsp;<a href="#createawindow/windowmessagequeue" class="level2"><span class="tocNumber">4.1&nbsp; </span>Window Message Queue</a><br/>
&nbsp;&nbsp;<a href="#createawindow/translatinganddispatchingmessages" class="level2"><span class="tocNumber">4.2&nbsp; </span>Translating and Dispatching Messages</a><br/>
<a href="#drawingsomethingtoourwindow" class="level1"><span class="tocNumber">5&nbsp; </span>Drawing Something to Our Window</a><br/>
&nbsp;&nbsp;<a href="#drawingsomethingtoourwindow/&ldquo;animating&rdquo;thewindow" class="level2"><span class="tocNumber">5.1&nbsp; </span>&ldquo;Animating&rdquo; the Window</a><br/>
<a href="#recap" class="level1"><span class="tocNumber">6&nbsp; </span>Recap</a><br/>
<a href="#exercises" class="level1"><span class="tocNumber">7&nbsp; </span>Exercises</a><br/>
&nbsp;&nbsp;<a href="#exercises/interceptmoremessages" class="level2"><span class="tocNumber">7.1&nbsp; </span>Intercept More Messages</a><br/>
&nbsp;&nbsp;<a href="#exercises/customwindowoptions" class="level2"><span class="tocNumber">7.2&nbsp; </span>Custom Window Options</a><br/>
<a href="#programmingbasics" class="level1"><span class="tocNumber">8&nbsp; </span>Programming Basics</a><br/>
&nbsp;&nbsp;<a href="#programmingbasics/concerningtypedefs" class="level2"><span class="tocNumber">8.1&nbsp; </span>Concerning typedefs</a><br/>
&nbsp;&nbsp;<a href="#programmingbasics/structinitialization" class="level2"><span class="tocNumber">8.2&nbsp; </span>Struct Initialization</a><br/>
&nbsp;&nbsp;<a href="#programmingbasics/switchstatements" class="level2"><span class="tocNumber">8.3&nbsp; </span>Switch Statements</a><br/>
&nbsp;&nbsp;<a href="#programmingbasics/pointers" class="level2"><span class="tocNumber">8.4&nbsp; </span>Pointers</a><br/>
&nbsp;&nbsp;<a href="#programmingbasics/loops" class="level2"><span class="tocNumber">8.5&nbsp; </span>Loops</a><br/>
<a href="#navigation" class="level1"><span class="tocNumber">9&nbsp; </span>Navigation</a><br/>
</p></div><a class="target" name="windowclass">&nbsp;</a><a class="target" name="windowclass">&nbsp;</a><a class="target" name="toc1">&nbsp;</a><h1>Window Class</h1>
<p>


From the earliest days of Windows, to start out opening your windows you had to declare and register a Window Class (i.e. <code>WNDCLASS</code>). If we open up <a href="https://docs.microsoft.com/en-us/">MSDN</a>, we can quickly find the relevant article (in this case, we need a simple <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassa">WNDCLASSA</a> structure<sup><a href="#endnote-awnotation">1</a></sup>). This is how it looks: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagWNDCLASSA</span> {</span></span>
<span class="line">  UINT      style;</span>
<span class="line">  WNDPROC   lpfnWndProc;</span>
<span class="line">  <span class="hljs-keyword">int</span>       cbClsExtra;</span>
<span class="line">  <span class="hljs-keyword">int</span>       cbWndExtra;</span>
<span class="line">  HINSTANCE hInstance;</span>
<span class="line">  HICON     hIcon;</span>
<span class="line">  HCURSOR   hCursor;</span>
<span class="line">  HBRUSH    hbrBackground;</span>
<span class="line">  LPCSTR    lpszMenuName;</span>
<span class="line">  LPCSTR    lpszClassName;</span>
<span class="line">} WNDCLASSA, *PWNDCLASSA, *NPWNDCLASSA, *LPWNDCLASSA;</span></code></pre><center><div class="listingcaption tilde"><file>[MSDN]</file> Window Class structure syntax.</div></center>
<p>


If you're unfamiliar with the Windows' way of decorating its structs and functions, it might look quite scary! Don't worry about it too much though. And, if you'd like to learn more about what this all means, we dive deeper in Subsection  <a href="#toc8.1">8.1</a>.

</p>
<a class="target" name="wndclassaimplementation">&nbsp;</a><a class="target" name="windowclass/wndclassaimplementation">&nbsp;</a><a class="target" name="toc1.1">&nbsp;</a><h2>WNDCLASSA Implementation</h2>
<p>


We now have our <code>WNDCLASSA</code> that we want to define in our program. This is a recurring pattern in the Win32 API: In order to do some function you need to: 

</p><p>

<ol start=1>
<li class="number">Create a struct.
</li>
<li class="number">Fill it out with as desired.
</li>
<li class="number">Call a function with this struct as a parameter.</li></ol>

</p><p>

The struct therefore serves as a parameter list to the function you are calling, a set of informational variables to communicate to a function when you call it<sup><a href="#endnote-bitwiseor">2</a></sup>. Let's do just that: 

</p><pre class="listing tilde"><code><div class=" delete"><span class="line">MessageBoxA(<span class="hljs-number">0</span>, <span class="hljs-string">"This is Handmade Hero."</span>, <span class="hljs-string">"Handmade Hero"</span>, MB_ICONINFORMATION | MB_OK);</span></div><div class=" add"><span class="line">WNDCLASSA WindowClass = {}; </span></div><span class="line"><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;1:</b> <file>[win32_handmade.cpp]</file> Defining our <code>WNDCLASSA</code>.</div></center>
<p>


You will note that we added a couple of braces (<code>{}</code>). This allows us to initialize the whole struct to <code>0</code>. For more information, read <a href="#structinitialization">Struct Initialization</a> subsection.

</p>
<a class="target" name="windowclassvaluesbeforeandafterinitialization">&nbsp;</a><a class="target" name="windowclass/wndclassaimplementation/windowclassvaluesbeforeandafterinitialization">&nbsp;</a><a class="target" name="toc1.1.1">&nbsp;</a><h3>WindowClass Values Before and After Initialization</h3>
<p>


Let's see what's going on in here, under the hood. Compile your program and head out to the debugger. 

</p><p>

In RemedyBG or Visual Studio debugger, if you press <code>F9</code> next to your WindowClass declaration, you'll see a red circle appearing next to the line. This means you set up a <em class="underscore">breakpoint</em>: a point where the program will stop and let you inspect its state. You then should find your <code>Watch</code> window and type in the name of your WindowClass structure. 

</p><p>

If you did everything correctly, once you run the program (<code>F5</code>) it should halt at the line you highlighted, and the current value of <code>WindowClass</code> appear in your <code>Watch</code> window:

</p><p>

<center><div class="image" style=""><a href="../media/day2/debug1.png" target="_blank"><img class="markdeep" src="../media/day2/debug1.png" /></a><center><span class="imagecaption"><a class="target" name="figure_x">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;1:</b> Inspecting WindowClass</span></center></div></center>

</p><p>

As you can see, the values are completely random. This is because the program actually stops <em class="underscore">before</em> the line is executed, and the values in <code>WindowClass</code> are garbage. You wouldn't want to pass this struct to any function! But if you hit <code>F11</code> once to <em class="underscore">step over</em> this line, you will notice that all the values in the struct have been cleared to 0 (which is what we wanted):

</p><p>

<center><div class="image" style=""><a href="../media/day2/debug2.png" target="_blank"><img class="markdeep" src="../media/day2/debug2.png" /></a><center><span class="imagecaption"><a class="target" name="figure_x">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;2:</b> Inspecting WindowClass</span></center></div></center>

</p><p>

<div class="admonition tip"><div class="admonition-title"> Zero Is Initialization</div>

</p><p>

    Unless the code is in a performance-critical area, it is a good practice to apply the so-called <em class="underscore">Zero is Initialization</em> principle. For most of the code we won't be using any constructors or other advanced initialization techniques of C++. As long as it was cleared to zero, most structures would work fine moving forward. 

</p><p>

    This is quite different from a C++ model where everything has a constructor, and there's a lot of things happening at the start of the life of a variable. 

</p><p>

    In a performance-critical area, even the &ldquo;initialize to zero&rdquo; step are to be skipped. The variables will be immediately initialized with specific values.</div>

</p>
<a class="target" name="fillingoutthewindowclass">&nbsp;</a><a class="target" name="windowclass/wndclassaimplementation/fillingoutthewindowclass">&nbsp;</a><a class="target" name="toc1.1.2">&nbsp;</a><h3>Filling out the WindowClass</h3>
<p>


Let's look back at the members of our WindowClass: 

</p><pre class="listing tilde"><code><span class="line">UINT      style;</span>
<span class="line">WNDPROC   lpfnWndProc;</span>
<span class="line"><span class="hljs-keyword">int</span>       cbClsExtra;</span>
<span class="line"><span class="hljs-keyword">int</span>       cbWndExtra;</span>
<span class="line">HINSTANCE hInstance;</span>
<span class="line">HICON     hIcon;</span>
<span class="line">HCURSOR   hCursor;</span>
<span class="line">HBRUSH    hbrBackground;</span>
<span class="line">LPCSTR    lpszMenuName;</span>
<span class="line">LPCSTR    lpszClassName;</span></code></pre><center><div class="listingcaption tilde"><file>[MSDN]</file> <code>WNDCLASSA</code> members.</div></center>
<p>


Which ones do we want? We want to skip a few, and some definitely want to fill out. Let's replace start assigning the fields that we need and remove the ones that we don't: 

</p><p>

<ul>
<li class="asterisk"><code>style</code>: a bit field which sets the properties of our window to have. 
</li>
<li class="asterisk"><code>lpfnWndProc</code>: a <em class="underscore">pointer</em> to the window function that we will define in a second. This function defines how the window responds to <em class="underscore">events</em>.
</li>
<li class="asterisk"><code>cbClsExtra</code>: how many extra bytes we need to store alongside our <code>WindowProc</code>. We don't really need to do it, so we delete it.
</li>
<li class="asterisk"><code>cbWndExtra</code>: same as <code>cbWndExtra</code>, it allows to reserve some extra memory, this time for the window. Again, we don't have a use for it.
</li>
<li class="asterisk"><code>hInstance</code>: the instance <em class="underscore">handle</em> of the currently running code. We have received <code>hInstance</code> with our <code>WinMain</code> so we can simply pass it along 
<ul>
    <li class="asterisk">If we didn't, there's a handy <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea">Kernel call</a> <code>GetModuleHandle(0)</code>, which returns just the same thing.
</li></ul>
<li class="asterisk"><code>hIcon</code>: handle for our game icon. For now, we will comment it out and return to it once we're ready to set the icon for our game (much later down the line).
</li>
<li class="asterisk"><code>hCursor</code>: handle for the cursor. Our game will not have a cursor, so we'll leave it at 0.
</li>
<li class="asterisk"><code>hbrBackground</code>: allows to clear the background for us, these are relevant if we're using [Windows Brushes]. We don't need this, so it can also go.
</li>
<li class="asterisk"><code>lpszMenuName</code>: the name for your menu if you use the default Windows one. We don't want this, either.
</li>
<li class="asterisk"><code>lpszClassName</code>: Name for our Window Class. We need it because, once we create our window, we'll need to pass the class name again for the window to use.</li></ul>

</p><pre class="listing tilde"><code><span class="line">WNDCLASSA WindowClass = {}; </span>
<span class="line"></span><div class=" add"><span class="line">WindowClass.style = ;</span>
<span class="line">WindowClass.lpfnWndProc = ;</span>
<span class="line">WindowClass.hInstance = hInstance;</span>
<span class="line"><span class="hljs-comment">// WindowClass.hIcon;</span></span>
<span class="line">WindowClass.lpszClassName = <span class="hljs-string">"HandmadeHeroWindowClass"</span>;</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;2:</b> <file>[win32_handmade.cpp]</file> Selecting the <code>Window Class</code> fields that we don't need to have set to 0.</div></center>
<p>


This leaves us with 4, potentially 5 values to set out of 10, the rest are cleared to 0. Let's go back to the couple values we do need to think a bit harder about.

</p>
<a class="target" name="windowclassstyle">&nbsp;</a><a class="target" name="windowclass/wndclassaimplementation/windowclassstyle">&nbsp;</a><a class="target" name="toc1.1.3">&nbsp;</a><h3>Window Class Style</h3>
<p>


<code>UINT style</code> is of type <code>UINT</code>, which is defined by Windows to be a 32-bit unsigned integer (a.k.a. <code>unsigned int</code>). You can set it as specified in the <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/window-class-styles">Window Class Styles</a> guide. In here, you will find several values which, as many things in Windows by now are there more for legacy support purposes. We are however interested in a couple: 

</p><p>

<div class="admonition tip">Remember to use <a href="https://docs.microsoft.com/en-us/">MSDN</a>! You won't always remember these things, even the veteran Windows programmers constantly consult with the documentation. 

</p><p>

    MSDN is your friend; it will tell you what you need to know.</div>

</p><p>

<ul>
<li class="asterisk"><code>CS_CLASSDC</code> / <code>CS_OWNDC</code>: Allocates a <em class="underscore">Device Context</em> per class / window. 
<ul>
    <li class="asterisk">Device Context is a structure used by Windows to keep the state of a drawing while we're drawing to the window. It was initially intended to be used in conjunction with the <a href="https://docs.microsoft.com/en-us/windows/win32/gdi/using-brushes">brushes</a>. 
</li>
    <li class="asterisk">Normally, Windows would have several device contexts available. When a program needs to draw, it gets one, uses it and then gives it back. 
</li>
    <li class="asterisk"><code>CS_CLASSDC</code> / <code>CS_OWNDC</code> allows programs to declare their intent of focusing on graphics. In this case, there would be no reason of <em class="underscore">sharing</em> a device context. <code>CS_CLASSDC</code> allows a class to request unique ownership rights for one device context, while <code>CS_OWNDC</code> would request a unique device context <em class="underscore">per window</em>. 
</li>
    <li class="asterisk">In the end, <code>CS_OWNDC</code> is the one we're going to use, if only for the peace of mind. We won't have to return here if we ever decide to open a new window. 
</li></ul>
<li class="asterisk"><code>CS_HREDRAW</code> / <code>CS_VREDRAW</code>: Redraws the entire window (as opposed to only the affected piece) if movement or resizing changes the width/height of the <em class="underscore">client area</em> (in case of movement, this would happen if part of the window goes off screen). We want to use both here.</li></ul>

</p><p>

At this point however, we need to verify if all of these options are even relevant anymore in this day and age. Let's put a <code>TODO</code> note so that we can return to at a later stage. It might be an interesting exploration journey at some point, but for now we'll set it aside. 

</p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-comment">// TODO(casey): Check if HREDRAW/VREDRAW/OWNDC still matter</span></span></div><div class=" edit"><span class="line">WindowClass.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;</span></div><span class="line">WindowClass.lpfnWndProc = ;</span>
<span class="line">WindowClass.hInstance = hInstance;</span>
<span class="line"><span class="hljs-comment">// WindowClass.hIcon;</span></span>
<span class="line">WindowClass.lpszClassName = <span class="hljs-string">"HandmadeHeroWindowClass"</span>;</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;3:</b> <file>[win32_handmade.cpp]</file> Adding the style options and our first <code>TODO</code>.</div></center>

<a class="target" name="mainwindowcallback">&nbsp;</a><a class="target" name="mainwindowcallback">&nbsp;</a><a class="target" name="toc2">&nbsp;</a><h1>Main Window Callback</h1>
<p>


Now, we have one element remaining: the mysterious <code>lpfnWndProc</code>. What is that? And how would you have known what it was if this guide wasn't here to tell you? Well, here's another example of how <a href="https://docs.microsoft.com/en-us/">MSDN</a> can help you. 

</p><p>

If you look at the <code>Members</code> section of <code>WNDCLASSA</code> <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassa">article</a>, you will see that <code>lpfnWndProc</code> is a &ldquo;pointer to the window procedure. [...] For more information, see WindowProc.&rdquo; If you follow the <a href="WindowProc">link</a> to the latter, you will see that this new article defines what that procedure is right there, in the <code>Syntax</code> window: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowProc</span><span class="hljs-params">(</span>
<span class="line">  HWND   hwnd,</span>
<span class="line">  UINT   uMsg,</span>
<span class="line">  WPARAM wParam,</span>
<span class="line">  LPARAM lParam</span>
<span class="line">)</span></span>;</span></code></pre><center><div class="listingcaption tilde"><file>[MSDN]</file> Signature for a <code>WindowProc</code> function.</div></center>
<p>


As you can see, this is a <em class="underscore">CALLBACK</em>. The keyword CALLBACK is exactly what it sounds like: Windows <em class="underscore">calls us back</em> from its code to have us do something for it. And you can see that it gets passed 4 mysterious parameters: an <code>HWND</code>, a <code>UINT</code>, <code>WPARAM</code> and <code>LPARAM</code>. It also <em class="underscore">returns</em> an <code>LRESULT</code>.

</p><p>

We haven't really dealt with these up until now. Even if we already saw type <code>UINT</code> which is nothing else than a 32-bit unsigned integer, we don't know what it means. We're going to check <a href="https://docs.microsoft.com/en-us/">MSDN</a> and see what all this is, but for now what we do know is that this will be our <em class="underscore">Main Window Callback</em>, so let's implement it as such in our code. As Windows doesn't care how this function will be called (but only of its signature), we will call it just that, <code>MainWindowCallback</code>.

</p><p>

Make sure to add it outside of our <code>WinMain</code>! And inside the <code>WinMain</code>, we can then &ldquo;register&rdquo; it as our <code>lpfnWndProc</code>, which is nothing else than our function name.

</p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-function">LRESULT CALLBACK</span>
<span class="line"><span class="hljs-title">MainWindowCallback</span><span class="hljs-params">(HWND hwnd, </span>
<span class="line">                   UINT uMsg,</span>
<span class="line">                   WPARAM wParam,</span>
<span class="line">                   LPARAM lParam)</span></span>
<span class="line"></span>{</span>
<span class="line">}</span>
<span class="line"></span></div><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> CALLBACK</span>
<span class="line"><span class="hljs-title">WinMain</span><span class="hljs-params">(...)</span> </span>{</span>
<span class="line"><span class="hljs-comment">//...</span></span><div class=" edit"><span class="line">WindowClass.lpfnWndProc = MainWindowCallback;</span></div><span class="line"><span class="hljs-comment">//...</span></span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;4:</b> <file>[win32_handmade.cpp]</file> Adding our Main Window Callback.</div></center>
<p>


This callback will be called any time Windows needs to send something to a window of this class (our <code>WindowClass</code>) to have it do something. 

</p>
<a class="target" name="refactoring:renamevariables">&nbsp;</a><a class="target" name="mainwindowcallback/refactoring:renamevariables">&nbsp;</a><a class="target" name="toc2.1">&nbsp;</a><h2>Refactoring: Rename Variables</h2>
<p>


There's one sidestep that we'd like to make before we move on.

</p><p>

To make things a bit less cryptic, let's rename all our variables to something more understandbale to us. Thus, our <code>hInstance</code> becomes <code>Instance</code>, <code>lpCmdLine</code> becomes <code>CommandLine</code>, etc.

</p><p>

Unfortunately, we cannot rename Windows struct members, so we'll have to leave them as they are, but we can easily do it for the functions. This is because in C and C++, the function <em class="underscore">signatures</em> are really only about types. The compiler will only check the <em class="underscore">type</em> of something you're trying to pass (in case of <code>MainWindowCallback</code>, it's <code>HWND, UINT, WPARAM, LPARAM</code>, in this exact sequence). The name of the parameter is up to us, so let's change it to our liking:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-comment">//...</span></span>
<span class="line"></span>
<span class="line">LRESULT CALLBACK</span><div class=" edit"><span class="line">MainWindowCallback(HWND Window, </span>
<span class="line">                   UINT Message,</span>
<span class="line">                   WPARAM WParam,</span>
<span class="line">                   LPARAM LParam)</span></div><div class=" C++ "><span class="line">{</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">int CALLBACK</span></div><div class=" edit"><span class="line">WinMain(HINSTANCE Instance,</span>
<span class="line">        HINSTANCE PrevInstance,</span>
<span class="line">        LPSTR     CommandeLine,</span>
<span class="line">        <span class="hljs-keyword">int</span>       ShowCode)</span></div><span class="line">{</span>
<span class="line">    WNDCLASS WindowClass = {};</span>
<span class="line">    </span>
<span class="line">    WindowClass.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;</span>
<span class="line">    WindowClass.lpfnWndProc = MainWindowCallback;</span><div class=" edit"><span class="line">    WindowClass.hInstance = Instance;</span></div><span class="line">    <span class="hljs-comment">// WindowClass.hIcon;</span></span>
<span class="line">    WindowClass.lpszClassName = <span class="hljs-string">"HandmadeHeroWindowClass"</span>;</span>
<span class="line"></span>
<span class="line"><span class="hljs-comment">//...</span></span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;5:</b> <file>[win32_handmade.cpp]</file> Renaming our variables.</div></center>
<p>




<div class="admonition trivia"><div class="admonition-title"> Trivia: Hungarian Notation</div>

</p><p>

    Older Microsoft's API made use of so-called &ldquo;Hungarian notation&rdquo;. The name refers to its inventor's, Charles Simonyi, country of origin, and also hints at a peculiar way of the Hungarians of saying their last name before the first name. 

</p><p>

    The prefixes and name abbreviations you see here are nothing else that a naming convention adopted when even the space for the source files and variable names was limited, but also to provide clarity to the type this variable brings. Thus, from the name <code>hInstance</code> we can deduce that it's an <code>Instance</code> of type <code>HANDLE</code>, <code>lpCmdLine</code> is a <code>Command Line</code> of type <code>long pointer</code>, etc. 

</p><p>

    Nowadays, many programmers moved away from these conventions and prefer simple and explicit names for their variables, and leave the types at the variable declarations, and the code follows our personal taste of reading them. You can decide whichever way you prefer. 

</p><p>

    One thing however that is recommended pretty much universally is: once you choose a style, stick to it in the whole project. It's very difficult to maintain a codebase which is written in different styles and naming conventions, let alone expand it.

</p><p>

    If you are interested in reading more, check out this <a href="https://en.wikipedia.org/wiki/Hungarian_notation">article on Wikipedia</a>.</div>

</p>
<a class="target" name="processsomemessages">&nbsp;</a><a class="target" name="mainwindowcallback/processsomemessages">&nbsp;</a><a class="target" name="toc2.2">&nbsp;</a><h2>Process Some Messages</h2>
<p>


Let's look at the parameters we're getting for our <code>MainWindowCallback</code> (don't forget about <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">MSDN</a>!):

</p><p>

<ul>
<li class="asterisk"><code>HWND</code>: A handle to the window. This is an opaque (to us) piece of data that we can pass back to Windows to identify a window. It's like Windows says: &ldquo;Hey, here's the handle to your window. If you need to talk to me about the window, pass it back, and I'll know what you mean&rdquo;.
</li>
<li class="asterisk"><code>UINT</code>: The message. This is the coded message that Windows is asking us to handle in the callback. The messages vary greately, and you can find many lists on <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/about-messages-and-message-queues#system-defined-messages">MSDN</a>. As you can see, over the ages the number of messages has grown to become <em class="underscore">absurdly</em> huge, the number of messages you can receive.</li></ul>

</p><p>

That said, most of these messages will be irrelevant for our project, and even less so now that we're starting. &ldquo;Animation Control Messages&rdquo;, &ldquo;Combo boxes&rdquo;... Since we are not going to be using Windows hardly at all (we'll be basically opening a window and then doing everything else ourselves), we mostly care about basic window operations. These all fall under the <code>WM</code> category, and we will not need much else.

</p><p>

The list for <code>WM</code> category is still big. To narrow it down even further for now, let's focus entirely on very a few <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/window-notifications">Window Notifications</a>. 

</p><p>

In order to process messages, we will be using a <code>switch</code>. If you'd like to learn more, check out the <a href="#switchstatements">Switch Statements</a> subsection.

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">LRESULT CALLBACK</span>
<span class="line"><span class="hljs-title">MainWindowCallback</span><span class="hljs-params">(HWND Window, </span>
<span class="line">                   UINT Message,</span>
<span class="line">                   WPARAM WParam,</span>
<span class="line">                   LPARAM LParam)</span></span>
<span class="line"></span>{</span><div class=" add"><span class="line">    <span class="hljs-keyword">switch</span> (Message)</span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-keyword">case</span>:</span>
<span class="line">        {</span>
<span class="line"></span>
<span class="line">        } <span class="hljs-keyword">break</span>;</span>
<span class="line"></span>
<span class="line">        <span class="hljs-keyword">default</span>:</span>
<span class="line">        {</span>
<span class="line">            <span class="hljs-comment">// Do something in case of any other message</span></span>
<span class="line">        } <span class="hljs-keyword">break</span>;</span>
<span class="line">    }</span>
<span class="line">}</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;6:</b> <file>[win32_handmade.cpp]</file> Getting ready to respond to Windows messages.</div></center>
<p>


The constants which you see, for instance, <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/window-notifications">here</a>, are nothing else than unique numbers identifying that message. So which messages do we want to deal with first? 

</p><p>

<ul>
<li class="asterisk"><code>WM_SIZE</code>: When the user changes the size of the window.
</li>
<li class="asterisk"><code>WM_DESTROY</code>: When Windows deletes our window. 
</li>
<li class="asterisk"><code>WM_CLOSE</code>: When the user clicks on that little <strong class="underscore">X</strong> in the top-right corner.
</li>
<li class="asterisk"><code>WM_ACTIVATEAPP</code>: When the user clicked on the window and it became <em class="underscore">active</em>.</li></ul>

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">switch</span> (Message)</span>
<span class="line">{</span><div class=" add"><span class="line">    <span class="hljs-keyword">case</span> WM_SIZE:</span>
<span class="line">    {</span>
<span class="line"></span>
<span class="line">    } <span class="hljs-keyword">break</span>;</span>
<span class="line"></span>
<span class="line">    <span class="hljs-keyword">case</span> WM_DESTROY:</span>
<span class="line">    {</span>
<span class="line"></span>
<span class="line">    } <span class="hljs-keyword">break</span>;</span>
<span class="line">    </span>
<span class="line">    <span class="hljs-keyword">case</span> WM_CLOSE:</span>
<span class="line">    {</span>
<span class="line"></span>
<span class="line">    } <span class="hljs-keyword">break</span>;</span>
<span class="line">    </span>
<span class="line">    <span class="hljs-keyword">case</span> WM_ACTIVATEAPP:</span>
<span class="line">    {</span>
<span class="line"></span>
<span class="line">    } <span class="hljs-keyword">break</span>;</span>
<span class="line"></span></div><span class="line">    <span class="hljs-keyword">default</span>:</span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-comment">// Do something in case of any other message</span></span>
<span class="line">    } <span class="hljs-keyword">break</span>;</span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;7:</b> <file>[win32_handmade.cpp]</file> Defining our first cases.</div></center>
<p>


For now, we are not going to do anything useful inside these cases. We will only output to the debug console when these messages fire. To do that, we're going to call the function <a href="https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-outputdebugstringa">OutputDebugStringA</a>. 

</p><p>

As you can see from its <a href="https://docs.microsoft.com/en-us/">MSDN</a> article, this function takes simply a <code>LPSTR</code>, a string, as the text to output. We will use it to output the message name and <code>newline</code> symbol (<code>\n</code>). In order to see the message, you should be <code>debugging</code> the program, and the messages will go in the <code>Output</code> window of your debugger.

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-keyword">case</span> WM_SIZE:</span>
<span class="line">    {</span><div class=" add"><span class="line">        OutputDebugStringA(<span class="hljs-string">"WM_SIZE\n"</span>);</span></div><span class="line">    } <span class="hljs-keyword">break</span>;</span>
<span class="line"></span>
<span class="line">    <span class="hljs-keyword">case</span> WM_DESTROY:</span>
<span class="line">    {</span><div class=" add"><span class="line">        OutputDebugStringA(<span class="hljs-string">"WM_DESTROY\n"</span>);</span></div><span class="line">    } <span class="hljs-keyword">break</span>;</span>
<span class="line">    </span>
<span class="line">    <span class="hljs-keyword">case</span> WM_CLOSE:</span>
<span class="line">    {</span><div class=" add"><span class="line">        OutputDebugStringA(<span class="hljs-string">"WM_CLOSE\n"</span>);</span></div><span class="line">    } <span class="hljs-keyword">break</span>;</span>
<span class="line">    </span>
<span class="line">    <span class="hljs-keyword">case</span> WM_ACTIVATEAPP:</span>
<span class="line">    {</span><div class=" add"><span class="line">        OutputDebugStringA(<span class="hljs-string">"WM_ACTIVATEAPP\n"</span>);</span></div><span class="line">    } <span class="hljs-keyword">break</span>;</span>
<span class="line"></span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;8:</b> <file>[win32_handmade.cpp]</file> &ldquo;Responding&rdquo; to the first cases.</div></center>

<a class="target" name="getaresult">&nbsp;</a><a class="target" name="mainwindowcallback/getaresult">&nbsp;</a><a class="target" name="toc2.3">&nbsp;</a><h2>Get a Result</h2>
<p>


As it is now, we still won't be able to compile our program. The compiler (and, later, Windows), will expect us to return to whoever called the function a specific parameter of type <code>LRESULT</code> (as it says on its signature). It was a similar case for <code>WinMain</code>, where we returned a <code>0</code>. As a bit of refresher, here is the signature for a <code>WindowProc</code>:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowProc</span><span class="hljs-params">(</span>
<span class="line">  HWND   hwnd,</span>
<span class="line">  UINT   uMsg,</span>
<span class="line">  WPARAM wParam,</span>
<span class="line">  LPARAM lParam</span>
<span class="line">)</span></span>;</span></code></pre><center><div class="listingcaption tilde"><file>[MSDN]</file> Signature for a <code>WindowProc</code> function.</div></center>
<p>


The type <code>LRESULT</code> is simply a return code saying what we did with the message. From its <a href="https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types#lresult">type definition</a> we can further see that it's a <code>Long pointer</code> (i.e. up to 64 bits). Windows will give potentially different meanings to this result, depending on the message that was passed in first place. 

</p><p>

How do we know which <code>LRESULT</code> to return when? We look at the documentation, of course! For instance, <a href="https://docs.microsoft.com/en-us/">MSDN</a> tells us that if we deal with <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/wm-close">WM_CLOSE</a> and process the message, <code>LRESULT</code> should be <code>0</code>. This is actually true for most cases, so let's initialize our LRESULT to <code>0</code> and also return it at the end. If we'll want to change our <code>Result</code>, we'll be able to do so inside a respective message's <code>case</code> block.

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">LRESULT CALLBACK</span>
<span class="line"><span class="hljs-title">MainWindowCallback</span><span class="hljs-params">(HWND Window, </span>
<span class="line">                   UINT Message,</span>
<span class="line">                   WPARAM WParam,</span>
<span class="line">                   LPARAM LParam)</span></span>
<span class="line"></span>{</span><div class=" add"><span class="line">    LRESULT Result = <span class="hljs-number">0</span>;</span></div><span class="line">    <span class="hljs-keyword">switch</span> (Message)</span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-comment">//...</span></span>
<span class="line">    }</span>
<span class="line"></span><div class=" add"><span class="line">    <span class="hljs-keyword">return</span> (Result);</span></div><span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;9:</b> <file>[win32_handmade.cpp]</file> Defining the LRESULT.</div></center>
<p>


Finally, let's deal with our <code>default</code> case. This is going to be a catch-all for allll those myriads of messages that Windows would decide to throw our way and that we will essentially ignore. In our <code>default</code> case, <code>Result</code> is going to be... whatever Windows decides it to be. 

</p><p>

<div class="admonition ">Windows has already defined a default case for each and every message it gives us. So all we need to do is to ask Windows to produce the default result based on our <code>Window, Message, WParam</code> and <code>LParam</code>. To get this default treatment, we need to simply call the function called 

</p><p>

    In this sense, our function positions itself between Windows and Windows. We say: before this message gets any further, let's see if <em class="underscore">we</em> are interested in treating it in some way (in this case: is it one of these 4 we care about?). If so, that's it, move along, if not you can deal with it in the manner you see fit. Even more than that: sometimes we will want to do something extra on top of the default treatment a message gets. We will deal with that message and then pass it <em class="underscore">back</em> to Windows for default process.</div>

</p><p>

The default Windows procedure is actually documented in <em class="underscore">all</em> the message-related articles on <a href="https://docs.microsoft.com/en-us/">MSDN</a>, and is called <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-defwindowproca">DefWindowProc</a>. 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">LRESULT WINAPI <span class="hljs-title">DefWindowProcA</span><span class="hljs-params">(</span>
<span class="line">  HWND   hWnd,</span>
<span class="line">  UINT   Msg,</span>
<span class="line">  WPARAM wParam,</span>
<span class="line">  LPARAM lParam</span>
<span class="line">)</span></span>;</span></code></pre><center><div class="listingcaption tilde"><file>[MSDN]</file> Signature for the <code>DefWindowProcA</code><sup><a href="#endnote-awnotation">1</a></sup>.</div></center>
<p>


As you can see, this function has the exact same function signature as our <code>MainWindowCallback</code>. The only difference is, instead of being a <code>CALLBACK</code> as we are, it's a <code>WINAPI</code> (which means that we are calling it instead)<sup><a href="#endnote-winapi">3</a></sup>. Let's  call it in our <code>default</code> case:

</p><pre class="listing tilde"><code><span class="line">    LRESULT Result = <span class="hljs-number">0</span>;</span>
<span class="line"></span>
<span class="line">    <span class="hljs-keyword">switch</span> (Message)</span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-comment">//...</span></span>
<span class="line">        <span class="hljs-keyword">default</span>:</span>
<span class="line">        {</span><div class=" add"><span class="line">            Result = DefWindowProc(Window, Message, WParam, LParam);</span></div><span class="line">        } <span class="hljs-keyword">break</span>;</span>
<span class="line">    }</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;10:</b> <file>[win32_handmade.cpp]</file> Calling <code>DefWindowProc</code>.</div></center>
<p>


We're simply passing down the same parameters we were passed. We don't care what they mean and what they are, we just pass them along. Our task will be to figure out a response to the messages we chose.

</p><p>

We now have a (very barebones) callback function. let's quickly compile to ensure that we compile successfully. 

</p><pre class="listing tilde"><code><div class=" input"><span class="line">W:\handmade\&gt;build</span></div><span class="line">A subdirectory or file build already exists.</span>
<span class="line">Microsoft (R) C/C++ Optimizing Compiler Version ##.##.##### for x64</span>
<span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span>
<span class="line"></span>
<span class="line">win32_handmade.cpp</span>
<span class="line">Microsoft (R) Incremental Linker Version ##.##.#####.#</span>
<span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span>
<span class="line"></span>
<span class="line">/out:win32_handmade.exe</span>
<span class="line">/debug</span>
<span class="line">win32_handmade.obj</span>
<span class="line">user32.lib</span>
<span class="line"></span>
<span class="line">W:\handmade\&gt; _</span></code></pre><center><div class="listingcaption tilde"><file>[Command Prompt]</file> Compiling... Success!</div></center>
<p>




<div class="admonition ">If you aren't getting a successful compile right away, try to go back until you reach your last successful compile to understand something you might have missed.</div>

</p>
<a class="target" name="registerthewindowclass">&nbsp;</a><a class="target" name="registerthewindowclass">&nbsp;</a><a class="target" name="toc3">&nbsp;</a><h1>Register the WindowClass</h1>
<p>


We're almost ready of opening our window using our WindowClass, but before we can do it, we need to <em class="underscore">register</em> the latter.
It's as easy as calling a function may be. The function in question is called <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclassa">RegisterClassA</a>. It takes a <em class="underscore">pointer</em> to a <code>WNDCLASS</code> structure and... that's it. 

</p><p>

<div class="admonition note"><div class="admonition-title"> </div>

</p><p>

    If you'd like to learn more about the pointers, check out subsection  <a href="#toc8.4">8.4</a>.</div>

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-comment">// WinMain</span></span>
<span class="line">    WindowClass.lpszClassName = <span class="hljs-string">"HandmadeHeroWindowClass"</span>;</span><div class=" add"><span class="line">    RegisterClassA(&amp;WindowClass);</span></div><div class=" C++ "><span class="line">    return(0);</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;11:</b> <file>[win32_handmade.cpp]</file> Registering the class.</div></center>
<p>




<div class="admonition trivia"><div class="admonition-title"> ATOMs</div>

</p><p>

    If you look in the syntax of <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclassa">RegisterClassA</a> function, you will see that it returns an <code>ATOM</code>. Nowadays it's a mostly obsolete type that is used to create windows and in a small bunch of other functions. Even there, this use is purely optional.

</p><p>

    In fact, an <em class="underscore">atom table</em> is a &ldquo;system-defined table that stores strings&rdquo; and their IDs. An <code>ATOM</code> is just that, an ID of that can be converted to a string.

</p><p>

    If you are interested in learning more, check out <a href="https://docs.microsoft.com/en-us/windows/win32/dataxchg/about-atom-tables">this article on MSDN</a>.</div>

</p><p>

Registering <code>RegisterClass</code> <em class="underscore">could</em> fail, and in that case it will return <code>0</code>. It's highly improbable, it almost never happens, but it <em class="underscore">might</em> happen. Let's ensure that <code>0</code> is <em class="underscore">not</em> returned to us before we proceed. We will use it by putting the <code>RegisterClass</code> function as the criteria of an <code>if</code> statement. If the value is not <code>0</code>, we continue the program; if it is, we simply exit. 

</p><p>

As for the case when it fails? In the future we might create an advanced logging system to report the error, so let's leave a TODO for it: 

</p><pre class="listing tilde"><code><div class=" edit"><span class="line">    <span class="hljs-keyword">if</span> (RegisterClassA(&amp;WindowClass))</span></div><div class=" add"><span class="line">    {</span>
<span class="line">        <span class="hljs-comment">// Window Class Registration successful, the rest of our WinMain</span></span>
<span class="line">        <span class="hljs-comment">// the rest of our WinMain</span></span>
<span class="line">    }</span>
<span class="line">    <span class="hljs-keyword">else</span></span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-comment">// Window Class Registration failed</span></span>
<span class="line">        <span class="hljs-comment">// TODO(casey): Logging</span></span>
<span class="line">    }</span></div><div class=" C++ "><span class="line">    return(0);</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;12:</b> <file>[win32_handmade.cpp]</file> Registering the class and checking if it was successul.</div></center>

<a class="target" name="createawindow">&nbsp;</a><a class="target" name="createawindow">&nbsp;</a><a class="target" name="toc4">&nbsp;</a><h1>Create a Window</h1>
<p>


So now we're finally getting to today's objective! Let's create a window! The function responsible for it is called... <code>CreateWindow</code>. There are two versions of it: an old version, <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-CreateWindowA">CreateWindowA</a>, and a newer version?. The only difference is that <code>Ex</code> function allows to specify more window style options. Let's go for the latter. 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">HWND <span class="hljs-title">CreateWindowExA</span><span class="hljs-params">(</span>
<span class="line">  DWORD     dwExStyle,</span>
<span class="line">  LPCSTR    lpClassName,</span>
<span class="line">  LPCSTR    lpWindowName,</span>
<span class="line">  DWORD     dwStyle,</span>
<span class="line">  <span class="hljs-keyword">int</span>       X,</span>
<span class="line">  <span class="hljs-keyword">int</span>       Y,</span>
<span class="line">  <span class="hljs-keyword">int</span>       nWidth,</span>
<span class="line">  <span class="hljs-keyword">int</span>       nHeight,</span>
<span class="line">  HWND      hWndParent,</span>
<span class="line">  HMENU     hMenu,</span>
<span class="line">  HINSTANCE hInstance,</span>
<span class="line">  LPVOID    lpParam</span>
<span class="line">)</span></span>;</span></code></pre><center><div class="listingcaption tilde"><file>[MSDN]</file> <code>CreateWindowExA</code> syntax.</div></center>
<p>


Wow, that's a lot of parameters! But they are all quite straightforward, we'll go through them one by one. 

</p><p>

This function returns a <code>HWND</code>, a <em class="underscore">handle</em> to the created window. We will need it for other things, so let's store it in a variable <code>Window</code>. 

</p><p>

<ul>
<li class="asterisk"><code>dwExStyle</code> (extended style): this is one of those <em class="underscore">bit fields</em> like the one we've seen in the WindowClass style. By now you should know the drill: find <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/extended-window-styles">documentation</a>, choose the style options that you want, and chain them together using the bitwise OR operator (<code>|</code>). Which option do we want? Actually none for now, so let's put a nice <code>0</code>. 
</li>
<li class="asterisk"><code>lpClassName</code> (class name): We have that one, we defined it above! So we'll just pass it straight from our <code>WindowClass</code>.
</li>
<li class="asterisk"><code>lpWindowName</code> (window name): Let's call it <code>Handmade Hero</code> for now.
</li>
<li class="asterisk"><code>dwStyle</code> (style): Another <em class="underscore">bit field</em>. Here we'll want to specify a few options from the get-go:
<ul>
    <li class="asterisk"><code>WS_OVERLAPPEDWINDOW</code>: An aggregate option, combining together several other ones. This option will give our window a typical thick frame, three buttons in the top right corner, a menu and a caption. 
</li>
    <li class="asterisk"><code>WS_VISIBLE</code>: Ensures that our window will be on visible and top when it spawns.
</li></ul>
<li class="asterisk"><code>X</code> and <code>Y</code>: Starting coordinates of the window. We... are not going to specify these just yet. Instead, we're going to use the special value <code>CW_USEDEFAULT</code> to let the operating system to put the window where it sees fit. 
</li>
<li class="asterisk"><code>nWidth</code> and <code>nHeight</code>: Width and Height, we're also going to skip these for now and let Windows deal with it via CW_USEDEFAULT. 
</li>
<li class="asterisk"><code>hWndParent</code> (parent window): for those cases if you want to have a window inside another window. This is not the case for us so we just put a <code>0</code> there. Windows will therefore use Desktop as our &ldquo;parent window&rdquo;
</li>
<li class="asterisk"><code>hMenu</code>: <code>0</code>, we don't have a menu to pass here. 
</li>
<li class="asterisk"><code>hInstance</code>: this is easy, we just pass it our <code>Instance</code> handle. 
</li>
<li class="asterisk"><code>lpParam</code>: any other parameter we'd like to pass to your window. This would be passed with the <code>WM_CREATE</code> message, so that you can intercept it and do something you like. We're fine, so just leave at 0.</li></ul>

</p><p>

If you filled out everything correctly, you should have something similar: 

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-keyword">if</span> (RegisterClassA(&amp;WindowClass))</span>
<span class="line">    {</span><div class=" add"><span class="line">        HWND Window = CreateWindowExA(<span class="hljs-number">0</span>,</span>
<span class="line">                                      WindowClass.lpszClassName,</span>
<span class="line">                                      <span class="hljs-string">"Handmade Hero"</span>,</span>
<span class="line">                                      WS_OVERLAPPEDWINDOW | WS_VISIBLE,</span>
<span class="line">                                      CW_USEDEFAULT,</span>
<span class="line">                                      CW_USEDEFAULT,</span>
<span class="line">                                      CW_USEDEFAULT,</span>
<span class="line">                                      CW_USEDEFAULT,</span>
<span class="line">                                      <span class="hljs-number">0</span>,</span>
<span class="line">                                      <span class="hljs-number">0</span>,</span>
<span class="line">                                      Instance,</span>
<span class="line">                                      <span class="hljs-number">0</span>);</span></div><div class=" C++ "><span class="line">    }</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;13:</b> <file>[win32_handmade.cpp]</file> Creating our window.</div></center>
<p>


We can compress all this a bit to look better:

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-keyword">if</span> (RegisterClassA(&amp;WindowClass))</span>
<span class="line">    {</span><div class=" edit"><span class="line">        HWND Window = CreateWindowExA(<span class="hljs-number">0</span>, WindowClass.lpszClassName, <span class="hljs-string">"Handmade Hero"</span>,</span>
<span class="line">                                      WS_OVERLAPPEDWINDOW | WS_VISIBLE,</span>
<span class="line">                                      CW_USEDEFAULT, CW_USEDEFAULT,</span>
<span class="line">                                      CW_USEDEFAULT, CW_USEDEFAULT,</span>
<span class="line">                                      <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, Instance, <span class="hljs-number">0</span>);</span></div><div class=" C++ "><span class="line">    }</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;14:</b> <file>[win32_handmade.cpp]</file> Creating our window.</div></center>
<p>




<div class="admonition tip">Try compiling quickly to see if you missed something. If compile fails, it means you added one too much or one too many parameters.</div>

</p><p>

Similarly to <code>RegisterClassA</code>, should in some hypothetical circumstance <code>CreateWindowExA</code> fail, it will also return <code>0</code>. Let's add another check to ensure that our <code>Window</code> handle is valid.

</p><pre class="listing tilde"><code><span class="line">        <span class="hljs-keyword">if</span> (RegisterClassA(&amp;WindowClass))</span>
<span class="line">        {</span>
<span class="line">            HWND Window = CreateWindowExA(...);</span><div class=" add"><span class="line">            <span class="hljs-keyword">if</span> (Window)</span>
<span class="line">            {</span>
<span class="line">                <span class="hljs-comment">// Window creation successful! </span></span>
<span class="line">            }</span>
<span class="line">            <span class="hljs-keyword">else</span></span>
<span class="line">            {</span>
<span class="line">                <span class="hljs-comment">// Window Creation failed! </span></span>
<span class="line">                <span class="hljs-comment">// TODO(casey): Logging</span></span>
<span class="line">            }</span></div><span class="line">        }</span>
<span class="line">        <span class="hljs-keyword">else</span></span>
<span class="line">        {</span>
<span class="line">            <span class="hljs-comment">// Window Class Registration failed</span></span>
<span class="line">            <span class="hljs-comment">// TODO(casey): Logging</span></span>
<span class="line">        }</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;15:</b> <file>[win32_handmade.cpp]</file> Ensuring our window handle is valid.</div></center>
<p>




<div class="admonition trivia"><div class="admonition-title"> Null-checking</div>

</p><p>

    Some programmers prefer being more explicit and writing something along the lines of <code>if (Window != NULL)</code> instead. There's no real reason for it, and you can simply write as we do. While such a comparison would yield us a <code>boolean</code> value, in C <code>true</code> and <code>false</code> are defined simply as <code>1</code> and <code>0</code>, respectively.</div>

</p>
<a class="target" name="windowmessagequeue">&nbsp;</a><a class="target" name="createawindow/windowmessagequeue">&nbsp;</a><a class="target" name="toc4.1">&nbsp;</a><h2>Window Message Queue</h2>
<p>


Now, if you compile and run your program, you will see that the window quickly blinks in and out of existence. This is exactly what you told it to do: Create window, check if it exists.... and return <code>0</code> out of <code>WinMain</code>. At this point, Windows considers your program complete, cleans everything up and closes your window.

</p><p>

Because we want our window to exist more than a fraction of a second, we need a so-called <em class="underscore">message loop</em>. We will induce our window to be always open and read Windows' messages until one of them simply doesn't tell the window to close, or we break out of that loop. 

</p><p>

In order to read the messages, we need to pull it from a Windows system called <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/about-messages-and-message-queues">Windows Message Queue</a>. It works the following way: when a window is created, it also sets up a queue for itself which starts to be filling up with all sorts of messages. These may be sent by Windows or anyone else who uses the Windows system. Our task would be to loop through this message queue, extract all the messages and read them. 

</p><p>

For today, we can use the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-GetMessage">GetMessage</a> function. This function allows us to pull the messages off our queue and process them.

</p><p>

<div class="admonition ">If there're no messages in the queue, the program will simply sit there and wait for new messages to come. This is not very convenient for the games, where things happen even if there's no messages coming up from the operating system.

</p><p>

    We will change this once we are ready to animate our game.</div>

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">BOOL <span class="hljs-title">GetMessage</span><span class="hljs-params">(</span>
<span class="line">  LPMSG lpMsg,</span>
<span class="line">  HWND  hWnd,</span>
<span class="line">  UINT  wMsgFilterMin,</span>
<span class="line">  UINT  wMsgFilterMax</span>
<span class="line">)</span></span>;</span></code></pre><center><div class="listingcaption tilde"><file>MSDN</file> <code>GetMessage</code> Syntax</div></center>
<p>


As you can see, <code>GetMessage</code> returns a <code>BOOL</code> (i.e. <code>true</code> or <code>false</code>) and takes four parameters:

</p><p>

<ul>
<li class="asterisk"><code>lpMsg</code> (Message): A pointer to the message of type <code>MSG</code>. We'll need to define it and then pass its <em class="underscore">address</em> (using the <code>&amp;</code> sign) to this function, so that it can be filled out if a message arrives.
</li>
<li class="asterisk"><code>hWnd</code> (Window): A window handle. We can pass to it our <code>Window</code> or we can pass <code>0</code>. In the latter case, <code>GetMessage</code> will collect any message directed at our program. Let's do that. 
</li>
<li class="asterisk"><code>wMsgFilterMin</code> and <code>wMsgFilterMax</code>: These serve to filter out specific messages. In our case, we want all the messages, so we leave these at <code>0</code>.</li></ul>

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">if</span> (Window)</span>
<span class="line">{</span><div class=" add"><span class="line">    MSG Message;</span>
<span class="line">    GetMessage(&amp;Message, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span></div><span class="line">}</span>
<span class="line"><span class="hljs-keyword">else</span></span>
<span class="line">{</span>
<span class="line">    <span class="hljs-comment">// Window Creation failed! </span></span>
<span class="line">    <span class="hljs-comment">// TODO(casey): Logging</span></span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;16:</b> <file>[win32_handmade.cpp]</file> Ensuring our window handle is valid.</div></center>
<p>




<div class="admonition ">MSG is another Windows structure. We won't look closely into it today, but feel free to learn more <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-MSG">here</a>.</div>

</p><p>

This program will exit as fast as the previous one because we <em class="underscore">still</em> don't have a loop. Luckily, <code>GetMessage</code> itself can help us out here. If we look at the documentation, we can see that &ldquo;If the function retrieves a message other than <code>WM_QUIT</code>, the return value is nonzero. If the function retrieves the <code>WM_QUIT</code> message, the return value is zero.&rdquo;

</p><p>

This means that, if we put <code>GetMessage</code> as a test condition in a <em class="underscore">while</em> loop, this program will run forever, until someone posts a &ldquo;quit&rdquo; message to the queue (and it gets retrieved by <code>GetMessage</code>). 

</p><p>

<div class="admonition note"><div class="admonition-title"> Loops</div>

</p><p>

    To learn more about the <code>while</code> and <code>for</code> loops, check out the <a href="#loops">Loops</a> subsection.</div>

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">if</span> (Window)</span>
<span class="line">{</span>
<span class="line">    MSG Message;</span><div class=" edit"><span class="line">    <span class="hljs-keyword">while</span>(GetMessage(&amp;Message, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))</span></div><div class=" add"><span class="line">    {</span>
<span class="line">        <span class="hljs-comment">// process message and go get another message</span></span>
<span class="line">    }</span>
<span class="line">    <span class="hljs-comment">// Exit procedures</span></span></div><span class="line">}</span>
<span class="line"><span class="hljs-keyword">else</span></span>
<span class="line">{</span>
<span class="line">    <span class="hljs-comment">// Window Creation failed! </span></span>
<span class="line">    <span class="hljs-comment">// TODO(casey): Logging</span></span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;17:</b> <file>[win32_handmade.cpp]</file> Ensuring our window handle is valid.</div></center>
<p>




<div class="admonition warning">If you read the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-GetMessage">documentation</a> carefully, you'll notice that it explicitly recommends <em class="underscore">against</em> doing the while loop the way we did it. The reason for it is that Windows' <code>BOOL</code> may return any number, not only <code>true</code> or <code>false</code>, including &minus;1 in case of invalid window handle.</div>

</p><p>

While this is not the way we will implement our message loop in the future anyway, and this code will be replaced by the more robust code that better suits our needs, for the sake of correctness, if you want to make use of <code>GetMessage</code> in your code, you may use the example provided in the documentation, or a construct such as this one: 

</p><pre class="listing tilde"><code><div class=" edit"><span class="line"><span class="hljs-keyword">for</span>(;;)                              <span class="hljs-comment">// a for loop which would run forever</span></span>
<span class="line">{</span>
<span class="line">    MSG Message;</span>
<span class="line">    BOOL MessageResult = GetMessage(&amp;Message, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span>
<span class="line">    <span class="hljs-keyword">if</span> (MessageResult &gt; <span class="hljs-number">0</span>)          <span class="hljs-comment">// 0 is the WM_QUIT message, -1 is invalid window handle</span></span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-comment">// Do work in your window</span></span>
<span class="line">    }</span>
<span class="line">    <span class="hljs-keyword">else</span></span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-keyword">break</span>;                      <span class="hljs-comment">// break out of the loop</span></span>
<span class="line">    }</span>
<span class="line">}</span></div><span class="line"><span class="hljs-comment">// Exit procedures</span></span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;18:</b> <file>[win32_handmade.cpp]</file> API-correct way of verifying <code>GetMessage</code>.</div></center>

<a class="target" name="translatinganddispatchingmessages">&nbsp;</a><a class="target" name="createawindow/translatinganddispatchingmessages">&nbsp;</a><a class="target" name="toc4.2">&nbsp;</a><h2>Translating and Dispatching Messages</h2>
<p>


We're still not out of the woods yet. If you'll try to compile and debug the program, you will notice that it runs forever, even if you try to close it (the only way to stop it would be to stop debugging). That's... not exactly what we had in mind, right? Well, that's fine, this is due to the fact that hitting <code>Alt-F4</code> or the red <code>X</code> button doesn't create a <code>WM_QUIT</code> message, but <code>WM_CLOSE</code>. And we're basically ignoring this message by replacing its default behaviour with an <code>OutputDebugStringA</code> call (see Subsection ?).

</p><p>

However, if you try to resize the program, or minimize the window, it doesn't react to your inputs at all. Moreover, if you check the <code>Output</code> window in your debugger, you will only notice a single <code>WM_ACTIVATEAPP</code> and <code>WM_SIZE</code> message (and more <code>WM_ACTIVATESIZE</code> messages if you switch in and out of the window). We don't get additional <code>WM_SIZE</code> messages if we try to resize the window, or any <code>WM_CLOSE</code> messages at all! 

</p><pre class="listing tilde"><code><span class="line">Debugging new process...[OK] Process ID: #####</span>
<span class="line">WM_ACTIVATEAPP</span>
<span class="line">WM_SIZE</span>
<span class="line">WM_ACTIVATEAPP</span>
<span class="line">WM_ACTIVATEAPP</span>
<span class="line">WM_ACTIVATEAPP</span></code></pre><center><div class="listingcaption tilde"><file>[Output window]</file></div></center>
<p>


This is because we don't do anything with our messages (and the messages that do come through to our <code>MainWindowCallback</code> aren't sent by our window). We simply pul them out of the queue and... discard them. In order to send the messages to our <code>MainWindowCallback</code> (and then to <code>DefWindowProc</code>), we need to <em class="underscore">dispatch</em> our message. The Windows command to do that is called simply <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessage">DispatchMessageA</a>.

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">LRESULT <span class="hljs-title">DispatchMessageA</span><span class="hljs-params">(</span>
<span class="line">  <span class="hljs-keyword">const</span> MSG *lpMsg</span>
<span class="line">)</span></span>;</span></code></pre><center><div class="listingcaption tilde"><file>[MSDN]</file> <code>DispatchMessageA</code> syntax</div></center>
<p>


As you can see, the syntax for <code>DispatchMessageA</code> is super simple, it only takes a pointer to the message. Moreover, we're not interested in the <code>LRESULT</code> this function returns so we can simply discard it. Let's plug it in our message loop: 

</p><pre class="listing tilde"><code><span class="line">MSG Message;</span>
<span class="line">BOOL MessageResult = GetMessage(&amp;Message, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span>
<span class="line"><span class="hljs-keyword">if</span> (MessageResult &gt; <span class="hljs-number">0</span>)</span>
<span class="line">{</span><div class=" add"><span class="line">    DispatchMessageA(&amp;Message);</span></div><span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;19:</b> <file>[win32_handmade.cpp]</file> Adding <code>DispatchMessageA</code>.</div></center>
<p>




<div class="admonition ">We <em class="underscore">might</em> try to call <code>MainWindowCallback</code> ourselves, however this is generally considered not a good idea. Windows expects the control flow to be in a specific shape, and it's better not to go against this set of things.</div>

</p><p>

While we're at it, we can add another useful function called <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage">TranslateMessage</a>. It has nearly identical syntax except it returns a <code>BOOL</code>: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">BOOL <span class="hljs-title">TranslateMessage</span><span class="hljs-params">(</span>
<span class="line">  <span class="hljs-keyword">const</span> MSG *lpMsg</span>
<span class="line">)</span></span>;</span></code></pre><center><div class="listingcaption tilde"><file>[MSDN]</file> <code>TranslateMessage</code> syntax</div></center>
<p>


This function doesn't have a purpose right now, but might be useful later. It's used to &ldquo;translate&rdquo; Windows virtual key character codes to actual <code>char</code> symbols, and post the result as a new message to the queue. Let's add it before our <code>DispatchMessageA</code> call:

</p><pre class="listing tilde"><code><span class="line">MSG Message;</span>
<span class="line">BOOL MessageResult = GetMessage(&amp;Message, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span>
<span class="line"><span class="hljs-keyword">if</span> (MessageResult &gt; <span class="hljs-number">0</span>)</span>
<span class="line">{</span><div class=" add"><span class="line">    TranslateMessage(&amp;Message);</span></div><span class="line">    DispatchMessageA(&amp;Message);</span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;20:</b> <file>[win32_handmade.cpp]</file> Adding <code>TranslateMessage</code>.</div></center>
<p>


We'll talk more about virtual keyboard input once we get to our input system.

</p><p>

So there you have it! Your barebones window. It's not pretty, it cannot be closed unless you force it from the debugger (<code>Shift-F5</code>) or the Task Manager, but you can rezise it, minimize and maximize it! 

</p><p>

<center><div class="image" style=""><a href="../media/day2/canvas.png" target="_blank"><img class="markdeep" src="../media/day2/canvas.png" /></a><center><span class="imagecaption"><a href="#figure_x">Figure&nbsp;2</a>. Your blank canvas, to build your worlds in.</span></center></div></center>

</p><p>

Additionally, if you inspect your <code>Output</code> window you will see a great many messages sent by resize and close messages. We will never, however, get a <code>WM_DESTROY</code> message because it will come from someone trying to forcefully close our window, or if we call it ourselves.

</p>
<a class="target" name="drawingsomethingtoourwindow">&nbsp;</a><a class="target" name="drawingsomethingtoourwindow">&nbsp;</a><a class="target" name="toc5">&nbsp;</a><h1>Drawing Something to Our Window</h1>
<p>


Let's have some fun. As of now, your window doesn't have any defined contents, so it might start white, black, &ldquo;transparent&rdquo;, or whatever else way Windows decides. Resizing it also randomly changes its contents. Instead, let's try and give our window some specific color. 

</p><p>

We're going to do it by securing a special path for the <code>WM_PAINT</code> message inside our <code>MainWindowCallback</code>. We are also going to make use of the  <em class="underscore">Device Context</em> that we secured for ourselves during the class registration, as well as the workflow Windows intended us to use for painting. This workflow intends us using the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-beginpaint">BeginPaint</a> and the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-endpaint">EndPaint</a> functions, <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-paintstruct">PAINTSTRUCT</a> structure, as well as the use of various &ldquo;brushes&rdquo;. 

</p><p>

<div class="admonition tip">If you're interested in the whole process, check out <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/painting-the-window">this article</a> on MSDN.</div>

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">HDC <span class="hljs-title">BeginPaint</span><span class="hljs-params">(</span>
<span class="line">  HWND          hWnd,</span>
<span class="line">  LPPAINTSTRUCT lpPaint</span>
<span class="line">)</span></span>;</span>
<span class="line"></span>
<span class="line"><span class="hljs-function">BOOL <span class="hljs-title">EndPaint</span><span class="hljs-params">(</span>
<span class="line">  HWND                hWnd,</span>
<span class="line">  <span class="hljs-keyword">const</span> LPPAINTSTRUCT *lpPaint</span>
<span class="line">)</span></span>;</span></code></pre><center><div class="listingcaption tilde"><file>[MSDN]</file> <code>BeginPaint</code> and <code>EndPaint</code> syntax.</div></center>
<p>


As you can see, <code>BeginPaint</code> returns a handle to one of those <em class="underscore">Device Contexts</em>. We may should store it for painting. Both <code>BeginPaint</code> and <code>EndPaint</code> take window handle and a apointer to a <code>PAINTSTRUCT</code>. The latter is a set of parameters that Windows fills out in <code>BeginPaint</code>, containing some useful information like <code>rcPaint</code> (rectangle where we can paint), <code>fErase</code> (a boolean saying whether or not we paint or erase), etc.

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-keyword">case</span> WM_ACTIVATEAPP:</span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-comment">// ...</span></span>
<span class="line">    } <span class="hljs-keyword">break</span>;</span>
<span class="line"></span><div class=" add"><span class="line">    <span class="hljs-keyword">case</span> WM_PAINT:</span>
<span class="line">    {</span>
<span class="line">        PAINTSTRUCT Paint;</span>
<span class="line">        HDC DeviceContext = BeginPaint(Window, &amp;Paint);</span>
<span class="line"></span>
<span class="line">        <span class="hljs-comment">// Do our painting here</span></span>
<span class="line"></span>
<span class="line">        EndPaint(Window, &amp;Paint);</span>
<span class="line">    } <span class="hljs-keyword">break</span>;</span></div><span class="line"></span>
<span class="line">    <span class="hljs-keyword">default</span>: <span class="hljs-comment">// ...</span></span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;21:</b> <file>[win32_handmade.cpp]</file> Defining custom paint workflow.</div></center>
<p>


In here, we can get as extravagant as we want to. Since we've done a lot already today, and we aren't going to make use of this system moving forward, let's use a simple call to <a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-patblt">PatBlt</a> (&ldquo;Pat Blit&rdquo;). This is a super simple function, allowing us to fill out a rectangle with a specified color or pattern. 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">BOOL <span class="hljs-title">PatBlt</span><span class="hljs-params">(</span>
<span class="line">  HDC   hdc,</span>
<span class="line">  <span class="hljs-keyword">int</span>   x,</span>
<span class="line">  <span class="hljs-keyword">int</span>   y,</span>
<span class="line">  <span class="hljs-keyword">int</span>   w,</span>
<span class="line">  <span class="hljs-keyword">int</span>   h,</span>
<span class="line">  DWORD rop</span>
<span class="line">)</span></span>;</span></code></pre><center><div class="listingcaption tilde"><file>[MSDN]</file> <code>PatBlt</code> syntax.</div></center>
<p>



<ul>
<li class="asterisk"><code>hdc</code>: The device context handle. We just got one, so we'll pass it down. 
</li>
<li class="asterisk"><code>x, y</code>: Top left coordinates of our painting rectangle. 
</li>
<li class="asterisk"><code>w, h</code>: Width and Height of our painting rectangle.
</li>
<li class="asterisk"><code>rop</code>: Keyword for the operation to do. Let's fill it with <code>WHITENESS</code> constant for now.</li></ul>

</p><p>

So where we can get the <code>x, y, w</code> and <code>h</code>? We have our <code>PAINTSTRUCT</code> with plenty useful information, including the <code>RECT</code> of the painting area. As you can see from <a href="https://docs.microsoft.com/en-us/windows/win32/api/windef/ns-windef-rect">documentation</a>, <code>RECT</code> structure contains a <code>left</code>, <code>top</code>, <code>right</code>, and <code>bottom</code>. This gives us immediately <code>x</code> and <code>y</code>, while <code>Width</code> and <code>Height</code> can be obtained by simply subtracting right from left, and bottom from top:

</p><pre class="listing tilde"><code><span class="line">    <span class="hljs-keyword">case</span> WM_PAINT:</span>
<span class="line">    {</span>
<span class="line">        PAINTSTRUCT Paint;</span>
<span class="line">        HDC DeviceContext = BeginPaint(Window, &amp;Paint);</span>
<span class="line"></span><div class=" add"><span class="line">        <span class="hljs-keyword">int</span> X = Paint.rcPaint.left;</span>
<span class="line">        <span class="hljs-keyword">int</span> Y = Paint.rcPaint.top;</span>
<span class="line">        <span class="hljs-keyword">int</span> Width = Paint.rcPaint.right - Paint.rcPaint.left;</span>
<span class="line">        <span class="hljs-keyword">int</span> Height = Paint.rcPaint.bottom - Paint.rcPaint.top;</span>
<span class="line">        PatBlt(DeviceContext, X, Y, Width, Height, WHITENESS);</span></div><span class="line"></span>
<span class="line">        EndPaint(Window, &amp;Paint);</span>
<span class="line">    } <span class="hljs-keyword">break</span>;</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;22:</b> <file>[win32_handmade.cpp]</file> <code>PatBlt</code></div></center>
<p>


We compile... and get a <code>LNK2019</code> error: <code>unresolved external symbol ....PatBlt</code>. If you remember <a href="day1.html#addsomethingtodofortheprogram/importalibrary">Day1</a> you should have the exact solution for it in mind.

</p><p>

<div class="admonition tip">Take a second looking for solution yourself before scrolling further down!</div>

</p><p>

If we inspect better the documentation for <a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-patblt">PatBlt</a>, we will quickly see that it requires <code>Gdi32.lib</code> library. That's simple, let's add it in our <code>build.bat</code>!

</p><pre class="listing tilde"><code><div class=" edit"><span class="line">cl -Zi ..\code\win32_handmade.cpp user32.lib gdi32.lib</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;23:</b> <file>[build.bat]</file> Linking with <code>gdi32.lib</code>.</div></center>

<a class="target" name="%22animating%22thewindow">&nbsp;</a><a class="target" name="drawingsomethingtoourwindow/&ldquo;animating&rdquo;thewindow">&nbsp;</a><a class="target" name="toc5.1">&nbsp;</a><h2>&ldquo;Animating&rdquo; the Window</h2>
<p>




<div class="admonition warning"><div class="admonition-title"> Epilepsy Warning</div>

</p><p>

    WARNING: This section contains code which may potentially trigger seizures for people with photosensitive epilepsy.</div>

</p><p>

As you remember from its <a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-patblt">documentation</a>, <code>PatBlt</code> allows us to set our window to <code>WHITENESS</code> or to <code>BLACKNESS</code>. Let's alternate between the two each time we process <code>WM_PAINT</code> message! 

</p><p>

Let's assign our <code>PatBlt</code> operation (which is a <code>DWORD</code> type) to a variable, similar to how we assigned <code>X, Y, Width</code> and <code>Height</code> before using them. However, we will do one thing differently and mark the variable as <code>static</code>:

</p><pre class="listing tilde"><code><span class="line">HDC DeviceContext = BeginPaint(Window, &amp;Paint);</span>
<span class="line"><span class="hljs-keyword">int</span> X = Paint.rcPaint.left;</span>
<span class="line"><span class="hljs-keyword">int</span> Y = Paint.rcPaint.top;</span>
<span class="line"><span class="hljs-keyword">int</span> Width = Paint.rcPaint.right - Paint.rcPaint.left;</span>
<span class="line"><span class="hljs-keyword">int</span> Height = Paint.rcPaint.bottom - Paint.rcPaint.top;</span><div class=" add"><span class="line"><span class="hljs-keyword">static</span> DWORD Operation = WHITENESS;</span></div><div class=" edit"><span class="line">PatBlt(DeviceContext, X, Y, Width, Height, Operation);</span></div><span class="line"></span>
<span class="line">EndPaint(Window, &amp;Paint);</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;24:</b> <file>[win32_handmade.cpp]</file> Extracting operation to a variable.</div></center>
<p>




<div class="admonition note"><div class="admonition-title"> <code>static</code> keyword and the <em class="underscore">scope</em></div>

</p><p>

    In C/C++, <code>static</code> is actually quite a confusing keyword: it has three meanings depending on the context. We will return to its definitions more in detailed <a href="day3.html#differentmeaningsofstatic">in the next chapter</a>. 

</p><p>

    In this particular case, by marking <code>Operation</code> as <code>static</code>, it will be declared only once for the whole duration of the program. Only on the first time you step into <code>WM_PAINT</code> the <code>Operation</code> will be initialized, after that the application will skip the initialization step and will remember its previous value.</div>

</p><p>

In our case, <code>Operation</code> will be initialized to <code>WHITENESS</code> only once, the rest of the times we can return and swap its current value to its opposite, like so: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">static</span> DWORD Operation = WHITENESS;</span><div class=" add"><span class="line"><span class="hljs-keyword">if</span> (Operation == WHITENESS)</span>
<span class="line">{ </span>
<span class="line">    Operation = BLACKNESS;</span>
<span class="line">}</span>
<span class="line"><span class="hljs-keyword">else</span></span>
<span class="line">{</span>
<span class="line">    Operation = WHITENESS;</span>
<span class="line">}</span></div><span class="line">PatBlt(DeviceContext, X, Y, Width, Height, Operation);</span>
<span class="line"></span>
<span class="line">EndPaint(Window, &amp;Paint);</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;25:</b> <file>[win32_handmade.cpp]</file> Changing <code>Operation</code> at every pass.</div></center>
<p>




<div class="admonition note"><div class="admonition-title"> <code>Assign</code> vs. <code>Equal to</code> operators</div>

</p><p>

    Note that <code>==</code> and <code>=</code> mean totally different things in C/C++. 

</p><p>

<ul>
    <li class="asterisk"><code>=</code> (Assignment operator) assigns the right value to the left variable.
</li>
    <li class="asterisk"><code>==</code> (&ldquo;Equal to&rdquo; operator) compares if the left and right values are mathematically equal.

</p><p>

</li></ul>
    It's a common beginner error inserting <code>=</code> instead of <code>==</code> in the <code>if</code> statement and producing all sorts of errors as a result.</div>

</p><p>

<div class="admonition warning"><div class="admonition-title"> <strong class="asterisk">Epilepsy Warning</strong></div>

</p><p>

    <strong class="asterisk">WARNING</strong>: This section may potentially trigger seizures for people with photosensitive epilepsy. You may want to skip observing the results and call it a day here.</div>

</p><p>

If you compile and run the program now, you will see the window change color each time the window is resized. If you bring it closer to the border, you will notice it's only repainting the portions which were previously hidden.

</p>
<a class="target" name="recap">&nbsp;</a><a class="target" name="recap">&nbsp;</a><a class="target" name="toc6">&nbsp;</a><h1>Recap</h1>
<p>


And there you have it! Opening a window is some great progress and, if you look back, it's not that much of code. We set up our own Window Class; additionally, we started laying the ground work of our main window callback. Finally, we were in position to open our window and we immediately started drawing some crazy stuff into it.

</p><p>

Next time, we will be defining the <code>MainWindowCallback</code> messages a bit more appropriately, as well as create a <em class="underscore">bitmap</em> which we will then display to our window. This will bring us to the point where we can actually render our game. 

</p><p>

<hr/>

</p><p>

<div class="endnote"><a class="target" name="endnote-awnotation">&nbsp;</a><sup>1</sup> We briefly touched on <code>...A</code> and <code>...W</code> notation in <a href="day1.html#addsomethingtodofortheprogram/importalibrary">Day 1</a>. To recap, any function that takes a string as input has an <b>A</b>nsi and a <b>W</b>ide (Unicode) version, and a macro decides which function to call. Here, you can use the macro <code>WNDCLASS</code> or the ANSI/Wide version, as you prefer. 
</div>
</p><p>

<div class="endnote"><a class="target" name="endnote-align">&nbsp;</a><sup>4</sup> It's not entirely true though, depending on the sizing of the elements in the struct some additional <em class="underscore">padding</em> may be introduced to preserve memory <em class="underscore">alignment</em>. We will look into the alignment later down the line. 
</div>
</p><p>

<div class="endnote"><a class="target" name="endnote-bitwiseor">&nbsp;</a><sup>2</sup> See also some additional methods to pass parameters to function <a href="day1.html#addsomethingtodofortheprogram">here</a>.
</div>
</p><p>

<div class="endnote"><a class="target" name="endnote-winapi">&nbsp;</a><sup>3</sup> The only difference between the two is their <em class="underscore">calling convention</em>. For MSVC calling conventions, you can read more <a href="https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions">here</a>.
</div>
</p>
<a class="target" name="exercises">&nbsp;</a><a class="target" name="exercises">&nbsp;</a><a class="target" name="toc7">&nbsp;</a><h1>Exercises</h1>

<a class="target" name="interceptmoremessages">&nbsp;</a><a class="target" name="exercises/interceptmoremessages">&nbsp;</a><a class="target" name="toc7.1">&nbsp;</a><h2>Intercept More Messages</h2>
<p>


Try to look around the <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/about-messages-and-message-queues#system-defined-messages">message lists</a>. See if you find some of your liking; then add the relevant <code>case</code> to your <code>switch</code> statement, add a debug line and try to have it go off during your program execution. Try to see if you can do something with the data they might bring.

</p>
<a class="target" name="customwindowoptions">&nbsp;</a><a class="target" name="exercises/customwindowoptions">&nbsp;</a><a class="target" name="toc7.2">&nbsp;</a><h2>Custom Window Options</h2>
<p>


Right now, we are letting Windows used default size and position of our Window. What if you put some actual values into it? Does <code>CreateWindowEx</code> operate as you would expect it to? 

</p><p>

Try adding some different styles to <code>dwStyle</code>. See what results does it bring you. 

</p>
<a class="target" name="programmingbasics">&nbsp;</a><a class="target" name="programmingbasics">&nbsp;</a><a class="target" name="toc8">&nbsp;</a><h1>Programming Basics</h1>

<a class="target" name="concerningtypedefs">&nbsp;</a><a class="target" name="programmingbasics/concerningtypedefs">&nbsp;</a><a class="target" name="toc8.1">&nbsp;</a><h2>Concerning typedefs</h2>
<p>


As you can see, <code>WNDCLASS</code> (or, to be precise, <code>WNDCLASSA</code>) is a C struct, with some interesting decoration. Let's look at it more closely.

</p><p>

<ul>
<li class="asterisk">The <em class="underscore">struct</em> itself is defined as <code>struct tagWNDCLASSA {...};</code> In C, a struct is just a record, a collection of variables that together. When you refer to a struct, you refer to a specific memory layout where each of these individual things is sequentially ordered and (usually) stored back to back<sup><a href="#endnote-align">4</a></sup>.
</li>
<li class="asterisk">You will note that the struct is actually called <i>tag</i>WNDCLASSA. The reasons for this are, in part, historical. The bottom line is because the Windows headers want to support both C and C++ compilation.  
</li>
<li class="asterisk">In C++, it's enough for you to declare the struct to start immediately using it.</li></ul>

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dim</span></span>
<span class="line">{</span></span>
<span class="line">    <span class="hljs-keyword">int</span> Width;</span>
<span class="line">    <span class="hljs-keyword">int</span> Height;</span>
<span class="line">};</span>
<span class="line"></span>
<span class="line">dim ScreenDimension;</span></code></pre><center><div class="listingcaption tilde"><file>[Example 1]</file> In C++, if we declare a struct, we can start using it right away by its name.</div></center>
<p>



<ul>
<li class="asterisk">In C, however, this is not true. C does not look up the names of types if you don't decorate them accordingly.</li></ul>

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dim</span></span>
<span class="line">{</span></span>
<span class="line">    <span class="hljs-keyword">int</span> Width;</span>
<span class="line">    <span class="hljs-keyword">int</span> Height;</span>
<span class="line">};</span>
<span class="line"></span>
<span class="line">       dim ScreenDimension;  <span class="hljs-comment">// error C2065: 'dim': undeclared identifier</span></span>
<span class="line">                             <span class="hljs-comment">// error C2065: 'ScreenDimension': undeclared identifier</span></span>
<span class="line"></span>
<span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dim</span> <span class="hljs-title">ScreenDimension</span>;</span>  <span class="hljs-comment">// OK</span></span>
<span class="line"></span></code></pre><center><div class="listingcaption tilde"><file>[Example 2]</file> In C, each struct must be marked as such in your code.</div></center>
<p>



<ul>
<li class="asterisk">If you want to avoid using again and again the keyword <code>struct</code>, you can create an <code>alias</code> of sorts using the keyword <code>typedef</code>. Think of this keyword as a way to specify a name for something declared previously.</li></ul>

</p><pre class="listing tilde"><code><span class="line"></span>
<span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dim</span> {</span>...};</span>
<span class="line"></span>
<span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dim</span> <span class="hljs-title">dim_t</span>;</span></span>
<span class="line"></span>
<span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dim</span> <span class="hljs-title">ScreenDimension</span>;</span>  <span class="hljs-comment">// OK</span></span>
<span class="line"><span class="hljs-keyword">dim_t</span> OtherDimension;        <span class="hljs-comment">// Also OK</span></span>
<span class="line"></span></code></pre><center><div class="listingcaption tilde"><file>[Example 3]</file> In this case, we define &ldquo;struct dim&rdquo; as a type &ldquo;dim_t&rdquo;.</div></center>
<p>



<ul>
<li class="asterisk"><code>typedef</code> is a powerful keyword. It allows creating multiple types at the same time, using one source and separated by a comma (<code>,</code>):</li></ul>

</p><pre class="listing tilde"><code><span class="line"></span>
<span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dim</span> {</span>...};</span>
<span class="line"></span>
<span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dim</span> <span class="hljs-title">dim</span>, *<span class="hljs-title">pDim</span>, <span class="hljs-title">twoDim</span>[2];</span>               <span class="hljs-comment">// typedef 3 types in one call</span></span>
<span class="line"></span>
<span class="line">dim ADimension;</span>
<span class="line">pDim PointerToDim = &amp;ADim;                              <span class="hljs-comment">// take the address of our dim and store it as pDim. * not necessary!</span></span>
<span class="line">twoDim DoubleDimension = { ADimension, ADimension };    <span class="hljs-comment">// take two dims and store it in twoDim array type. </span></span>
<span class="line"></span>
<span class="line"><span class="hljs-comment">// etc., etc.</span></span>
<span class="line"></span></code></pre><center><div class="listingcaption tilde"><file>[Example 4]</file> typedefs can get very complex and silly very quickly.</div></center>
<p>



<ul>
<li class="asterisk">Finally, it's possible to <code>typedef</code> preemptively, without having to go to a separate line, and that is what Windows headers are doing. The complete solution would be the where we started:</li></ul>

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagWNDCLASSA</span> {</span></span>
<span class="line">...; <span class="hljs-comment">// contents of the struct</span></span>
<span class="line">} WNDCLASSA, *PWNDCLASSA, *NPWNDCLASSA, *LPWNDCLASSA;</span>
<span class="line"></span>
<span class="line"><span class="hljs-comment">// WNDCLASSA WindowClass; -&gt; struct tagWNDCLASSA WindowClass;</span></span>
<span class="line"><span class="hljs-comment">// PWNDCLASSA WindowClass; -&gt; struct tagWNDCLASSA *WindowClass;</span></span>
<span class="line"><span class="hljs-comment">// NPWNDCLASSA WindowClass; -&gt; struct tagWNDCLASSA *WindowClass;</span></span>
<span class="line"><span class="hljs-comment">// LPWNDCLASSA WindowClass; -&gt; struct tagWNDCLASSA *WindowClass;</span></span>
<span class="line"></span></code></pre><center><div class="listingcaption tilde"><file>[MSDN]</file> Window Class structure syntax, hopefully clarified`.</div></center>
<p>




<div class="admonition trivia"><div class="admonition-title"> Trivia: Old pointer types</div>

</p><p>

    At this point, you have probably noticed that <code>WNDCLASSA</code> comes with not one, but with three pointer types. In fact, there's <code>*P...</code> (pointer), <code>*NP...</code> (near pointer) and <code>*LP...</code> (long, or far pointer). At this point, this is an anachronistic residual of a 16-bit era of <a href="https://en.wikipedia.org/wiki/MS-DOS">MS-DOS</a>, which became obsolete with the advent of <a href="https://en.wikipedia.org/wiki/Intel_80386">80386 Intel processors in 1985</a>. If you're still interested, further reading is available <a href="https://www.answers.com/Q/What_are_near_far_and_huge_pointers_in_C">here</a>.

</p><p>

    For all intents and purpuses on a modern 32-bit+ operating system, they are the same type, a pointer to <code>WINCLASSA</code> structure.

</p><p>

    Another note: struct identifier shouldn't necessarily be different from one of its types (i.e. it can be simply <code>typedef struct WNDCLASSA....</code> instead of <code>tagWNDCLASSA</code>) or even be there (<code>typedef struct {...} WNDCLASSA, ...;</code>). The way Windows headers do it is somewhat the more explicit way, supposedly to support some old compiler.</div>

</p><p>

<em class="underscore">(Continue following along: Subsection  <a href="#toc1.1">1.1</a>)</em>

</p>
<a class="target" name="structinitialization">&nbsp;</a><a class="target" name="programmingbasics/structinitialization">&nbsp;</a><a class="target" name="toc8.2">&nbsp;</a><h2>Struct Initialization</h2>
<p>


Let's look at the braces <code>{}</code> we provided in subsection  <a href="#toc1.1">1.1</a>. 

</p><p>

A variable must not necessarily be initialized. You can simply declare it (like this: <code>int x;</code>, <code>WNDCLASSA WindowClass</code>, etc.) and move on, if that is your intention. However, what if we want to <em class="underscore">initialize</em> a variable to a value? In case of a simple type, you just write its initial value after <code>=</code> (in the example above, <code>int x = 5;</code>). In case of a <em class="underscore">struct</em>, you can use the values inside the braces (i.e. <code>WNDCLASSA WindowClass = { MyStyle, &quot;Hello&quot; };</code>, etc.). The elements that you don't assign value to, all the elements onwards, are set to 0. If you simply assign it <code>{}</code>, you zero out the whole struct, however big it is. 

</p><p>

We want to do this here, because a) it's more readable to see which value you assing to which element, and b) because we don't even need to fill out all the elements. 

</p><p>

<div class="admonition warning">In C, you should use <code>{0}</code> instead of <code>{}</code>, but <code>{0}</code> can also be used in C++.</div>

</p><p>

<em class="underscore">(Back to Subsection  <a href="#toc1.1">1.1</a>)</em>

</p>
<a class="target" name="switchstatements">&nbsp;</a><a class="target" name="programmingbasics/switchstatements">&nbsp;</a><a class="target" name="toc8.3">&nbsp;</a><h2>Switch Statements</h2>
<p>


The <code>switch</code> statement allows to test if a variable we get equals any <code>constant</code> value. If it does, you apply a relevant <code>case</code> to it. 

</p><p>

Remember that by executing the <code>case</code> you don't automatically fall out of the <code>switch</code>! You need to use the <code>break</code> statement in order to not keep executing all the <code>cases</code> that follow.

</p><p>

If no value falls under a specific <code>case</code>, you can specify a <code>default</code> to execute if every other fails. 

</p><p>

The way we are going to write <code>switch</code> statements in this course might seem a bit unusual if you've seen these statements elsewhere because each <code>case</code> statement is limited by a basic block (delimited by braces (<code>{}</code>)). While this is not required, it allows defining variables specific to that case, and they will not &ldquo;spill&rdquo; outside to another case. This is due to the fact that, after you close your block, you go outside of those variables' <em class="underscore">scope</em> and they cease to exist. <code>break</code> will go just outside the block, again in a mix of a convention, convenience and practicality. 

</p><p>

<em class="underscore">(Back to Subsection  <a href="#toc2.2">2.2</a>)</em>

</p>
<a class="target" name="pointers">&nbsp;</a><a class="target" name="programmingbasics/pointers">&nbsp;</a><a class="target" name="toc8.4">&nbsp;</a><h2>Pointers</h2>
<p>


Every variable, function, struct, everything in computer has a location in memory, its <em class="underscore">address</em>. This address is nothing more than a number that, as any other number in C, may be manipulated with ease. To get something's <em class="underscore">address</em>, or a <em class="underscore">pointer</em> to something, you simply put the ampersand symbol (<code>&amp;</code>) before a variable's name. To learn the <em class="underscore">contents</em> of an address (&ldquo;dereference a pointer&rdquo;), you simply put a star operator (<code>*</code>) before the pointer in question.

</p><p>

There's a lot more to know about the pointers, and this course will certainly touch a lot on this subject.

</p><p>

For a more in-depth overview on pointers, you can watch the short series <a href="https://hero.handmade.network/episode/intro-to-c">Intro to C</a> where this topic is covered in detail.

</p><p>

For our purposes, to pass a <em class="underscore">pointer</em> to our WindowClass, we simply write <code>&amp;WindowClass</code>. 

</p>
<a class="target" name="loops">&nbsp;</a><a class="target" name="programmingbasics/loops">&nbsp;</a><a class="target" name="toc8.5">&nbsp;</a><h2>Loops</h2>
<p>


There're many ways to create a &ldquo;loop&rdquo;, or to repeat execution of a chunk of code. Two common ways to implement a loop is to use <code>while</code> or <code>for</code> keywords.

</p><p>

A <code>while</code> loop has one condition which is being tested at the beginning of the loop. If the test is <code>true</code>, the program will execute the code inside and immidiately return to test again. If the test is <code>false</code>, the program will skip the <code>while</code> block and continue after the scope of the statement.

</p><p>

A <code>for</code> loop is an iteration loop. Usually it's used the following way: initialize a variable <code>i</code>; compare if <code>i</code> is smaller than some value; increment <code>i</code> and go into loop if true, otherwise break out. All this is compactly represented at the head of the loop as follows: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SomeValue; ++i)</span>
<span class="line">{</span>
<span class="line"><span class="hljs-comment">// do your operations</span></span>
<span class="line">}</span></code></pre><p>

However, strictly speaking you <em class="underscore">don't have to</em> fill out the head parts, all or any. And if you leave it as <code>(;;)</code> this loop will simply run forever, unless some other condition inside it <code>breaks</code> it out. In the same way, a <code>while (1)</code> or <code>while (true)</code> loop will also run forever.

</p><p>

<em class="underscore">(Back to Subsection  <a href="#toc4.1">4.1</a>)</em>

</p>
<a class="target" name="navigation">&nbsp;</a><a class="target" name="navigation">&nbsp;</a><a class="target" name="toc9">&nbsp;</a><h1>Navigation</h1>
<p>


Previous: <a href="day1.html">Day 1. Setting the Windows Build</a>

</p><p>

Up Next: <a href="day3.html">Day 3. Allocating a Back Buffer</a>

</p><p>

<a href="../index.md.html">Back to Index</a>

</p>
<div class="nonumberh1">Glossary</div>
<p>





<ul>
<li class="asterisk">Breakpoint
</li>
<li class="asterisk">Debugger
</li>
<li class="asterisk">Function signature
</li>
<li class="asterisk">Handle
</li>
<li class="asterisk">Pointer
</li>
<li class="asterisk">Scope
</li>
<li class="asterisk">Step over
</li>
<li class="asterisk">Type
</li>
<li class="asterisk">Win32 API
<ul>
    <li class="asterisk"><a href="https://docs.microsoft.com/en-us/windows/win32/gdi/using-brushes">Brushes</a>
</li>
    <li class="asterisk"><a href="https://docs.microsoft.com/en-us/windows/win32/gdi/device-contexts">Device Context</a>: a structure used by Windows to keep the state of a drawing while we're drawing to the window.
</li>
    <li class="asterisk">Events
</li></ul>
<li class="asterisk">Zero is Initialization</li></ul>

</p>
<div class="nonumberh1">References</div>
<p>


<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-beginpaint">BeginPaint</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-CreateWindowA">CreateWindowA</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-CreateWindowExA">CreateWindowExA</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-defwindowproca">DefWindowProcA</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessage">DispatchMessageA</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-endpaint">EndPaint</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-GetMessage">GetMessage</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-MSG">MSG structure</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-MSG">PAINTSTRUCT structure</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-outputdebugstringa">OutputDebugStringA</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-patblt">patblt</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclassa">RegisterClassA</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage">TranslateMessage</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassa">WNDCLASSA</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/winprog/windows-data-types">Windows Data Types</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/about-messages-and-message-queues">Windows Message Queue</a>

</p><p>

<style class="fallback">
  body {
    visibility: hidden;
    font-family: sans-serif;
  }
</style>

</p><p>

<script>markdeepOptions = { tocStyle: 'long' }; window.alreadyProcessedMarkdeep || (document.body.style.visibility = 'visible');</script>

</p><p>

</p></span><div id="mdContextMenu" style="visibility:hidden"></div><div class="markdeepFooter"><i>formatted by <a href="https://casual-effects.com/markdeep" style="color:#999">Markdeep&nbsp;1.10&nbsp;&nbsp;</a></i><div style="display:inline-block;font-size:13px;font-family:'Times New Roman',serif;vertical-align:middle;transform:translate(-3px,-1px)rotate(135deg);">&#x2712;</div></div>