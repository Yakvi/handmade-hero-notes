<meta charset="utf-8" />
<link rel="stylesheet" href="../css/style.css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  MathJax.Hub.Insert(MathJax.InputJax.TeX.Definitions.macros,{
    cancel: ["Extension","cancel"],
    bcancel: ["Extension","cancel"],
  });
});
</script>

**Day 20. Debugging the Audio Sync** 
_Video Length (including Q&A): [2h46](https://hero.handmade.network/episode/code/day020/)_ 

(insert intro.md.html here) 

If you've got this far, congratulations! Debugging sound issues may well be among the most tedious tasks one would face (even if that's your cup of tea). However, we aren't out of the woods yet; the system we have in our hands right now is still quite latent, and there's room for improvement even at this early stage. Sure, with the default sound API and the integrated sound module, audio is laggy. But what about the sound junkies who have powerful cards with close to zero latency on the sound output? We want to support them as well! And today we need to think real hard to make it happen.

You might have noticed a trend throughout this series: think first, and type after. If you understand at least on assumption level the code that you're about to write, it will be much easier for you to  translate your thoughts into good code. And the benefits don't stop here! You will actually be able to read and edit it after a while. That said, you never want to go too deep and define every single scrupulous detail in advance: at that point, you might as well write the code directly! Leave yourself some space for a good surprise.

Today however, we will mix the two together. It's a complex topic that we can simplify by performing one step at a time, instead of trying to do the whole thing at once. If we find out that we were incorrect initially, the fix shouldn't be too difficult to make.

# Deep Dive into the Issue

## Define the Problem

Let's go back to our favorite timeline chart. We have our video frames which update every "frame flip" until the game stops running.

***************************************************************
*                     Next Frame Preparation                  *
*             (User Input processing, World update,           *
*             Graphics rendering and writing Audio)           *
*                      /     |      |     \                   *
*                   .-+.   .-+.   .-+.   .-+.                 *
*                  |    | |    | |    | |    |                *
* |               |      |      |      |      |          time *
* +---------------+------+------+------+-....-+------+---->   *
* |               |      |      |      |      |      |        *
*                 0      1      2     ...     N               *
* ^               ^      ^      ^      ^      ^      ^        *
* |               |       \      \     |     /       |        *
* |               |        \      \    |    /        |        *
* game           first    Next frame is displayed    game     *
* starts         frame          "frame flip"         exits    *
* running        is displayed                                 *
*                                                             *
***************************************************************
[Figure [x]: Game lifetime. Everything on it should be familiar to you by now.]

For the moment, we're aiming at 30 frames per second frequency of the frame flips. This means that every second (or every 1000 milliseconds) we output 30 frames. Thus each frame only has $\frac{1000}{30} \approx 33.3$ milliseconds to do all the work. 

Each frame we want to display the image and the sound of our next frame. In an ideal world, both would go out at the same time. 

***************************************************************
*               .---. image is                                *
*               | ðŸ•º | displayed                               *
*               '---'                                         *
*                audio is played                              *
*               +~~~~~~~~~~~~~                                *
* |   frame 0   |   frame 1   |   frame 2   |   ...      time *
* +---+---------+-------------+-------------+------------->   *
* |   ^         ^                                             *
*     |         |                                             *
*     +--------'                                              *
*     |         Frame                                         *
*    Work       Flip                                          *
*   starts                                                    *
*                                                             *
*                                                             *
***************************************************************
[Figure [x]: Frame flip workflow in an ideal world.]

This work happens some time after the frame begins: before we get started on rendering, we need to collect the user input, update our world state, etc. Even further still, we're currently writing audio just before the frame flip, at the last possible moment in fact. The idea being that the moment we send something to the hardware, it will be reproduced to the user.

*******************************************************************
*                                                                 *
*        Update game world                                        *
*        Prepare for render                        wait           *
*              |                                    |             *
*           .--+---.                           .----+---.         *
*    |     |        |                         |          | repeat *
* ---+-----+--------+-------------------------+----------+-->     *
*    |     |        |                         |          ^        *
*     '-+-'          '-----------+-----------'           |        *
*       |                        |                   frame flip   *
*   gather input               Render                             *
* (keyboard, mouse,                                               *
*     gamepad)                                                    *
*                                                                 *
*******************************************************************
[Figure [x]: Breakdown of the work within a single frame. Proportions of game update/render times will differ. Of course, some of these tasks may run in parallel in the future.]

Unfortunately for us, hardware lag exists, so things do not happen immediately. Furthermore, DirectSound (on our specific machine) is not cooperating with us. Last time, we determined that the API has a delay of 30ms! That's in fact almost full frame! So this is what happens with our frames in reality: 

***************************************************************
*               .---. image is                                *
*               | ðŸ•º | displayed                               *
*               '---'                                         *
*               |            audio is played                  *
*               |           +~~~~~~~~~~~~~                    *
* |   frame 0   |  frame 1  | |   frame 2   |   ...      time *
* +---+---------+-----------+-+-------------+------------->   *
* |   ^       ^ |           | |             |                 *
*     |       | ^           |                                 *
*     |       |  \          |                                 *
*    Work     |   '----expected                               *
*   starts    |       frame flip                              *
*             |             |                                 *
*         Send audio        |                                 *
*       samples to the      |                                 *
*      Operating System     |                                 *
*             |             |                                 *
*              '----. .----'                                  *
*                    |                                        *
*         Windows/Hardware route audio                        *
*             for reproduction                                *
***************************************************************
[Figure [x]: Frame flip workflow in our reality.]

As you can see, by the time audio starts playing, it's almost time for the next frame to flip! And, when we blindly assumed low latency scenario, this is what created the audible clicks for us: information kept getting overwritten from under the Play Cursor. 

What this means is that, when we were writing audio, we were telling to write waaay before it was safe. DirectSound API works on two cursors: Play Cursor and Write Cursor. The API reads the audio bytes from the area _around_ the Play Cursor, with the Write Cursor represents the first _safe_ point user can write to. We're ignoring the write cursor for the time being and write to wherever we feel is appropriate to our needs. 

That's why we needed to add the additional frames of latency: simply to allow the write cursor to advance. Even further still, currently we're asking for the cursors location at the end of _previous_ frame. This means that, by the time we get to compute audio, the cursors have advanced even further, resulting in a whopping 3 frames of latency!

****************************************************************************
*                                                                          *
*                           "Ignore" the WriteCursor and define our own    *
*           +--------------> TargetCursor based on expected frame flip;    *
*           |               offset it by a specific latency to always be   *
*           |                         in the "safe zone"                   *
*           |                                                    |         *
*    |      |                                                    v         *
* -+-+------+------------+--------+----------+--------+----------+---->    *
*  ^ |      |            |        ^          |                   |         *
*  | .---.  |            .---.    |          .---.               .---.     *
*  | | ðŸ•º |  |            | ðŸ•º |    |          | ðŸ•º |               | ðŸ•º |     *
*  | '---'  |            '---'    |          '---'               '---'     *
* Ask where the                   |          |                             *
*  DirectSound                    |          |                             *
*  cursors are                    |          |                             *
*           |                     |          |                             *
*       PlayCursor           WriteCursor     |                             *
*                                            |                             *
*                                            +~~~~~~~~~~~~~~~~~~~          *
*                                    Audio will play until the             *
*                                TargetCursor, for exactly one frame       *
*                                                                          *
****************************************************************************
[Figure [x]: Our current approach. ðŸ•º represents frame flips.]

If we want to avoid latency, we'd ideally have to send audio data before our rendering work on a frame even starts! This isn't necessarily impossible but would introduce frame lag anyway, since the new user input and world state wouldn't be accounted in the old sound... On surface this seems like chasing one's own tail.

## Evaluate the Options

At the end of the day, under the current system there's no way to compute sound for a frame and have it reproduced together with its image when we intend it to. This leaves us with the following options: 

* Accept the reality that our audio will always be a couple frames behind the image. After all, so many games already do this! This would simply regress our audio to be latent by design.
* Have a "low latency mode" which would take over on a machine with a great sound card and low latency; do things the slow way otherwise. 
* Continue tinkering on the inner workings of our platform layer.
* Fix latency issues by essentially getting input and world state a frame before. This, however, would introduce input lag, which seems like a worse tradeoff in an action game like ours will be. 

The last option in our particular case seems to be the worst of all, so we can rule it out straight away. In fact, we want to push the input capture as close to the frame flip as possible, so that the user doesn't get a feeling of an unresponsive game.

Let's start with the simplest solution we might imagine. We write our sound to the hardware as soon as we have it, without waiting for frame flip. So if, for instance, audio is sent out 15ms after the frame starts, it will be reproduced ~15ms after the frame flip occurred. 

The game won't know of this happening: platform will lie to the game saying that the audio will be reproduced at the frame flip. 

***************************************************************
*               .---. image is                                *
*               | ðŸ•º | displayed                               *
*               '---'                                         *
*               |       audio is played                       *
*               |      +~~~~~~~~~~~~~                         *
* |             |      |      |             |   ...      time *
* +------+------+------+------+-------------+------------->   *
* |      ^      |             |             |                 *
*        |      ^                                             *
*        |      |                                             *
* Calculate and |                                             *
* send audio    |                                             *
*               |                                             *
*           frame flip                                        *
*                                                             *
***************************************************************
[Figure [x]: Sending the audio out as soon as it's ready.]

!!! Trivia 
    Unfortunately, this kind of unsynchronized audio loop is common in the industry. It's a bit sloppy but better than the alternative of pushing audio to the next frame and have a whole frame of buffering instead of roughly a half. 

This solution also opens the road for the "low latency mode" we proposed above. If we determine that we're playing on an extremely performant hardware, the sound will be target the frame flip instead.

## Tracking Audio Latency

We calculated last time our latency by subtracting the write cursor from the play cursor. We did it on calculator, so let's capture it in our debug output for simplicity. We can do this by simply subtracting the write cursor from the play cursor:

~~~~~~~ C++
#if HANDMADE_INTERNAL
DWORD PlayCursor;
DWORD WriteCursor;
GlobalSecondaryBuffer->GetCurrentPosition(&PlayCursor, &WriteCursor);

~~~~~~~ C++ add
DWORD AudioLatencyBytes = WriteCursor - PlayCursor;
~~~~~~~ C++

char TextBuffer[256];
~~~~~~~ C++ edit
sprintf_s(TextBuffer, sizeof(TextBuffer), "LPC:%u BTL:%u TC:%u BTW:%u - PC:%u WC:%u DELTA:%u\n",
            LastPlayCursor, ByteToLock, TargetCursor, BytesToWrite,
            PlayCursor, WriteCursor, AudioLatencyBytes);
~~~~~~~ C++
OutputDebugStringA(TextBuffer);
#endif
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Tracking audio delta.]

However, we need to remember that audio buffer is a circular buffer so the value we'll get sometimes might be negative. This happens when the write cursor "wraps around" to the beginning of the buffer while the play cursor is still at the end. In order to circumvent this issue, we can "unwrap" the `WriteCursor` value in those cases, by simply adding to it the length of the secondary buffer. It's a simple trick but quite effective. We'll use in another instance later today.

**********************************************************************
*                                                                    *
*                       UnwrappedWriteCursor                         *
*                               |                                    *
*  |                          | v                        |           *
*  +-+---------------------+--+â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯â‹¯+           *
*  | ^                     ^  |                          |           *
*    |                     |                                         *
* WriteCursor          PlayCursor                                    *
*                                                                    *
**********************************************************************
[Figure [x]: If we add the circular buffer's length to the value of Write Cursor, we effectively unwrap it.]

This is a circular buffer so we need to account for when the write cursor is in front.

~~~~~~~ C++ add
DWORD UnwrappedWriteCursor = WriteCursor;
if (UnwrappedWriteCursor < PlayCursor)
{
    UnwrappedWriteCursor += SoundOutput.SecondaryBufferSize;
}
~~~~~~~ C++ edit
DWORD AudioLatencyBytes = UnwrappedWriteCursor - PlayCursor;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Accounting for circular buffer wrap.]

Let's compile and run our program in the debugger. You should see a static DELTA value, which on our machine is 5760 bytes:

~~~~~~~ batch
BTL:373332 TC:379093 BTW:5761 - PC:364800 WC:370560 DELTA:5760
BTL:379092 TC:2773 BTW:7681 - PC:372480 WC:378240 DELTA:5760
BTL:2772 TC:8533 BTW:5761 - PC:378240 WC:0 DELTA:5760
BTL:8532 TC:14293 BTW:5761 - PC:0 WC:5760 DELTA:5760
BTL:14292 TC:21973 BTW:7681 - PC:7680 WC:13440 DELTA:5760
~~~~~~~
[Listing [x]: <file>[Debug Output]</file> You will notice that delta is calculated correctly in case of buffer wrap, as we anticipated.]

We could go even further, and calculate how many seconds does this amount of bytes translate to. Using some dimensional analysis you can quickly derive the following: 

$$ bytes \times (\frac{samples}{bytes}) \times (\frac{seconds}{samples}) = $$
$$\frac{\bcancel{bytes} \times \bcancel{samples} \times seconds}{1 \times \bcancel{bytes} \times \bcancel {samples}} =$$
$$ seconds $$

Since we don't have SamplesPerBytes and SecondsPerSample but the contrary, we'll need to do division instead. We will store the resulting value as a real (${\rm I\!R}$) number inside a float. When we'll pass it to `sprintf_s` function, we can use `%f` operator to read the float, or even `%.3f` to only display the first 3 decimal points (and round the rest).

~~~~~~~ C++
DWORD UnwrappedWriteCursor = WriteCursor;
if (UnwrappedWriteCursor < PlayCursor)
{
    UnwrappedWriteCursor += SoundOutput.SecondaryBufferSize;
}
DWORD AudioLatencyBytes = UnwrappedWriteCursor - PlayCursor;
~~~~~~~ C++ add
f32 AudioLatencySeconds = ((f32)AudioLatencyBytes / (f32)SoundOutput.BytesPerSample) / 
                           (f32)SoundOutput.SamplesPerSecond;
~~~~~~~ C++
char TextBuffer[256];
~~~~~~~ C++ edit
sprintf_s(TextBuffer, sizeof(TextBuffer), "LPC:%u BTL:%u TC:%u BTW:%u - PC:%u WC:%u DELTA:%u (%.3fs)\n",
            LastPlayCursor, ByteToLock, TargetCursor, BytesToWrite,
            PlayCursor, WriteCursor, AudioLatencyBytes, AudioLatencySeconds);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Displaying latency in seconds.]

!!! Note 
    We've encountered already an operation where we need to divide by samples per second. In fact, it's quite prone to error and we might want to pull out these calculations in the future. For the time being, let's place a todo for the future us to add a bytes per second field:

    ~~~~~~~ C++
    struct win32_sound_output
    {
        int SamplesPerSecond;
        int BytesPerSample;
        DWORD SecondaryBufferSize;
        u32 RunningSampleIndex;
        int LatencySampleCount;
    ~~~~~~~ C++ add
        // TODO(casey): Math get simpler if we add a "bytes per second" field? 
    ~~~~~~~ C++
    };
    ~~~~~~~
    [Listing [x]: <file>[win32_handmade.h]</file> Adding a todo for the future.]

## Review Target Bytes calculation

If you remember, this is how we define how many samples do we want to send to the buffer.

* `ByteToLock` defines from which point on should we start writing.
* `TargetCursor` defines until where we're writing. 
* `BytesToWrite` is the difference between the two (considering circular buffer wrap).

Up until now, we were setting our `ByteToLock` to be whatever our `RunningSampleIndex` was. We would then calculate target cursor which would be the last known play cursor's location. We wouldn't really consider where the Write Cursor, just leave enough room (`LatencySampleCount`) for us to surely get ahead of it. 

Now we will start taking into account the DirectSound's write cursor. If it's within this frame's boundaries, we can assume that we are on a low latency hardware, and get on the "Low Latency Path". In this case, we presume that we're able to write up from the frame flip, so we offset the `TargetCursor` until the next frame's boundary so that audio will always goes out with the image.

*****************************************************************************
*                                                                           *
*                        Set TargetCursor                                   *
*                       to the end of next frame                            *
*                    .------------------------------.                       *
*                   |                               |                       *
*    |              |        |                      v|                      *
*    +------+-------+--------+-----------------------+------------->        *
*    |      ^       ^        |                       |                      *
*    .---.  |       |        .---.                   .---.                  *
*    | ðŸ•º |  |       |        | ðŸ•º |                   | ðŸ•º |                  *
*    '---'  |       |        '---'                   '---'                  *
*     Ask where the |        |                                              *
*      DirectSound  |        |                                              *
*      cursors are  |        |                                              *
*        |          |        |                                              *
*        +-->  WriteCursor   |                                              *
*      PlayCursor            |                                              *
*                            +~~~~~~~~~~~~~~~~~~~~~~~                       *
*                            audio is playing for exactly one frame         *
*                            rinse and repeat for infinite sound            *
*                                                                           *
*****************************************************************************
[Figure [x]: Low latency path idea.]

If the Write Cursor is beyond this frame, we assume that the latency is high. Then we won't wait until the frame flip, and the `TargetCursor` can be whatever our `WriteCursor` would be after one frame. We will offset it by but a small safety margin (a few milliseconds) to account for potential variability in the latency between now and the output.

*****************************************************************************
*                                                                           *
*                     Set TargetCursor to be slightly further ahead         *
*                                from the WriteCursor                       *
*                     (just a safety margin, don't wait until flip)         *
*                                      .------------------------.           *
*                                     |                          |          *
*    |                                |              |           v          *
*    +------+----------------+--------+--------------+-----------+->        *
*    |      ^                |        ^       |      |                      *
*    .---.  |                .---.    |       |      .---.                  *
*    | ðŸ•º |  |                | ðŸ•º |    |       |      | ðŸ•º |                  *
*    '---'  |                '---'    |       |      '---'                  *
*     Ask where the                   |       |                             *
*      DirectSound                    |       |                             *
*      cursors are                    |       |                             *
*        |                            |       |                             *
*        +-------------------->  WriteCursor  |                             *
*     PlayCursor                              |                             *
*                                             +~~~~~~~~~~~~~~~~~~~          *
*                            audio is still playing for exactly one frame   *
*                             but it's scheduled one frame earlier          *
*                                                                           *
*****************************************************************************
[Figure [x]: High latency path.]

All of this wouldn't impact our `ByteToLock` or `BytesToWrite` calculation (or, at least, not directly). However, given that `TargetCursor` will move depending on the hardware's latency, the rest of these values will move accordingly.

# Implement the Two Audio Paths

## Clean Up the Old Code

Alright, let's get cracking. First of all, let's get rid of the `LastPlayCursor`, it's gone. We'll need to remove it from the beginning of our `WinMain`, as well as any usage we encounter along the way. We won't need it anymore, because we'll do all the computations as soon as we get the cursor values.

~~~~~~~ C++
int DebugTimeMarkerIndex = 0;
win32_debug_time_marker DebugTimeMarkers[GameUpdateHz / 2] = {};

~~~~~~~ C++ delete
DWORD LastPlayCursor = 0;
~~~~~~~ C++
b32 SoundIsValid = false;

// ... 
// Towards the end of WinMain
// ... 

DWORD PlayCursor = 0;
DWORD WriteCursor= 0;
if (SUCCEEDED(GlobalSecondaryBuffer->GetCurrentPosition(&PlayCursor, &WriteCursor)))
{
~~~~~~~ C++ delete
    LastPlayCursor = PlayCursor;
~~~~~~~ C++
    if (!SoundIsValid)
    {
        SoundOutput.RunningSampleIndex = WriteCursor / SoundOutput.BytesPerSample;
        SoundIsValid = true;
    }
}

//... 
~~~~~~~ C++
f32 AudioLatencySeconds = ((f32)AudioLatencyBytes / (f32)SoundOutput.BytesPerSample) /
                            (f32)SoundOutput.SamplesPerSecond;
char TextBuffer[256];
~~~~~~~ C++ edit
sprintf_s(TextBuffer, sizeof(TextBuffer), "BTL:%u TC:%u BTW:%u - PC:%u WC:%u DELTA:%u (%.2fs)\n",
            ByteToLock, TargetCursor, BytesToWrite,
            PlayCursor, WriteCursor, AudioLatencyBytes, AudioLatencySeconds);
~~~~~~~ C++
OutputDebugStringA(TextBuffer);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Retiring `LastPlayCursor`.]

We can now consolidate the blocks dealing with the audio. For our debug code capturing the markers for visual display, we will have the own position calculation. Since it will happen quite close to the frame flip, we might as well consider these cursors as the Flip Cursors. 

The sound initialization block can be removed for now, we'll move it to another section in a second.

~~~~~~~ C++ delete
DWORD PlayCursor = 0;
DWORD WriteCursor= 0;
if (SUCCEEDED(GlobalSecondaryBuffer->GetCurrentPosition(&PlayCursor, &WriteCursor)))
{
    if (!SoundIsValid)
    {
        SoundOutput.RunningSampleIndex = WriteCursor / SoundOutput.BytesPerSample;
        SoundIsValid = true;
    }
}
else
{
    SoundIsValid = false;
}
~~~~~~~ C++
#if HANDMADE_INTERNAL
// NOTE(casey): This is debug code
{
~~~~~~~ C++ add
    DWORD FlipPlayCursor = 0;
    DWORD FlipWriteCursor= 0;
    if (SUCCEEDED(GlobalSecondaryBuffer->GetCurrentPosition(&FlipPlayCursor, &FlipWriteCursor)))
    {
~~~~~~~ C++
        Assert(DebugTimeMarkerIndex < ArrayCount(DebugTimeMarkers));
        win32_debug_time_marker *Marker = &DebugTimeMarkers[DebugTimeMarkerIndex++];
        if (DebugTimeMarkerIndex == ArrayCount(DebugTimeMarkers))
        {
            DebugTimeMarkerIndex = 0;
        }
~~~~~~~ C++ edit
        Marker->PlayCursor = FlipPlayCursor;
        Marker->WriteCursor = FlipWriteCursor;
~~~~~~~ C++ add
    }
~~~~~~~ C++
}
#endif
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Simplifying blocks structure.]

Next, we will delete the whole block calculating the cursors. Not all of this code is obsolete though, `ByteToLock` will still be useful. We will recreate it further down below.

~~~~~~~ C++ delete
DWORD ByteToLock = 0;
DWORD TargetCursor = 0;
DWORD BytesToWrite = 0;

if (SoundIsValid)
{
    ByteToLock = ((SoundOutput.RunningSampleIndex * SoundOutput.BytesPerSample)
                    % SoundOutput.SecondaryBufferSize);
    
    TargetCursor = ((LastPlayCursor +
                        (SoundOutput.LatencySampleCount * SoundOutput.BytesPerSample))
                    % SoundOutput.SecondaryBufferSize);
    
    if(ByteToLock > TargetCursor)
    {
        BytesToWrite = SoundOutput.SecondaryBufferSize - ByteToLock;
        BytesToWrite += TargetCursor;
    }
    else
    {
        BytesToWrite = TargetCursor - ByteToLock;
    }
}
~~~~~~~ C++

game_sound_output_buffer SoundBuffer = {};
SoundBuffer.SamplesPerSecond = SoundOutput.SamplesPerSecond;
SoundBuffer.SampleCount = BytesToWrite / SoundOutput.BytesPerSample;
SoundBuffer.Samples = Samples;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Removing previous cursor calculation routine.]

Finally, a bit further below, immediately after `GameUpdateAndRender`, we will house our new code for the audio calculation. We will add here all the pieces that were useful in the past, all in one place:

1. Capture position of the Play and Write cursors.
2. If the sound is not valid (we've just started, or something happened), initialize the `RunningSampleIndex`. This functionality is the same as we had before.
3. Calculate `ByteToLock` (same as before).
4. Calculate `TargetCursor` (same as before, for a moment, but already set up for eventual change).
5. Calculate `BytesToWrite` (same as before).
6. Fill the sound buffer with the samples we collected during `GameUpdateAndRender`.
7. If we're in debug mode (`HANDMADE_INTERNAL`), print out the various values we computed above.
8. Last, if by any chance `GetCurrentPosition` fails, we will do nothing of the above and simply mark `SoundIsValid` false.

~~~~~~~ C++
GameUpdateAndRender(...);

~~~~~~~ C++ add
DWORD PlayCursor;
DWORD WriteCursor;
if (GlobalSecondaryBuffer->GetCurrentPosition(&PlayCursor, &WriteCursor) == DS_OK)
{
    if (!SoundIsValid)
    {
        SoundOutput.RunningSampleIndex = WriteCursor / SoundOutput.BytesPerSample;
        SoundIsValid = true;
    }
    
    DWORD ByteToLock = ((SoundOutput.RunningSampleIndex * SoundOutput.BytesPerSample)
                        % SoundOutput.SecondaryBufferSize);
        
    DWORD TargetCursor = 0;
    TargetCursor = ((LastPlayCursor +
                        (SoundOutput.LatencySampleCount * SoundOutput.BytesPerSample))
                    % SoundOutput.SecondaryBufferSize);
    
    DWORD BytesToWrite = 0;
    if(ByteToLock > TargetCursor)
    {
        BytesToWrite = SoundOutput.SecondaryBufferSize - ByteToLock;
        BytesToWrite += TargetCursor;
    }
    else
    {
        BytesToWrite = TargetCursor - ByteToLock;
    }
~~~~~~~ C++ delete
if(SoundIsValid)
{
~~~~~~~ C++
    Win32FillSoundBuffer(&SoundOutput, ByteToLock, BytesToWrite, &SoundBuffer);

#if HANDMADE_INTERNAL
~~~~~~~ C++ delete
    DWORD PlayCursor;
    DWORD WriteCursor;
    GlobalSecondaryBuffer->GetCurrentPosition(&PlayCursor, &WriteCursor);
~~~~~~~ C++
    
    DWORD UnwrappedWriteCursor = WriteCursor;
    if (UnwrappedWriteCursor < PlayCursor)
    {
        UnwrappedWriteCursor += SoundOutput.SecondaryBufferSize;
    }
    DWORD AudioLatencyBytes = UnwrappedWriteCursor - PlayCursor;
    f32 AudioLatencySeconds = ((f32)AudioLatencyBytes / (f32)SoundOutput.BytesPerSample) /
                               (f32)SoundOutput.SamplesPerSecond;
    char TextBuffer[256];
    sprintf_s(TextBuffer, sizeof(TextBuffer), 
                "LPC:%u BTL:%u TC:%u BTW:%u - PC:%u WC:%u DELTA:%u (%.2fs)\n",
                LastPlayCursor, ByteToLock, TargetCursor, BytesToWrite,
                PlayCursor, WriteCursor, AudioLatencyBytes, AudioLatencySeconds);
    OutputDebugStringA(TextBuffer);
#endif
}
~~~~~~~ C++ add
{
    // GetCurrentPosition didn't succeed
    SoundIsValid = false;
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Simplifying and combining audio blocks.]

Last, we want to record our theory for the audio paths, so let's annotate what we decided: 

~~~~~~~ C++
DWORD PlayCursor;
DWORD WriteCursor;
if (GlobalSecondaryBuffer->GetCurrentPosition(&PlayCursor, &WriteCursor) == DS_OK)
{
~~~~~~~ C++ add
    /* NOTE(casey):

    Here is how sound output computation works.

    We define a safety value that is the number 
    of samples we think our game update loop 
    may vary by (let's say up to 2ms). 

    When we wake up to write audio, we will look
    and see what the play cursor position is and we
    will forecast ahead where we think the
    play cursor will be on the next frame boundary.

    We will then look to see if the write cursor is
    before that by at least our safety value. If it is, the
    target fill position is that frame boundary
    plus one frame. This gives us perfect audio
    sync in the case of a card that has low enough
    latency.

    If the write cursor is _after_ that safety 
    margin, then we assume we can never sync the
    audio perfectly, so we will write one frame's
    worth of audio plus the safety margin's worth
    of guard samples.
    */
~~~~~~~ C++
if (!SoundIsValid)
{
    SoundOutput.RunningSampleIndex = WriteCursor / SoundOutput.BytesPerSample;
    SoundIsValid = true;
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Noting down our theory.]

## Change `TargetCursor` Calculation

Everything is set up, let's go ahead with the changes we need. We'll write how we imagine target cursor calculation first, and think about making it happen later.

* For the fast path (low latency card), we would position ourselves at the expected frame boundary of the next frame.
* For the slow path the write cursor position, move by one frame's length and add some safety bytes.

In both cases the resulting value may be greater than the size of our buffer, so in order to bind it to the buffer, we'll simply _modulo_ it against the buffer size. As a reminder, _modulo_ operator (`%`) keeps the remainder of a given division.

~~~~~~~ C++
DWORD TargetCursor = 0;
~~~~~~~ C++ add
if (AudioCardIsLowLatency)
{
~~~~~~~ C++ edit
    TargetCursor = ExpectedFrameBoundaryByte + ExpectedSoundBytesPerFrame;
~~~~~~~ C++ add
}
else
{
    TargetCursor = WriteCursor + ExpectedSoundBytesPerFrame + SoundOutput.SafetyBytes;
}
TargetCursor = TargetCursor % SoundOutput.SecondaryBufferSize;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Preparing two cases for TargetCursor calculation.]

Now we just have to compute all those new values. 

Let's start with `AudioCardIsLowLatency`. We define the latency by taking `ExpectedFrameBoundaryByte` and check if it's greater than the write cursor with the safety margin.

~~~~~~~ C++ add
b32 AudioCardIsLowLatency = true;
DWORD SafeWriteCursor = WriteCursor + SoundOutput.SafetyBytes;
if (SafeWriteCursor >= ExpectedFrameBoundaryByte)
{
    AudioCardIsLowLatency = false;
}
~~~~~~~ C++
DWORD TargetCursor = 0;
if (AudioCardIsLowLatency)
//...
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Determining if our sound card is latent.]

Or, in other words, 

~~~~~~~ C++ edit
DWORD SafeWriteCursor = WriteCursor + SoundOutput.SafetyBytes;
b32 AudioCardIsLowLatency = SafeWriteCursor < ExpectedFrameBoundaryByte;
~~~~~~~ C++

DWORD TargetCursor = 0;
if (AudioCardIsLowLatency)
//...
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> A more concise notation of the above.]

However, there's always the circular buffer issue that we need to take into account: if the write cursor is behind the play cursor, it means the buffer wrapped, and we need to "unwrap" the cursor as we've done earlier: simply add the sound buffer size to write cursor's value.

~~~~~~~ C++ edit
DWORD SafeWriteCursor = WriteCursor;
~~~~~~~ C++ add
if (SafeWriteCursor < PlayCursor)
{
    SafeWriteCursor += SoundOutput.SecondaryBufferSize;
}
Assert(SafeWriteCursor >= PlayCursor);
SafeWriteCursor += SoundOutput.SafetyBytes;
~~~~~~~ C++
b32 AudioCardIsLowLatency = SafeWriteCursor < ExpectedFrameBoundaryByte;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Normalizing write cursor.]

// BOOKMARK

`ExpectedFrameBoundaryByte`: 

~~~~~~~ C++ add
DWORD ExpectedFrameBoundaryByte = PlayCursor + ExpectedSoundBytesPerFrame;
~~~~~~~ C++
DWORD SafeWriteCursor = WriteCursor + SoundOutput.SafetyBytes;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Calculating expected frame flip boundary.]

~~~~~~~ C++ add
DWORD ExpectedSoundBytesPerFrame = (SoundOutput.SamplesPerSecond * SoundOutput.BytesPerSample)
                            / GameUpdateHz ;

~~~~~~~ C++
DWORD ExpectedFrameBoundaryByte = PlayCursor + ExpectedSoundBytesPerFrame;
DWORD SafeWriteCursor = WriteCursor;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Calculating expected sound bytes per frame.]

~~~~~~~ C++ delete
#define FramesOfAudioLatency 3
~~~~~~~ C++
// TODO(casey): How do we reliably query on monitor refresh rate on Windows?
#define MonitorRefreshHz 60
#define GameUpdateHz (MonitorRefreshHz / 2)

// ... 

// NOTE(casey): Sound test
win32_sound_output SoundOutput = {};
SoundOutput.SamplesPerSecond = 48000;
SoundOutput.BytesPerSample = sizeof(s16) * 2;
SoundOutput.SecondaryBufferSize = 2 * SoundOutput.SamplesPerSecond * SoundOutput.BytesPerSample;
SoundOutput.RunningSampleIndex = 0;
~~~~~~~ C++ delete
SoundOutput.LatencySampleCount = FramesOfAudioLatency *(SoundOutput.SamplesPerSecond / GameUpdateHz);
~~~~~~~ C++ add
// TODO(casey): Actually compute this variance and see 
// what the lowest reasonable value is.
SoundOutput.SafetyBytes = (SoundOutput.SamplesPerSecond * SoundOutput.BytesPerSample) 
    / GameUpdateHz) / 3;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Calculating safety bytes.]

~~~~~~~ C++
struct win32_sound_output
{
    int SamplesPerSecond;
    int BytesPerSample;
    DWORD SecondaryBufferSize;
    u32 RunningSampleIndex;
~~~~~~~ C++ delete
    int LatencySampleCount;
~~~~~~~ C++ add
    DWORD SafetyBytes;
~~~~~~~ C++
    // TODO(casey): Math get simpler if we add a "bytes per second" field?
};
~~~~~~~
[Listing [x]: <file>[win32_handmade.h]</file> Updating `win32_sound_output` structure.]


Concern: GameUpdateAndRender happens after our cursor calculation happens, so we don't really know how long is our frame going to take, only an estimate. That's fine since we know the _expected_ time? 

Getting real audio sync is complicated. We need to sync two clocks - game clock and audio device clock. We also need to know how many bytes to ask from the game but in order to know that we need to prepare the samples... so it's getting a bit of a vicious cycle.

Solution: separate audio and game update and rendering!

~~~~~~~ C++
struct game_memory
{
    u64 PermanentStorageSize;
    void *PermanentStorage;
    u64 TransientStorageSize;
    void *TransientStorage;
    b32 IsInitialized;
};

~~~~~~~ C++ edit
internal void GameUpdateAndRender(game_memory *Memory, game_input *Input, game_offscreen_buffer* Buffer);
~~~~~~~ C++ add
internal void GetSoundSamples(game_memory *Memory, game_sound_output_buffer *SoundBuffer);
~~~~~~~
[Listing [x]: <file>[handmade.h]</file> Splitting sound update from the rest of the game update.]

~~~~~~~ C++ delete
game_sound_output_buffer SoundBuffer = {};
SoundBuffer.SamplesPerSecond = SoundOutput.SamplesPerSecond;
SoundBuffer.SampleCount = BytesToWrite / SoundOutput.BytesPerSample;
SoundBuffer.Samples = Samples;

~~~~~~~ C++

game_offscreen_buffer Buffer = {};
Buffer.Memory = GlobalBackbuffer.Memory;
Buffer.Width = GlobalBackbuffer.Width;
Buffer.Height = GlobalBackbuffer.Height;
Buffer.Pitch = GlobalBackbuffer.Pitch;

// ...

else
{
    BytesToWrite = TargetCursor - ByteToLock;
}

~~~~~~~ C++ add
game_sound_output_buffer SoundBuffer = {};
SoundBuffer.SamplesPerSecond = SoundOutput.SamplesPerSecond;
SoundBuffer.SampleCount = BytesToWrite / SoundOutput.BytesPerSample;
SoundBuffer.Samples = Samples;

GameGetSoundSamples(&GameMemory, &SoundBuffer);

~~~~~~~ C++
Win32FillSoundBuffer(&SoundOutput, ByteToLock, BytesToWrite, &SoundBuffer);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Using `GameGetSoundSamples`.]

~~~~~~~ C++
internal void
~~~~~~~ C++ edit
GameUpdateAndRender(game_memory* Memory, game_input *Input, game_offscreen_buffer* Buffer)
~~~~~~~ C++
{
    Assert((&Input->Controllers[0].Terminator - &Input->Controllers[0].Buttons[0]) ==
           (ArrayCount(Input->Controllers[0].Buttons)));
    Assert(sizeof(game_state) <= Memory->PermanentStorageSize);
    game_state *GameState = (game_state*)Memory;
    
    if(!Memory->IsInitialized)
    {
        debug_read_file_result FileData = DEBUGPlatformReadEntireFile(__FILE__);
        if (FileData.Contents)
        {
            DEBUGPlatformWriteEntireFile("test.out", FileData.ContentsSize, FileData.Contents);
            DEBUGPlatformFreeFileMemory(FileData.Contents);
        }
        
        GameState->XOffset = 0;
        GameState->YOffset = 0;
        GameState->ToneHz = 256;
        
        Memory->IsInitialized = true;
    }
    
    for (int ControllerIndex = 0;
         ControllerIndex < ArrayCount(Input->Controllers);
         ++ControllerIndex)
    {
        
        game_controller_input *Controller = GetController(Input, ControllerIndex);
        if (Controller->IsAnalog)
        {
            // NOTE(casey): Use analog movement tuning
            GameState->XOffset += (int)(4.0f * Controller->StickAverageX);
            GameState->ToneHz = 256 + (int)(128.0f * (Controller->StickAverageY));
        }
        else
        {
            // NOTE(casey): Use digital movement tuning
            if (Controller->MoveLeft.EndedDown)
            {
                GameState->XOffset -= 1;
            }
            
            if (Controller->MoveRight.EndedDown)
            {
                GameState->XOffset += 1;
            }
        }
        
        if(Controller->ActionDown.EndedDown)
        {
            GameState->YOffset += 1;
        }
    }
    
~~~~~~~ C++ delete
    GameSoundOutput(SoundBuffer, GameState->ToneHz);
~~~~~~~ C++
    RenderWeirdGradient(Buffer, GameState->XOffset, GameState->YOffset);
}

~~~~~~~ C++ add
internal void
GameGetSoundSamples(game_memory* Memory, game_sound_output_buffer *SoundBuffer)
{
    game_state *GameState = (game_state*)Memory;
    GameSoundOutput(SoundBuffer, GameState->ToneHz);
}
~~~~~~~

yay!

# Improve Debug Drawing Routine

Let's have some fun!

## Highlight Latest Marker

~~~~~~~ C++
internal void
Win32DebugSyncDisplay(win32_offscreen_buffer *Backbuffer,
                      int MarkerCount, win32_debug_time_marker *Markers,
~~~~~~~ C++ add
                      int CurrentMarkerIndex,
~~~~~~~ C++
                      win32_sound_output *SoundOutput, f32 TargetSecondsPerFrame)
{
    int PadX = 16;
    int PadY = 16;
    
~~~~~~~ C++ add
    int LineHeight = 64;
~~~~~~~ C++ delete
    int Top = PadY;
    int Bottom = Backbuffer->Height - PadY;
~~~~~~~ C++
    
    f32 C = (f32)(Backbuffer->Width - 2 * PadX) / (f32)SoundOutput->SecondaryBufferSize;
    for (int MarkerIndex = 0;
         MarkerIndex < MarkerCount;
         ++MarkerIndex)
    {
~~~~~~~ C++ add
        DWORD PlayColor = 0xFFFFFFFF;
        DWORD WriteColor = 0xFFFF0000;
        
        int Top = PadY;
        int Bottom = PadY + LineHeight;
        
        if (MarkerIndex == CurrentMarkerIndex)
        {
            Top += LineHeight + PadY;
            Bottom += LineHeight + PadY;
        }
~~~~~~~ C++
        
        win32_debug_time_marker *ThisMarker = &Markers[MarkerIndex];
~~~~~~~ C++ edit
        Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom, ThisMarker->PlayCursor, PlayColor);
        Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom, ThisMarker->WriteCursor, WriteColor);
~~~~~~~ C++
    }
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp]</file> Improving `Win32DebugSyncDisplay`.]

~~~~~~~ C++
#if HANDMADE_INTERNAL
~~~~~~~ C++ add
// TODO(casey): Note, current is wrong on the zero'th index
~~~~~~~ C++
Win32DebugSyncDisplay(&GlobalBackbuffer,
                        ArrayCount(DebugTimeMarkers), DebugTimeMarkers,
~~~~~~~ C++ add
                        DebugTimeMarkerIndex - 1,
~~~~~~~ C++
                        &SoundOutput, TargetSecondsPerFrame);
#endif
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Passing current marker index.]

## Record More Values

~~~~~~~ C++
struct win32_debug_time_marker
{
~~~~~~~ C++ add
    DWORD OutputPlayCursor;
    DWORD OutputWriteCursor;
    DWORD OutputLocation; 
    DWORD OutputByteCount;
    
~~~~~~~ C++ edit
    DWORD FlipPlayCursor;
    DWORD FlipWriteCursor;
~~~~~~~ C++
};
~~~~~~~
[Listing [x]: <file>[win32_handmade.h]</file> Updating old values and adding some new ones.]

~~~~~~~ C++
#if HANDMADE_INTERNAL
// NOTE(casey): This is debug code
{
    DWORD FlipPlayCursor = 0;
    DWORD FlipWriteCursor= 0;
    if (SUCCEEDED(GlobalSecondaryBuffer->GetCurrentPosition(&FlipPlayCursor, &FlipWriteCursor)))
    {
        Assert(DebugTimeMarkerIndex < ArrayCount(DebugTimeMarkers));
~~~~~~~ C++ edit
        win32_debug_time_marker *Marker = &DebugTimeMarkers[DebugTimeMarkerIndex];
~~~~~~~ C++ delete
        if (DebugTimeMarkerIndex == ArrayCount(DebugTimeMarkers))
        {
            DebugTimeMarkerIndex = 0;
        }
~~~~~~~ C++ edit
        Marker->FlipPlayCursor = FlipPlayCursor;
        Marker->FlipWriteCursor = FlipWriteCursor;
~~~~~~~ C++
    }
}
#endif

// ... 

#if 0
// debug timing output
// ...
#endif

~~~~~~~ C++ add
#if HANDMADE_INTERNAL
++DebugTimeMarkerIndex;
if (DebugTimeMarkerIndex == ArrayCount(DebugTimeMarkers))
{
    DebugTimeMarkerIndex = 0;
}
#endif
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Making sure time marker index is only updated once per frame.]


~~~~~~~ C++
GameGetSoundSamples(&GameMemory, &SoundBuffer);
                        
Win32FillSoundBuffer(&SoundOutput, ByteToLock, BytesToWrite, &SoundBuffer);

#if HANDMADE_INTERNAL
~~~~~~~ C++ add
win32_debug_time_marker *Marker = &DebugTimeMarkers[DebugTimeMarkerIndex];
Marker->OutputPlayCursor = PlayCursor;
Marker->OutputWriteCursor = WriteCursor;
Marker->OutputLocation = ByteToLock;
Marker->OutputByteCount = BytesToWrite;
~~~~~~~ C++

//... 
OutputDebugStringA(TextBuffer);
#endif
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Recording output markers.]

Finally, we need to update the correct struct members inside `Win32DebugSyncDisplay`: 

~~~~~~~ C++
win32_debug_time_marker *ThisMarker = &Markers[MarkerIndex];
~~~~~~~ C++
Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom,             
~~~~~~~ C++ edit
                           ThisMarker->FlipPlayCursor, PlayColor);
~~~~~~~ C++
Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom, 
~~~~~~~ C++ edit
                           ThisMarker->FlipWriteCursor, WriteColor);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > Win32DebugSyncDisplay]</file> Making us compilable.]

So far, we're recording the new values but we don't display them. You can compile and test it out: now changes yet. Let's add the newly recorded values to our debug display.

~~~~~~~ C++ add
win32_debug_time_marker *ThisMarker = &Markers[MarkerIndex];
~~~~~~~ C++

DWORD PlayColor = 0xFFFFFFFF;
DWORD WriteColor = 0xFFFF0000;

int Top = PadY;
int Bottom = PadY + LineHeight;

if (MarkerIndex == CurrentMarkerIndex)
{
    Top += LineHeight + PadY;
    Bottom += LineHeight + PadY;
    
~~~~~~~ C++ add
    Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom, 
                               ThisMarker->OutputPlayCursor, PlayColor);
    Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom, 
                               ThisMarker->OutputWriteCursor, WriteColor);
    Top += LineHeight + PadY;
    Bottom += LineHeight + PadY;
    Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom, 
                               ThisMarker->OutputLocation, PlayColor);
    Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom,       
                               ThisMarker->OutputLocation + ThisMarker->OutputByteCount, WriteColor);
    Top += LineHeight + PadY;
    Bottom += LineHeight + PadY;
~~~~~~~ C++
}
~~~~~~~ C++ delete
win32_debug_time_marker *ThisMarker = &Markers[MarkerIndex];
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > Win32DebugSyncDisplay]</file> Displaying new values (only on the current cursor).]

~~~~~~~ C++
internal void
Win32DebugDrawVertical(win32_offscreen_buffer *Backbuffer,
                       int X, int Top, int Bottom, u32 Color)
{
~~~~~~~ C++ add
    if (Top <= 0)
    {
        Top = 0;
    }
    
    if (Bottom > Backbuffer->Height)
    {
        Bottom = Backbuffer->Height;
    }
    
    if ((X >= 0) && (X < Backbuffer->Width))
    {
~~~~~~~ C++
        u8 *Pixel = (u8 *)Backbuffer->Memory +
            X * Backbuffer->BytesPerPixel +
            Top * Backbuffer->Pitch;
        for (int Y = Top;
            Y < Bottom;
            ++Y)
        {
            *(u32 *)Pixel = Color;
            Pixel += Backbuffer->Pitch;
        }
~~~~~~~ C++ add
    }
~~~~~~~ C++
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp]</file> Making sure we never go out of bounds.]

~~~~~~~ C++
inline void
Win32DrawSoundBufferMarker(...)
{
~~~~~~~ C++ delete
    Assert (Value < SoundOutput->SecondaryBufferSize);
~~~~~~~ C++
    f32 XReal = C * (f32)Value;
    int X = PadX + (int)XReal;
    
    Win32DebugDrawVertical(Backbuffer, X, Top, Bottom, Color);
}

internal void
Win32DebugSyncDisplay(...)
{
    int PadX = 16;
    int PadY = 16;
    
    int LineHeight = 64;
    
    f32 C = (f32)(Backbuffer->Width - 2 * PadX) / (f32)SoundOutput->SecondaryBufferSize;
    for (int MarkerIndex = 0;
         MarkerIndex < MarkerCount;
         ++MarkerIndex)
    {
        win32_debug_time_marker *ThisMarker = &Markers[MarkerIndex];
        
~~~~~~~ C++ add
        Assert(ThisMarker->OutputPlayCursor < SoundOutput->SecondaryBufferSize);
        Assert(ThisMarker->OutputWriteCursor < SoundOutput->SecondaryBufferSize);
        Assert(ThisMarker->OutputLocation < SoundOutput->SecondaryBufferSize);
        Assert(ThisMarker->OutputByteCount < SoundOutput->SecondaryBufferSize);
        Assert(ThisMarker->FlipPlayCursor < SoundOutput->SecondaryBufferSize);
        Assert(ThisMarker->FlipWriteCursor < SoundOutput->SecondaryBufferSize);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp]</file> Fixing the assertions.]
 
## Add Global Pause Key And Inspect Values

~~~~~~~ C++
global_variable b32 GlobalRunning;
~~~~~~~ C++ add
global_variable b32 GlobalPause;
~~~~~~~ C++
global_variable win32_offscreen_buffer GlobalBackbuffer;
global_variable IDirectSoundBuffer *GlobalSecondaryBuffer;
global_variable s64 GlobalPerfCountFrequency;
~~~~~~~


~~~~~~~ C++
else if (VKCode == VK_BACK)
{
    Win32ProcessKeyboardMessages(&KeyboardController->Back, IsDown);
}
~~~~~~~ C++ add
#if HANDMADE_INTERNAL
else if (VKCode == 'P')
{
    if (IsDown)
    {
        GlobalPause = !GlobalPause;
    }
}
#endif

b32 AltKeyWasDown = ((Message.lParam & (1 << 29)) != 0);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > Win32ProcessPendingMessages]</file> Adding Global Pause Hotkey.]

~~~~~~~ C++
Win32ProcessPendingMessages(NewKeyboardController);
~~~~~~~ C++ add
if (!GlobalPause)
{
~~~~~~~ C++
    DWORD MaxControllerCount = XUSER_MAX_COUNT;
    if(MaxControllerCount > (ArrayCount(NewInput->Controllers) - 1))
    {
        MaxControllerCount = (ArrayCount(NewInput->Controllers) - 1);
    }
    // ...
    // All of the game update
    // ...
    
#if HANDMADE_INTERNAL
    ++DebugTimeMarkerIndex;
    if (DebugTimeMarkerIndex == ArrayCount(DebugTimeMarkers))
    {
        DebugTimeMarkerIndex = 0;
    }
#endif
~~~~~~~ C++ add
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Implementing Global Pause.]

## Display Expected Frame Flip Time

We want to see if our estimate lines up at all

~~~~~~~ C++
struct win32_debug_time_marker
{
    DWORD OutputPlayCursor;
    DWORD OutputWriteCursor;
    DWORD OutputLocation;
    DWORD OutputByteCount;
~~~~~~~ C++ add
    DWORD ExpectedFlipPlayCursor;
~~~~~~~ C++
    
    DWORD FlipPlayCursor;
    DWORD FlipWriteCursor;
};
~~~~~~~
[Listing [x]: <file>[win32_handmade.h]</file> Expanding `win32_debug_time_marker`.]

~~~~~~~ C++
win32_debug_time_marker *Marker = &DebugTimeMarkers[DebugTimeMarkerIndex];
Marker->OutputPlayCursor = PlayCursor;
Marker->OutputWriteCursor = WriteCursor;
Marker->OutputLocation = ByteToLock;
Marker->OutputByteCount = BytesToWrite;
~~~~~~~ C++ add
Marker->ExpectedFlipPlayCursor = ExpectedFrameBoundaryByte;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Recording calculated frame flip cursor.]

~~~~~~~ C++
DWORD PlayColor = 0xFFFFFFFF;         // White
DWORD WriteColor = 0xFFFF0000;        // Red
~~~~~~~ C++ add
DWORD ExpectedFlipColor = 0xFFFFFF00; // Yellow
~~~~~~~ C++

int Top = PadY;
int Bottom = PadY + LineHeight;

if (MarkerIndex == CurrentMarkerIndex)
{
    Top += LineHeight + PadY;
    Bottom += LineHeight + PadY;
    
    Win32DrawSoundBufferMarker(..., ThisMarker->OutputPlayCursor, PlayColor);
    Win32DrawSoundBufferMarker(..., ThisMarker->OutputWriteCursor, WriteColor);
    
    Top += LineHeight + PadY;
    Bottom += LineHeight + PadY;
    
    Win32DrawSoundBufferMarker(..., ThisMarker->OutputLocation, PlayColor);
    Win32DrawSoundBufferMarker(..., ThisMarker->OutputLocation + ThisMarker->OutputByteCount, WriteColor);
    
    Top += LineHeight + PadY;
    Bottom += LineHeight + PadY;
    
~~~~~~~ C++ add
    Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, PadY, Bottom, 
                               ThisMarker->ExpectedFlipPlayCursor, ExpectedFlipColor);
~~~~~~~ C++
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > Win32DebugSyncDisplay]</file> Displaying flip play cursor.]


However, upon giving a closer look at `ExpectedFrameBoundaryByte`, we can see that the computation is wrong:

~~~~~~~~ C++
DWORD ExpectedFrameBoundaryByte = PlayCursor + ExpectedSoundBytesPerFrame;
~~~~~~~~

That's not what we set out to do! This doesn't take into account whatever amount of time has already elapsed since the frame started. Let's fix this. 

~~~~~~~ C++
// Before the main loop
b32 SoundIsValid = false;

LARGE_INTEGER LastCounter = Win32GetWallClock();
~~~~~~~ C++ add
LARGE_INTEGER FlipWallClock = Win32GetWallClock();
~~~~~~~ C++

u64 LastCycleCount = __rdtsc();
GlobalRunning = true;
win32_window_dimension Dimension = Win32GetWindowDimension(Window);

// ... 
// At the end of the main loop
// ... 

#if HANDMADE_INTERNAL
Win32DebugSyncDisplay(...);
#endif
Win32DisplayBufferInWindow(...);

~~~~~~~ C++ add
FlipWallClock = Win32GetWallClock();
~~~~~~~ C++

#if HANDMADE_INTERNAL
// More debug code
// ... 
#endif
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Getting the actual frame flip timing.]

~~~~~~~ C++
GameUpdateAndRender(&GameMemory, NewInput, &Buffer);
                        
~~~~~~~ C++ add
LARGE_INTEGER AudioWallClock = Win32GetWallClock();
f32 FromBeginToAudioSeconds = Win32GetSecondsElapsed(FlipWallClock, AudioWallClock);
~~~~~~~ C++

DWORD PlayCursor;
DWORD WriteCursor;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Calculating correct frame boundary byte.]

## Display Play Window

~~~~~~~ C++
DWORD PlayColor = 0xFFFFFFFF;
DWORD WriteColor = 0xFFFF0000;
DWORD ExpectedFlipColor = 0xFFFFFF00;
~~~~~~~ C++ add
DWORD PlayWindowColor = 0xFFFF00FF;
~~~~~~~ C++

int Top = PadY;
int Bottom = PadY + LineHeight;

if (MarkerIndex == CurrentMarkerIndex)
{
    // ...
}

Win32DrawSoundBufferMarker(..., ThisMarker->FlipPlayCursor, PlayColor);
~~~~~~~ C++ add
Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom, 
                           ThisMarker->FlipPlayCursor + (480 * SoundOutput->BytesPerSample), 
                           PlayWindowColor);
~~~~~~~ C++
Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom, ThisMarker->FlipWriteCursor, WriteColor);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > Win32DebugSyncDisplay]</file> Calculating play window.]

# Recap 

Audio is tough, and it's hard to find topics harder than this in programming. However, if you got this far, congratulations! From here on it should be a breeze. 

# Exercises 

# Side Considerations

## Bugfix: Sound Changing Pitch

~~~~~~~ C++
f32 SineValue = sinf(tSine);
s16 SampleValue = (s16)(SineValue * ToneVolume);

*SampleOut++ = SampleValue;
*SampleOut++ = SampleValue;
tSine += 2.0f * Pi32 * 1.0f / (f32)WavePeriod;

~~~~~~~ C++ add
if (tSine > 2.0f * Pi32)
{
    tSine -= 2.0f * Pi32;
}
~~~~~~~
[Listing [x]: <file>[handmade.cpp > GameSoundOutput]</file> Normalizing `tSine`.]

# Navigation 

Previous: [Day 19. Improving Audio Synchronization][day 19]

Up Next: [Day 21. Loading Game Code Dynamically][day 21]

[Back to Index](../index.md.html)

(#) Glossary 

(insert glossary/glossary_day20.md.html here)

(insert references/refs_day20.md.html here) 

(insert links.md.html here)

<style class="fallback">
  body {
    visibility: hidden;
    font-family: sans-serif;
  }
</style>
<!-- Markdeep: https://casual-effects.com/markdeep/ -->
<script>
  markdeepOptions = { tocStyle: 'long' };
  window.alreadyProcessedMarkdeep ||
    (document.body.style.visibility = 'visible');
</script>
<script src="../js/markdeep.min.js" charset="utf-8"></script>
