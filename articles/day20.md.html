<meta charset="utf-8" />
<link rel="stylesheet" href="../css/style.css" />

**Day 20. Debugging the Audio Sync** 
_Video Length (including Q&A): [2h46](https://hero.handmade.network/episode/code/day020/)_ 

(insert intro.md.html here) 

If you got this far, congratulations! Debugging sound issues may well be among the most tedious tasks one would face (unless that's exactly your cup of tea). However, we aren't out of the woods yet; the system we have in our hands is still quite latent, and there's room for improvement even at this early stage. The root of our concern is the following: sure, with the default sound API and the integrated sound module, audio is laggy. But what if someone is an audio junkie and has a powerful sound card with zero latency? We want to support them as well! And today we need to think real hard to make it happen.

You might have noticed a trend throughout this series: we think first, and type after. If you understand at least on assumption level the code that you're writing, it will be much easier for you to, first, translate your thoughts into good code and, later, actually be able to read and edit it. That said, you never want to go too deep down the rabbit hole and define every single scrupulous detail: at that point, you might as well write the code directly! Leave yourself some space for a good surprise.

# Deep Dive into the Issue

## Define the Problem

Let's go back into our favorite timeline. 

***************************************************************
*                     Next Frame Preparation                  *
*                (User Input processing, World update,        *
*                Graphics rendering and writing Audio)        *
*                      /     |      |     \                   *
*                   .-+.   .-+.   .-+.   .-+.                 *
*                  |    | |    | |    | |    |                *
* |               |      |      |      |      |          time *
* +---------------+------+------+------+-....-+------+---->   *
* |               |      |      |      |      |      |        *
*                 0      1      2     ...     N               *
* ^               ^      ^      ^      ^      ^      ^        *
* |               |       \      \     |     /       |        *
* |               |        \      \    |    /        |        *
* game           first    Next frame is displayed    game     *
* starts         frame          "frame flip"         exits    *
* running        is displayed                                 *
*                                                             *
***************************************************************
[Figure [x]: Game lifetime. Everything on it should be familiar to you by now.]

We have decided to aim at 30 frames per second for the time being. This means that every second (or every 1000 milliseconds) we aim to output 30 frames. Thus, each frame only has $\frac{1000}{30} \approx 33.3$ milliseconds to do all the work. 

Each frame we do the work to display the image and the sound of our next frame. In an ideal world, both would go out at the same time: at the magical moment in time that we call "frame flip". 

***************************************************************
*               .---. image is                                *
*               | ðŸ•º | displayed                               *
*               '---'                                         *
*                audio is played                              *
*               +~~~~~~~~~~~~~                                *
* |   frame 0   |   frame 1   |   frame 2   |   ...      time *
* +---+---------+-------------+-------------+------------->   *
* |   ^         ^                                             *
*     |         |                                             *
*     +--------'                                              *
*     |         Frame                                         *
*    Work       Flip                                          *
*   starts                                                    *
*                                                             *
*                                                             *
***************************************************************
[Figure [x]: Frame flip workflow in an ideal world.]

This work happens some time after the frame begins: before we get started on rendering, we need to collect the user input update our world state, and maybe do some additional preparations as necessary. Even further still, we're currently writing audio just before the frame flip, at the last possible moment in fact. The idea being that the moment we send something to the hardware, it will be reproduced to the user.

*******************************************************************
*                                                                 *
*        Update game world                                        *
*        Prepare for render                        wait           *
*              |                                    |             *
*           .--+---.                           .----+---.         *
*    |     |        |                         |          | repeat *
* ---+-----+--------+-------------------------+----------+-->     *
*    |     |        |                         |          ^        *
*     '-+-'          '-----------+-----------'           |        *
*       |                        |                   frame flip   *
*   gather input               Render                             *
* (keyboard, mouse,                                               *
*     gamepad)                                                    *
*                                                                 *
*******************************************************************
[Figure [x]: Breakdown of the work within a single frame. Proportions of game update/render times will differ. Of course, some of these tasks may run in parallel in the future.]

Unfortunately for us, hardware lag exists. Furthermore, DirectSound (on our specific machine) is not cooperating with us. The API has a delay on the order of 30-33ms! That's in fact a full frame of ours! So this is what happens with our frames in practice: 

***************************************************************
*               .---. image is                                *
*               | ðŸ•º | displayed                               *
*               '---'                                         *
*               |            audio is played                  *
*               |           +~~~~~~~~~~~~~                    *
* |   frame 0   |  frame 1  | |   frame 2   |   ...      time *
* +---+---------+-----------+-+-------------+------------->   *
* |   ^       ^ |             |             |                 *
*     |       | ^                                             *
*     |       |  \                                            *
*    Work     |   '----expected                               *
*   starts    |       frame flip                              *
*             |                                               *
*           Send work to                                      *
*           the hardware                                      *
*                                                             *
***************************************************************
[Figure [x]: Frame flip workflow in our reality.]

As you can see, by the time audio starts playing, it's almost time for the next frame to flip! And, when we blindly assumed low latency scenario, this is what created the audible clicks for us: information kept getting overwritten from under the Play Cursor.

If we want to avoid latency, we'd ideally have to send audio data before our rendering work on a frame even starts! This isn't necessarily impossible but would introduce frame lag anyway, since the new user input and world state wouldn't be accounted in the old sound... On surface this seems like an exercise in chasing one's own tail.

## Evaluate the Options

At the end of the day, under the current system there's no way to compute sound for a frame and have it reproduced together with its image. This leaves us with the following options: 

* Accept the reality that our audio will always be a couple frames behind the image. After all, so many games already do this! This would simply regress our audio to be latent by design.
* Have a "low latency mode" which would take over on a machine with a great sound card and low latency; do things the slow way otherwise. 
* Continue tinkering on the inner workings of our platform layer.
* Fix latency issues by essentially getting input and world state a frame before. This would introduce input lag, which seems like a worse tradeoff in an action game like ours. 

The input lag option in our particular case seems like the worst of all, so we can rule it out right away. In fact, we want to push the input capture as close to the frame flip as possible, so that the user doesn't get a feeling of an unresponsive game.

## Draft an Action Plan

Let's start with the simplest solution we might imagine. We write our sound to the hardware as soon as we have it, without waiting for frame flip. So if, for instance, audio is sent out 15ms after the frame starts, it will be reproduced ~15ms after the frame flip happened. 

The game won't know of this happening: platform will lie to the game saying that the audio will be reproduced at the frame flip. 

***************************************************************
*               .---. image is                                *
*               | ðŸ•º | displayed                               *
*               '---'                                         *
*               |       audio is played                       *
*               |      +~~~~~~~~~~~~~                         *
* |             |      |      |             |   ...      time *
* +------+------+------+------+-------------+------------->   *
* |      ^      |             |             |                 *
*        |      ^                                             *
*        |      |                                             *
* Calculate and |                                             *
* send audio    |                                             *
*               |                                             *
*           frame flip                                        *
*                                                             *
***************************************************************
[Figure [x]: Sending the audio out as soon as it's ready.]

!!! Trivia 
    Unfortunately, this kind of unsynchronized audio loop is common in the industry. It's a bit sloppy but better than the alternative of pushing audio to the next frame and have a whole frame of buffering instead of roughly a half. 

This solution also opens the road for the "low latency mode" we proposed above. If we determine that we're playing on the extremely performant hardware, the sound will be target the frame flip instead of whenever it's ready.

// FIXME: Undocumented code edits start

~~~~~~~ C++ delete
#define FramesOfAudioLatency 3
~~~~~~~ C++
    // TODO(casey): How do we reliably query on monitor refresh rate on Windows?
#define MonitorRefreshHz 60
#define GameUpdateHz (MonitorRefreshHz / 2)

// ... 

// NOTE(casey): Sound test
win32_sound_output SoundOutput = {};
SoundOutput.SamplesPerSecond = 48000;
SoundOutput.BytesPerSample = sizeof(s16) * 2;
SoundOutput.SecondaryBufferSize = 2 * SoundOutput.SamplesPerSecond * SoundOutput.BytesPerSample;
SoundOutput.RunningSampleIndex = 0;
~~~~~~~ C++ add
// TODO(casey): Get rid of LatencySampleCount
~~~~~~~ C++ edit
SoundOutput.LatencySampleCount = 3 *(SoundOutput.SamplesPerSecond / GameUpdateHz);           
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> .]

This is a circular buffer so we need to account for when the write cursor is in front.

~~~~~~~ C++
#if HANDMADE_INTERNAL
DWORD PlayCursor;
DWORD WriteCursor;
GlobalSecondaryBuffer->GetCurrentPosition(&PlayCursor, &WriteCursor);

~~~~~~~ C++ add
DWORD UnwrappedWriteCursor = WriteCursor;
if (UnwrappedWriteCursor < PlayCursor)
{
    UnwrappedWriteCursor += SoundOutput.SecondaryBufferSize;
}
DWORD AudioLatencyBytes = UnwrappedWriteCursor - PlayCursor;
~~~~~~~ C++

char TextBuffer[256];
~~~~~~~ C++ edit
sprintf_s(TextBuffer, sizeof(TextBuffer), "LPC:%u BTL:%u TC:%u BTW:%u - PC:%u WC:%u DELTA:%u\n",
            LastPlayCursor, ByteToLock, TargetCursor, BytesToWrite,
            PlayCursor, WriteCursor, AudioLatencyBytes);
~~~~~~~ C++
OutputDebugStringA(TextBuffer);
#endif
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> .]

DELTA is nice and stable at 5760, and circular buffer hack works well. 

~~~~~~~ C++
DWORD UnwrappedWriteCursor = WriteCursor;
if (UnwrappedWriteCursor < PlayCursor)
{
    UnwrappedWriteCursor += SoundOutput.SecondaryBufferSize;
}
DWORD AudioLatencyBytes = UnwrappedWriteCursor - PlayCursor;
~~~~~~~ C++ add
f32 AudioLatencySeconds = ((f32)AudioLatencyBytes / (f32)SoundOutput.BytesPerSample) / 
                           (f32)SoundOutput.SamplesPerSecond;
~~~~~~~ C++
char TextBuffer[256];
~~~~~~~ C++ edit
sprintf_s(TextBuffer, sizeof(TextBuffer), "LPC:%u BTL:%u TC:%u BTW:%u - PC:%u WC:%u DELTA:%u (%fs)\n",
            LastPlayCursor, ByteToLock, TargetCursor, BytesToWrite,
            PlayCursor, WriteCursor, AudioLatencyBytes, AudioLatencySeconds);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> .]

Note about printf values. `%.2f` makes it so it's only 2 decimal points.

Dimensional analysis aside: Bytes * (Sample / Bytes) * (Seconds / Samples). Simple to work out in the head but also can use the trick on paper if necessary. In fact, let's place a todo to simplify similar calculations in the future.

~~~~~~~ C++
struct win32_sound_output
{
    int SamplesPerSecond;
    int BytesPerSample;
    DWORD SecondaryBufferSize;
    u32 RunningSampleIndex;
    int LatencySampleCount;
~~~~~~~ C++ add
    // TODO(casey): Math get simpler if we add a "bytes per second" field? 
~~~~~~~ C++
};
~~~~~~~
[Listing [x]: <file>[win32_handmade.h]</file> .]

Now, pull them out from the game loop, these are useful values that we want to keep track of between frames.

~~~~~~~ C++
// ... 
// Just before the main loop
// ... 

int DebugTimeMarkerIndex = 0;
win32_debug_time_marker DebugTimeMarkers[GameUpdateHz / 2] = {};

DWORD LastPlayCursor = 0;
b32 SoundIsValid = false;
~~~~~~~ C++ add
DWORD AudioLatencyBytes = 0;
f32 AudioLatencySeconds = 0;
~~~~~~~ C++

LARGE_INTEGER LastCounter = Win32GetWallClock();
u64 LastCycleCount = __rdtsc();
GlobalRunning = true;

// ... 
// Most of the main loop
// ... 

DWORD UnwrappedWriteCursor = WriteCursor;
if (UnwrappedWriteCursor < PlayCursor)
{
    UnwrappedWriteCursor += SoundOutput.SecondaryBufferSize;
}
~~~~~~~ C++ edit
AudioLatencyBytes = UnwrappedWriteCursor - PlayCursor;
AudioLatencySeconds = ((f32)AudioLatencyBytes / (f32)SoundOutput.BytesPerSample) / 
                           (f32)SoundOutput.SamplesPerSecond;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> .]

Having values gather around like this is a good indication that we're going to start gathering them together and we might do that soon, just not yet. It's better to wait until you're completely happy with how something works until you start gathering things together and pulling them out, otherwise you will fall in a lot of additional typing. Don't be too horrible! 

## Review target bytes calculation

We set our `ByteToLock` to be whatever our `RunningSampleIndex` was. We then calculate target cursor which takes into account latency. Now we want to finally start tracking the DirectSound's write cursor. up until now we were ignoring it.

~~~~~~~ C++
DWORD LastPlayCursor = 0;
~~~~~~~ C++ add
DWORD LastWriteCursor = 0;
~~~~~~~ C++
b32 SoundIsValid = false;
DWORD AudioLatencyBytes = 0;
f32 AudioLatencySeconds = 0;

// ... 
// Towards the end of the main loop
// ... 

DWORD PlayCursor = 0;
DWORD WriteCursor= 0;
if (SUCCEEDED(GlobalSecondaryBuffer->GetCurrentPosition(&PlayCursor, &WriteCursor)))
{
    LastPlayCursor = PlayCursor;
~~~~~~~ C++ add
    LastWriteCursor = WriteCursor;
~~~~~~~ C++
    if (!SoundIsValid)
    {
        SoundOutput.RunningSampleIndex = WriteCursor / SoundOutput.BytesPerSample;
        SoundIsValid = true;
    }
}
else
{
    SoundIsValid = false;
}

~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> .]

*****************************************************************************
*                                                                           *
*              Set TargetCursor                                             *
*             to the end of frame         Set TargetCursor                  *
*                    .-----.                 .-----.                        *
*                   |       |               |       |                       *
*    |              |       v|              |       v|                      *
*    +------+-------+--------+------+-------+--------+------------->        *
*    |      ^       ^        |      ^       ^        |                      *
*    .---.  |       |        .---.  |       |        .---.                  *
*    | ðŸ•º |  |       |        | ðŸ•º |  |       |        | ðŸ•º |                  *
*    '---'  |       |        '---'  |       |        '---'                  *
*     Ask where the |        |      |       |        |                      *
*      DirectSound  |        |   Wake up    |        |      ...             *
*      cursors are  |        |   and ask    |        |                      *
*        |          |        |    |         |        |                      *
*        +-->  WriteCursor   |    +-->  WriteCursor  |                      *
*      PlayCursor            |  PlayCursor           |                      *
*                            +~~~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~   *
*                            audio is playing for exactly one frame         *
*                            rinse and repeat for infinite sound            *
*                                                                           *
*****************************************************************************
[Figure [x]: Low latency path idea. ðŸ•º represents frame flips.]

Need to adjust by however much the clock consumes, so need to calculate _average_ wc movement instead of going straight to the end of frame.

If inside frame WC then always write average WC motion amount

*****************************************************************************
*                                                                           *
*                     Set TargetCursor to be slightly further ahead         *
*                                from the WriteCursor                       *
*                     (just a safety margin, don't wait until flip)         *
*                                      .-----.                              *
*                                     |       |                             *
*    |                                |       v      |                      *
*    +------+----------------+--------+--------------+------------->        *
*    |      ^                |        ^       |      |                      *
*    .---.  |                .---.    |       |      .---.                  *
*    | ðŸ•º |  |                | ðŸ•º |    |       |      | ðŸ•º |                  *
*    '---'  |                '---'    |       |      '---'                  *
*     Ask where the                   |       |                             *
*      DirectSound                    |       |                             *
*      cursors are                    |       |                             *
*        |                            |       |                             *
*        +-------------------->  WriteCursor  |                             *
*     PlayCursor                              |                             *
*                                             +~~~~~~~~~~~~~~~~~~~          *
*                            audio is still playing for exactly one frame   *
*                             but it's scheduled one frame in advance       *
*                                                                           *
*****************************************************************************
[Figure [x]: High latency path.]

~~~~~~~ C++ add
/* NOTE(casey):

   Here is how sound output computation works.

   We define a safety value that is the number 
   of samples we think our game update loop 
   may vary by (let's say up to 2ms). 

   When we wake up to write audio, we will look
   and see what the play cursor position is and we
   will forecast ahead where we think the
   play cursor will be on the next frame boundary.

   We will then look to see if the write cursor is
   before that by at least our safety value. If it is, the
   target fill position is that frame boundary
   plus one frame. This gives us us perfect audio
   sync in the case of a card that has low enough
   latency.

   If the write cursor is _after_ that safety 
   margin, then we assume we can never sync the
   audio perfectly, so we will write one frame's
   worth of audio plus the safety margin's worth
   of guard samples.
*/
~~~~~~~ C++
DWORD ByteToLock = 0;
DWORD TargetCursor = 0;
DWORD BytesToWrite = 0;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> .]


~~~~~~~ C++
int DebugTimeMarkerIndex = 0;
win32_debug_time_marker DebugTimeMarkers[GameUpdateHz / 2] = {};

~~~~~~~ C++ delete
DWORD LastPlayCursor = 0;
DWORD LastWriteCursor = 0;
~~~~~~~ C++
b32 SoundIsValid = false;
DWORD AudioLatencyBytes = 0;
f32 AudioLatencySeconds = 0;

// ... 
// Towards the end of WinMain
// ... 

DWORD PlayCursor = 0;
DWORD WriteCursor= 0;
if (SUCCEEDED(GlobalSecondaryBuffer->GetCurrentPosition(&PlayCursor, &WriteCursor)))
{
~~~~~~~ C++ delete
    LastPlayCursor = PlayCursor;
    LastWriteCursor = WriteCursor;
~~~~~~~ C++
    if (!SoundIsValid)
    {
        SoundOutput.RunningSampleIndex = WriteCursor / SoundOutput.BytesPerSample;
        SoundIsValid = true;
    }
}

//... 
~~~~~~~ C++
AudioLatencySeconds = ((f32)AudioLatencyBytes / (f32)SoundOutput.BytesPerSample) /
                            (f32)SoundOutput.SamplesPerSecond;
char TextBuffer[256];
~~~~~~~ C++ edit
sprintf_s(TextBuffer, sizeof(TextBuffer), "BTL:%u TC:%u BTW:%u - PC:%u WC:%u DELTA:%u (%.2fs)\n",
            ByteToLock, TargetCursor, BytesToWrite,
            PlayCursor, WriteCursor, AudioLatencyBytes, AudioLatencySeconds);
~~~~~~~ C++
OutputDebugStringA(TextBuffer);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> .]


~~~~~~~ C++ delete
DWORD PlayCursor = 0;
DWORD WriteCursor= 0;
if (SUCCEEDED(GlobalSecondaryBuffer->GetCurrentPosition(&PlayCursor, &WriteCursor)))
{
    LastPlayCursor = PlayCursor;
    LastWriteCursor = WriteCursor;
    if (!SoundIsValid)
    {
        SoundOutput.RunningSampleIndex = WriteCursor / SoundOutput.BytesPerSample;
        SoundIsValid = true;
    }
}
else
{
    SoundIsValid = false;
}
~~~~~~~ C++
#if HANDMADE_INTERNAL
// NOTE(casey): This is debug code
{
~~~~~~~ C++ add
    DWORD FlipPlayCursor = 0;
    DWORD FlipWriteCursor= 0;
    if (SUCCEEDED(GlobalSecondaryBuffer->GetCurrentPosition(&FlipPlayCursor, &FlipWriteCursor)))
    {
~~~~~~~ C++
        Assert(DebugTimeMarkerIndex < ArrayCount(DebugTimeMarkers));
        win32_debug_time_marker *Marker = &DebugTimeMarkers[DebugTimeMarkerIndex++];
        if (DebugTimeMarkerIndex == ArrayCount(DebugTimeMarkers))
        {
            DebugTimeMarkerIndex = 0;
        }
~~~~~~~ C++ edit
        Marker->PlayCursor = FlipPlayCursor;
        Marker->WriteCursor = FlipWriteCursor;
~~~~~~~ C++ add
    }
~~~~~~~ C++
}
#endif
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> .]

~~~~~~~ C++ delete
DWORD ByteToLock = 0;
DWORD TargetCursor = 0;
DWORD BytesToWrite = 0;

if (SoundIsValid)
{
    ByteToLock = ((SoundOutput.RunningSampleIndex * SoundOutput.BytesPerSample)
                    % SoundOutput.SecondaryBufferSize);
    
    TargetCursor = ((LastPlayCursor +
                        (SoundOutput.LatencySampleCount * SoundOutput.BytesPerSample))
                    % SoundOutput.SecondaryBufferSize);
    
    if(ByteToLock > TargetCursor)
    {
        BytesToWrite = SoundOutput.SecondaryBufferSize - ByteToLock;
        BytesToWrite += TargetCursor;
    }
    else
    {
        BytesToWrite = TargetCursor - ByteToLock;
    }
}
~~~~~~~ C++

game_sound_output_buffer SoundBuffer = {};
SoundBuffer.SamplesPerSecond = SoundOutput.SamplesPerSecond;
SoundBuffer.SampleCount = BytesToWrite / SoundOutput.BytesPerSample;
SoundBuffer.Samples = Samples;

game_offscreen_buffer Buffer = {};
Buffer.Memory = GlobalBackbuffer.Memory;
Buffer.Width = GlobalBackbuffer.Width;
Buffer.Height = GlobalBackbuffer.Height;
Buffer.Pitch = GlobalBackbuffer.Pitch;

GameUpdateAndRender(&GameMemory, NewInput, &Buffer, &SoundBuffer);

~~~~~~~ C++ add
DWORD PlayCursor;
DWORD WriteCursor;
if (GlobalSecondaryBuffer->GetCurrentPosition(&PlayCursor, &WriteCursor) == DS_OK)
{
    if (!SoundIsValid)
    {
        SoundOutput.RunningSampleIndex = WriteCursor / SoundOutput.BytesPerSample;
        SoundIsValid = true;
    }

    
    DWORD ByteToLock = ((SoundOutput.RunningSampleIndex * SoundOutput.BytesPerSample)
                        % SoundOutput.SecondaryBufferSize);
        
    DWORD TargetCursor = 0;
    TargetCursor = ((LastPlayCursor +
                        (SoundOutput.LatencySampleCount * SoundOutput.BytesPerSample))
                    % SoundOutput.SecondaryBufferSize);
    
    DWORD BytesToWrite = 0;
    if(ByteToLock > TargetCursor)
    {
        BytesToWrite = SoundOutput.SecondaryBufferSize - ByteToLock;
        BytesToWrite += TargetCursor;
    }
    else
    {
        BytesToWrite = TargetCursor - ByteToLock;
    }
~~~~~~~ C++ delete
if(SoundIsValid)
{
~~~~~~~ C++
    Win32FillSoundBuffer(&SoundOutput, ByteToLock, BytesToWrite, &SoundBuffer);

#if HANDMADE_INTERNAL
~~~~~~~ C++ delete
    DWORD PlayCursor;
    DWORD WriteCursor;
    GlobalSecondaryBuffer->GetCurrentPosition(&PlayCursor, &WriteCursor);
~~~~~~~ C++
    
    DWORD UnwrappedWriteCursor = WriteCursor;
    if (UnwrappedWriteCursor < PlayCursor)
    {
        UnwrappedWriteCursor += SoundOutput.SecondaryBufferSize;
    }
    AudioLatencyBytes = UnwrappedWriteCursor - PlayCursor;
    AudioLatencySeconds = ((f32)AudioLatencyBytes / (f32)SoundOutput.BytesPerSample) /
        (f32)SoundOutput.SamplesPerSecond;
    char TextBuffer[256];
    sprintf_s(TextBuffer, sizeof(TextBuffer), "LPC:%u BTL:%u TC:%u BTW:%u - PC:%u WC:%u DELTA:%u (%.2fs)\n",
                LastPlayCursor, ByteToLock, TargetCursor, BytesToWrite,
                PlayCursor, WriteCursor, AudioLatencyBytes, AudioLatencySeconds);
    OutputDebugStringA(TextBuffer);
#endif
}
~~~~~~~ C++ add
{
    // GetCurrentPosition didn't succeed
    SoundIsValid = false;
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Simplifying and combining audio blocks.]

~~~~~~~ C++
DWORD TargetCursor = 0;
~~~~~~~ C++ add
if (AudioCardIsLowLatency)
{
~~~~~~~ C++ edit
    TargetCursor = ExpectedFrameBoundaryByte + ExpectedSoundBytesPerFrame;
~~~~~~~ C++ add
}
else
{
    TargetCursor = WriteCursor + ExpectedSoundBytesPerFrame + SoundOutput.SafetyBytes;
}
TargetCursor = TargetCursor % SoundOutput.SecondaryBufferSize;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Preparing two cases for TargetCursor calculation.]

Now we just have to compute all those new values. Let's start with `AudioCardIsLowLatency`.

~~~~~~~ C++ add
b32 AudioCardIsLowLatency = false;
DWORD SafeWriteCursor = WriteCursor + SoundOutput.SafetyBytes;
if (SafeWriteCursor >= ExpectedFrameBoundaryByte)
{
    AudioCardIsLowLatency = false;
}
~~~~~~~ C++
DWORD TargetCursor = 0;
if (AudioCardIsLowLatency)
//...
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Determining if our sound card is latent.]

Or, in other words, 

~~~~~~~ C++ edit
DWORD SafeWriteCursor = WriteCursor + SoundOutput.SafetyBytes;
b32 AudioCardIsLowLatency = SafeWriteCursor < ExpectedFrameBoundaryByte;
~~~~~~~ C++

DWORD TargetCursor = 0;
if (AudioCardIsLowLatency)
//...
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> A more concise notation of the above.]

However, there's always the circular buffer issue that we need to take into account: if the write cursor is behind the play cursor, it means the buffer wrapped, and we need to "unwrap" the cursor as we've done before (simply add the sound buffer size to write cursor's value).

~~~~~~~ C++ edit
DWORD SafeWriteCursor = WriteCursor;
~~~~~~~ C++ add
if (SafeWriteCursor < PlayCursor)
{
    SafeWriteCursor += SoundOutput.SecondaryBufferSize;
}
Assert(SafeWriteCursor >= PlayCursor);
SafeWriteCursor += SoundOutput.SafetyBytes;
~~~~~~~ C++
b32 AudioCardIsLowLatency = SafeWriteCursor < ExpectedFrameBoundaryByte;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Normalizing write cursor.]

`ExpectedFrameBoundaryByte`: 

~~~~~~~ C++ add
DWORD ExpectedFrameBoundaryByte = PlayCursor + ExpectedSoundBytesPerFrame;
~~~~~~~ C++
DWORD SafeWriteCursor = WriteCursor + SoundOutput.SafetyBytes;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Calculating expected frame flip boundary.]

~~~~~~~ C++ add
DWORD ExpectedSoundBytesPerFrame = (SoundOutput.SamplesPerSecond * SoundOutput.BytesPerSample)
                            / GameUpdateHz ;

~~~~~~~ C++
DWORD ExpectedFrameBoundaryByte = PlayCursor + ExpectedSoundBytesPerFrame;
DWORD SafeWriteCursor = WriteCursor;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Calculating expected sound bytes per frame.]

~~~~~~~ C++ delete
// TODO(casey): Get rid of LatencySampleCount
SoundOutput.LatencySampleCount = 3 *(SoundOutput.SamplesPerSecond / GameUpdateHz);
~~~~~~~ C++ add
// TODO(casey): Actually compute this variance and see 
// what the lowest reasonable value is.
SoundOutput.SafetyBytes = (SoundOutput.SamplesPerSecond * SoundOutput.BytesPerSample) 
    / GameUpdateHz) / 3;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Calculating safety bytes.]

~~~~~~~ C++
struct win32_sound_output
{
    int SamplesPerSecond;
    int BytesPerSample;
    DWORD SecondaryBufferSize;
    u32 RunningSampleIndex;
~~~~~~~ C++ delete
    int LatencySampleCount;
~~~~~~~ C++ add
    DWORD SafetyBytes;
~~~~~~~ C++
    // TODO(casey): Math get simpler if we add a "bytes per second" field?
};
~~~~~~~
[Listing [x]: <file>[win32_handmade.h]</file> Updating `win32_sound_output` structure.]


Concern: GameUpdateAndRender happens after our cursor calculation happens, so we don't really know how long is our frame going to take, only an estimate. That's fine since we know the _expected_ time? 

Getting real audio sync is complicated. We need to sync two clocks - game clock and audio device clock. We also need to know how many bytes to ask from the game but in order to know that we need to prepare the samples... so it's getting a bit of a vicious cycle.

Solution: separate audio and game update and rendering!

~~~~~~~ C++
struct game_memory
{
    u64 PermanentStorageSize;
    void *PermanentStorage;
    u64 TransientStorageSize;
    void *TransientStorage;
    b32 IsInitialized;
};

~~~~~~~ C++ edit
internal void GameUpdateAndRender(game_memory *Memory, game_input *Input, game_offscreen_buffer* Buffer);
~~~~~~~ C++ add
internal void GetSoundSamples(game_memory *Memory, game_sound_output_buffer *SoundBuffer);
~~~~~~~
[Listing [x]: <file>[handmade.h]</file> Splitting sound update from the rest of the game update.]

~~~~~~~ C++ delete
game_sound_output_buffer SoundBuffer = {};
SoundBuffer.SamplesPerSecond = SoundOutput.SamplesPerSecond;
SoundBuffer.SampleCount = BytesToWrite / SoundOutput.BytesPerSample;
SoundBuffer.Samples = Samples;

~~~~~~~ C++

game_offscreen_buffer Buffer = {};
Buffer.Memory = GlobalBackbuffer.Memory;
Buffer.Width = GlobalBackbuffer.Width;
Buffer.Height = GlobalBackbuffer.Height;
Buffer.Pitch = GlobalBackbuffer.Pitch;

// ...

else
{
    BytesToWrite = TargetCursor - ByteToLock;
}

~~~~~~~ C++ add
game_sound_output_buffer SoundBuffer = {};
SoundBuffer.SamplesPerSecond = SoundOutput.SamplesPerSecond;
SoundBuffer.SampleCount = BytesToWrite / SoundOutput.BytesPerSample;
SoundBuffer.Samples = Samples;

GameGetSoundSamples(&GameMemory, &SoundBuffer);

~~~~~~~ C++
Win32FillSoundBuffer(&SoundOutput, ByteToLock, BytesToWrite, &SoundBuffer);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Using `GameGetSoundSamples`.]

~~~~~~~ C++
internal void
~~~~~~~ C++ edit
GameUpdateAndRender(game_memory* Memory, game_input *Input, game_offscreen_buffer* Buffer)
~~~~~~~ C++
{
    Assert((&Input->Controllers[0].Terminator - &Input->Controllers[0].Buttons[0]) ==
           (ArrayCount(Input->Controllers[0].Buttons)));
    Assert(sizeof(game_state) <= Memory->PermanentStorageSize);
    game_state *GameState = (game_state*)Memory;
    
    if(!Memory->IsInitialized)
    {
        debug_read_file_result FileData = DEBUGPlatformReadEntireFile(__FILE__);
        if (FileData.Contents)
        {
            DEBUGPlatformWriteEntireFile("test.out", FileData.ContentsSize, FileData.Contents);
            DEBUGPlatformFreeFileMemory(FileData.Contents);
        }
        
        GameState->XOffset = 0;
        GameState->YOffset = 0;
        GameState->ToneHz = 256;
        
        Memory->IsInitialized = true;
    }
    
    for (int ControllerIndex = 0;
         ControllerIndex < ArrayCount(Input->Controllers);
         ++ControllerIndex)
    {
        
        game_controller_input *Controller = GetController(Input, ControllerIndex);
        if (Controller->IsAnalog)
        {
            // NOTE(casey): Use analog movement tuning
            GameState->XOffset += (int)(4.0f * Controller->StickAverageX);
            GameState->ToneHz = 256 + (int)(128.0f * (Controller->StickAverageY));
        }
        else
        {
            // NOTE(casey): Use digital movement tuning
            if (Controller->MoveLeft.EndedDown)
            {
                GameState->XOffset -= 1;
            }
            
            if (Controller->MoveRight.EndedDown)
            {
                GameState->XOffset += 1;
            }
        }
        
        if(Controller->ActionDown.EndedDown)
        {
            GameState->YOffset += 1;
        }
    }
    
~~~~~~~ C++ delete
    GameSoundOutput(SoundBuffer, GameState->ToneHz);
~~~~~~~ C++
    RenderWeirdGradient(Buffer, GameState->XOffset, GameState->YOffset);
}

~~~~~~~ C++ add
internal void
GameGetSoundSamples(game_memory* Memory, game_sound_output_buffer *SoundBuffer)
{
    game_state *GameState = (game_state*)Memory;
    GameSoundOutput(SoundBuffer, GameState->ToneHz);
}
~~~~~~~

yay!

# Improve Debug Drawing Routine

Let's have some fun!

## Highlight Latest Marker

~~~~~~~ C++
internal void
Win32DebugSyncDisplay(win32_offscreen_buffer *Backbuffer,
                      int MarkerCount, win32_debug_time_marker *Markers,
~~~~~~~ C++ add
                      int CurrentMarkerIndex,
~~~~~~~ C++
                      win32_sound_output *SoundOutput, f32 TargetSecondsPerFrame)
{
    int PadX = 16;
    int PadY = 16;
    
~~~~~~~ C++ add
    int LineHeight = 64;
~~~~~~~ C++ delete
    int Top = PadY;
    int Bottom = Backbuffer->Height - PadY;
~~~~~~~ C++
    
    f32 C = (f32)(Backbuffer->Width - 2 * PadX) / (f32)SoundOutput->SecondaryBufferSize;
    for (int MarkerIndex = 0;
         MarkerIndex < MarkerCount;
         ++MarkerIndex)
    {
~~~~~~~ C++ add
        DWORD PlayColor = 0xFFFFFFFF;
        DWORD WriteColor = 0xFFFF0000;
        
        int Top = PadY;
        int Bottom = PadY + LineHeight;
        
        if (MarkerIndex == CurrentMarkerIndex)
        {
            Top += LineHeight + PadY;
            Bottom += LineHeight + PadY;
        }
~~~~~~~ C++
        
        win32_debug_time_marker *ThisMarker = &Markers[MarkerIndex];
~~~~~~~ C++ edit
        Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom, ThisMarker->PlayCursor, PlayColor);
        Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom, ThisMarker->WriteCursor, WriteColor);
~~~~~~~ C++
    }
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp]</file> Improving `Win32DebugSyncDisplay`.]

~~~~~~~ C++
#if HANDMADE_INTERNAL
~~~~~~~ C++ add
// TODO(casey): Note, current is wrong on the zero'th index
~~~~~~~ C++
Win32DebugSyncDisplay(&GlobalBackbuffer,
                        ArrayCount(DebugTimeMarkers), DebugTimeMarkers,
~~~~~~~ C++ add
                        DebugTimeMarkerIndex - 1,
~~~~~~~ C++
                        &SoundOutput, TargetSecondsPerFrame);
#endif
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Passing current marker index.]

## Record More Values

~~~~~~~ C++
struct win32_debug_time_marker
{
~~~~~~~ C++ add
    DWORD OutputPlayCursor;
    DWORD OutputWriteCursor;
    DWORD OutputLocation; 
    DWORD OutputByteCount;
    
~~~~~~~ C++ edit
    DWORD FlipPlayCursor;
    DWORD FlipWriteCursor;
~~~~~~~ C++
};
~~~~~~~
[Listing [x]: <file>[win32_handmade.h]</file> Updating old values and adding some new ones.]

~~~~~~~ C++
#if HANDMADE_INTERNAL
// NOTE(casey): This is debug code
{
    DWORD FlipPlayCursor = 0;
    DWORD FlipWriteCursor= 0;
    if (SUCCEEDED(GlobalSecondaryBuffer->GetCurrentPosition(&FlipPlayCursor, &FlipWriteCursor)))
    {
        Assert(DebugTimeMarkerIndex < ArrayCount(DebugTimeMarkers));
~~~~~~~ C++ edit
        win32_debug_time_marker *Marker = &DebugTimeMarkers[DebugTimeMarkerIndex];
~~~~~~~ C++ delete
        if (DebugTimeMarkerIndex == ArrayCount(DebugTimeMarkers))
        {
            DebugTimeMarkerIndex = 0;
        }
~~~~~~~ C++ edit
        Marker->FlipPlayCursor = FlipPlayCursor;
        Marker->FlipWriteCursor = FlipWriteCursor;
~~~~~~~ C++
    }
}
#endif

// ... 

#if 0
// debug timing output
// ...
#endif

~~~~~~~ C++ add
#if HANDMADE_INTERNAL
++DebugTimeMarkerIndex;
if (DebugTimeMarkerIndex == ArrayCount(DebugTimeMarkers))
{
    DebugTimeMarkerIndex = 0;
}
#endif
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Making sure time marker index is only updated once per frame.]


~~~~~~~ C++
GameGetSoundSamples(&GameMemory, &SoundBuffer);
                        
Win32FillSoundBuffer(&SoundOutput, ByteToLock, BytesToWrite, &SoundBuffer);

#if HANDMADE_INTERNAL
~~~~~~~ C++ add
win32_debug_time_marker *Marker = &DebugTimeMarkers[DebugTimeMarkerIndex];
Marker->OutputPlayCursor = PlayCursor;
Marker->OutputWriteCursor = WriteCursor;
Marker->OutputLocation = ByteToLock;
Marker->OutputByteCount = BytesToWrite;
~~~~~~~ C++

//... 
OutputDebugStringA(TextBuffer);
#endif
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Recording output markers.]

Finally, we need to update the correct struct members inside `Win32DebugSyncDisplay`: 

~~~~~~~ C++
win32_debug_time_marker *ThisMarker = &Markers[MarkerIndex];
~~~~~~~ C++
Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom,             
~~~~~~~ C++ edit
                           ThisMarker->FlipPlayCursor, PlayColor);
~~~~~~~ C++
Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom, 
~~~~~~~ C++ edit
                           ThisMarker->FlipWriteCursor, WriteColor);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > Win32DebugSyncDisplay]</file> Making us compilable.]

So far, we're recording the new values but we don't display them. You can compile and test it out: now changes yet. Let's add the newly recorded values to our debug display.

~~~~~~~ C++ add
win32_debug_time_marker *ThisMarker = &Markers[MarkerIndex];
~~~~~~~ C++

DWORD PlayColor = 0xFFFFFFFF;
DWORD WriteColor = 0xFFFF0000;

int Top = PadY;
int Bottom = PadY + LineHeight;

if (MarkerIndex == CurrentMarkerIndex)
{
    Top += LineHeight + PadY;
    Bottom += LineHeight + PadY;
    
~~~~~~~ C++ add
    Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom, 
                               ThisMarker->OutputPlayCursor, PlayColor);
    Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom, 
                               ThisMarker->OutputWriteCursor, WriteColor);
    Top += LineHeight + PadY;
    Bottom += LineHeight + PadY;
    Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom, 
                               ThisMarker->OutputLocation, PlayColor);
    Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom,       
                               ThisMarker->OutputLocation + ThisMarker->OutputByteCount, WriteColor);
    Top += LineHeight + PadY;
    Bottom += LineHeight + PadY;
~~~~~~~ C++
}
~~~~~~~ C++ delete
win32_debug_time_marker *ThisMarker = &Markers[MarkerIndex];
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > Win32DebugSyncDisplay]</file> Displaying new values (only on the current cursor).]

~~~~~~~ C++
internal void
Win32DebugDrawVertical(win32_offscreen_buffer *Backbuffer,
                       int X, int Top, int Bottom, u32 Color)
{
~~~~~~~ C++ add
    if (Top <= 0)
    {
        Top = 0;
    }
    
    if (Bottom > Backbuffer->Height)
    {
        Bottom = Backbuffer->Height;
    }
    
    if ((X >= 0) && (X < Backbuffer->Width))
    {
~~~~~~~ C++
        u8 *Pixel = (u8 *)Backbuffer->Memory +
            X * Backbuffer->BytesPerPixel +
            Top * Backbuffer->Pitch;
        for (int Y = Top;
            Y < Bottom;
            ++Y)
        {
            *(u32 *)Pixel = Color;
            Pixel += Backbuffer->Pitch;
        }
~~~~~~~ C++ add
    }
~~~~~~~ C++
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp]</file> Making sure we never go out of bounds.]

~~~~~~~ C++
inline void
Win32DrawSoundBufferMarker(...)
{
~~~~~~~ C++ delete
    Assert (Value < SoundOutput->SecondaryBufferSize);
~~~~~~~ C++
    f32 XReal = C * (f32)Value;
    int X = PadX + (int)XReal;
    
    Win32DebugDrawVertical(Backbuffer, X, Top, Bottom, Color);
}

internal void
Win32DebugSyncDisplay(...)
{
    int PadX = 16;
    int PadY = 16;
    
    int LineHeight = 64;
    
    f32 C = (f32)(Backbuffer->Width - 2 * PadX) / (f32)SoundOutput->SecondaryBufferSize;
    for (int MarkerIndex = 0;
         MarkerIndex < MarkerCount;
         ++MarkerIndex)
    {
        win32_debug_time_marker *ThisMarker = &Markers[MarkerIndex];
        
~~~~~~~ C++ add
        Assert(ThisMarker->OutputPlayCursor < SoundOutput->SecondaryBufferSize);
        Assert(ThisMarker->OutputWriteCursor < SoundOutput->SecondaryBufferSize);
        Assert(ThisMarker->OutputLocation < SoundOutput->SecondaryBufferSize);
        Assert(ThisMarker->OutputByteCount < SoundOutput->SecondaryBufferSize);
        Assert(ThisMarker->FlipPlayCursor < SoundOutput->SecondaryBufferSize);
        Assert(ThisMarker->FlipWriteCursor < SoundOutput->SecondaryBufferSize);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp]</file> Fixing the assertions.]
 
## Add Global Pause Key And Inspect Values

~~~~~~~ C++
global_variable b32 GlobalRunning;
~~~~~~~ C++ add
global_variable b32 GlobalPause;
~~~~~~~ C++
global_variable win32_offscreen_buffer GlobalBackbuffer;
global_variable IDirectSoundBuffer *GlobalSecondaryBuffer;
global_variable s64 GlobalPerfCountFrequency;
~~~~~~~


~~~~~~~ C++
else if (VKCode == VK_BACK)
{
    Win32ProcessKeyboardMessages(&KeyboardController->Back, IsDown);
}
~~~~~~~ C++ add
#if HANDMADE_INTERNAL
else if (VKCode == 'P')
{
    if (IsDown)
    {
        GlobalPause = !GlobalPause;
    }
}
#endif

b32 AltKeyWasDown = ((Message.lParam & (1 << 29)) != 0);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > Win32ProcessPendingMessages]</file> Adding Global Pause Hotkey.]

~~~~~~~ C++
Win32ProcessPendingMessages(NewKeyboardController);
~~~~~~~ C++ add
if (!GlobalPause)
{
~~~~~~~ C++
    DWORD MaxControllerCount = XUSER_MAX_COUNT;
    if(MaxControllerCount > (ArrayCount(NewInput->Controllers) - 1))
    {
        MaxControllerCount = (ArrayCount(NewInput->Controllers) - 1);
    }
    // ...
    // All of the game update
    // ...
    
#if HANDMADE_INTERNAL
    ++DebugTimeMarkerIndex;
    if (DebugTimeMarkerIndex == ArrayCount(DebugTimeMarkers))
    {
        DebugTimeMarkerIndex = 0;
    }
#endif
~~~~~~~ C++ add
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Implementing Global Pause.]

// FIXME: 02:06

------------------------
<!-- 
[Listing [x]: <file>[]</file> .]
![Figure [x]: .](../media/day16/.jpg) 
[Figure [x]: .]
-->
------------------------






















# Recap 

# Exercises 

# Programming Notions 

# Side Considerations 

# Navigation 

Previous: [Day 19. Improving Audio Synchronization][day 19]

Up Next: [Day 21. Loading Game Code Dynamically][day 21]

[Back to Index](../index.md.html)

(#) Glossary 

(insert glossary/glossary_day20.md.html here)

(insert references/refs_day20.md.html here) 

(insert links.md.html here)

<style class="fallback">
  body {
    visibility: hidden;
    font-family: sans-serif;
  }
</style>
<!-- Markdeep: https://casual-effects.com/markdeep/ -->
<script>
  markdeepOptions = { tocStyle: 'long' };
  window.alreadyProcessedMarkdeep ||
    (document.body.style.visibility = 'visible');
</script>
<script src="../js/markdeep.min.js" charset="utf-8"></script>
