<meta charset="UTF-8">
<meta http-equiv="content-type" content="text/html;charset=UTF-8">
<meta name="viewport" content="width=600, initial-scale=1">
<link rel="stylesheet" href="../css/html-style.css">
<link rel="stylesheet" href="../css/style.css">

<span class="md"><p><title>Day 3. Allocating a Back Buffer</title><div class="title"> Day 3. Allocating a Back Buffer </div>

<div class="afterTitles"></div>
<em class="underscore">Video Length: <a href="https://hero.handmade.network/episode/code/day003/">1h03</a> (before Q&A)</em>

</p><p>

Welcome to &ldquo;Handmade Hero Notes&rdquo;, the book where we follow the footsteps of <a href="https://handmadehero.org/">Handmade Hero</a> in making the complete game from scratch, with no external libraries. If you'd like to follow along, preorder the game on <a href="https://handmadehero.org/">handmadehero.org</a>, and you will receive access to the GitHub repository, containing complete source code (tagged day-by-day) as well as a variety of other useful resources.

</p><p>

We have not quite finished setting up our application: some things need to be cleaned up, and we need to start drawing to our window. 

</p><p>

Today, we'll need to create something that would become our <em class="underscore">buffer</em> of pixels that we can write to in any way that we want. We then need to give it back to Windows, so that it displays it in our window for us. It won't be necessarily the most <em class="underscore">efficient</em> way of render things on Windows (nowadays everything goes through the 3D graphics card). However, before anything can go to the graphics card, we're going to do everything from scratch ourselves, so we'll need to follow a slightly slower path. 

</p><p>

<div class="admonition trivia">This is <em class="underscore">sort of</em> going back to the old days, when this was <em class="underscore">the</em> way of writing renderer. At the time there simply wasn't much in a way of graphics card to do for you. It was simply in charge of displaying the graphics buffer on the screen.</div>

</p>
<div class="longTOC">
    <p align="center">
        <span align="left"><a href="day2.html">Day 2</a></span>
        <a href="../index.html"><img src = "../media/logo.png"></a>
        <span align="right"><a href="day4.html">Day 4</a></span>
    </p><p><a href="#" class="tocTop">(Top)</a><br/>
<a href="#windowsmessagecallback" class="level1"><span class="tocNumber">1&nbsp; </span>Windows Message Callback</a><br/>
&nbsp;&nbsp;<a href="#windowsmessagecallback/closingthewindow" class="level2"><span class="tocNumber">1.1&nbsp; </span>Closing the Window</a><br/>
<a href="#differentmeaningsofstatic" class="level1"><span class="tocNumber">2&nbsp; </span>Different Meanings of <code>static</code></a><br/>
&nbsp;&nbsp;<a href="#differentmeaningsofstatic/global_variable" class="level2"><span class="tocNumber">2.1&nbsp; </span>global_variable</a><br/>
&nbsp;&nbsp;<a href="#differentmeaningsofstatic/local_persist" class="level2"><span class="tocNumber">2.2&nbsp; </span>local_persist</a><br/>
&nbsp;&nbsp;<a href="#differentmeaningsofstatic/internal" class="level2"><span class="tocNumber">2.3&nbsp; </span>internal</a><br/>
<a href="#layouttheplan" class="level1"><span class="tocNumber">3&nbsp; </span>Lay Out the Plan</a><br/>
&nbsp;&nbsp;<a href="#layouttheplan/backbuffer,windows,gdiandus" class="level2"><span class="tocNumber">3.1&nbsp; </span>Backbuffer, Windows, GDI and Us</a><br/>
&nbsp;&nbsp;<a href="#layouttheplan/create/resizedibsection" class="level2"><span class="tocNumber">3.2&nbsp; </span>Create / Resize DIB Section</a><br/>
&nbsp;&nbsp;<a href="#layouttheplan/calculateclientarea" class="level2"><span class="tocNumber">3.3&nbsp; </span>Calculate Client Area</a><br/>
&nbsp;&nbsp;<a href="#layouttheplan/somerefactoring" class="level2"><span class="tocNumber">3.4&nbsp; </span>Some Refactoring</a><br/>
&nbsp;&nbsp;<a href="#layouttheplan/updatewindow" class="level2"><span class="tocNumber">3.5&nbsp; </span>Update Window</a><br/>
<a href="#implementlogic" class="level1"><span class="tocNumber">4&nbsp; </span>Implement Logic</a><br/>
&nbsp;&nbsp;<a href="#implementlogic/stretchdibitsimplementation" class="level2"><span class="tocNumber">4.1&nbsp; </span><code>StretchDIBits</code> Implementation</a><br/>
&nbsp;&nbsp;<a href="#implementlogic/createdibsectionimplementation" class="level2"><span class="tocNumber">4.2&nbsp; </span><code>CreateDIBSection</code> Implementation</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#implementlogic/createdibsectionimplementation/filloutbitmapinfo" class="level3"><span class="tocNumber">4.2.1&nbsp; </span>Fill Out <code>BITMAPINFO</code></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#implementlogic/createdibsectionimplementation/decideonmemoryallocation" class="level3"><span class="tocNumber">4.2.2&nbsp; </span>Decide on Memory Allocation</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#implementlogic/createdibsectionimplementation/extractmoreglobalvariables" class="level3"><span class="tocNumber">4.2.3&nbsp; </span>Extract More Global Variables</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#implementlogic/createdibsectionimplementation/freememory" class="level3"><span class="tocNumber">4.2.4&nbsp; </span>Free Memory</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#implementlogic/createdibsectionimplementation/getthedevicecontext" class="level3"><span class="tocNumber">4.2.5&nbsp; </span>Get the Device Context</a><br/>
&nbsp;&nbsp;<a href="#implementlogic/finishwin32updatewindow" class="level2"><span class="tocNumber">4.3&nbsp; </span>Finish <code>Win32UpdateWindow</code></a><br/>
<a href="#inspectyourwork" class="level1"><span class="tocNumber">5&nbsp; </span>Inspect Your Work</a><br/>
<a href="#recap" class="level1"><span class="tocNumber">6&nbsp; </span>Recap</a><br/>
<a href="#exercises" class="level1"><span class="tocNumber">7&nbsp; </span>Exercises</a><br/>
&nbsp;&nbsp;<a href="#exercises/experimentwiththedebugger" class="level2"><span class="tocNumber">7.1&nbsp; </span>Experiment with the Debugger</a><br/>
&nbsp;&nbsp;<a href="#exercises/peekingintoassemblylanguage" class="level2"><span class="tocNumber">7.2&nbsp; </span>Peeking into Assembly Language</a><br/>
<a href="#programmingbasics" class="level1"><span class="tocNumber">8&nbsp; </span>Programming Basics</a><br/>
&nbsp;&nbsp;<a href="#programmingbasics/aboutresourcehandling" class="level2"><span class="tocNumber">8.1&nbsp; </span>About Resource Handling</a><br/>
&nbsp;&nbsp;<a href="#programmingbasics/definedirective" class="level2"><span class="tocNumber">8.2&nbsp; </span>Define Directive</a><br/>
&nbsp;&nbsp;<a href="#programmingbasics/voidtype" class="level2"><span class="tocNumber">8.3&nbsp; </span>void Type</a><br/>
<a href="#sideconsiderations" class="level1"><span class="tocNumber">9&nbsp; </span>Side Considerations</a><br/>
&nbsp;&nbsp;<a href="#sideconsiderations/aboutglobalvariables" class="level2"><span class="tocNumber">9.1&nbsp; </span>About Global Variables</a><br/>
<a href="#navigation" class="level1"><span class="tocNumber">10&nbsp; </span>Navigation</a><br/>
</p></div><a class="target" name="windowsmessagecallback">&nbsp;</a><a class="target" name="windowsmessagecallback">&nbsp;</a><a class="target" name="toc1">&nbsp;</a><h1>Windows Message Callback</h1>
<p>


In the previous chapter, we finished setting up our window and getting ready of outputting something into it. We have our <em class="underscore">callback function</em> and a <em class="underscore">message loop</em>. The latter is a way to process the <em class="underscore">message queue</em>, where Windows and other programs add messages. We need to <em class="underscore">pull</em> these messages, one at a time, Translate and Dispatch them, so that they are sent to our <code>MainWindowCallback</code> function. 

</p><p>

<div class="admonition note"><div class="admonition-title"> Why do we need a callback function at all? </div>

</p><p>

    We have our message queue which we pull messages from, why can't we process them at the same place, without going through setting up an opaque message dispatch system? 

</p><p>

    While we're those who pull the messages from our queue, we aren't the only ones who can call our callback function. Windows reserves the right to call that callback function any time it wants to. It does not have to do it inside that <code>DispatchMessageA</code>, and we have to be ready for the operating system to call us back.</div>

</p>
<a class="target" name="closingthewindow">&nbsp;</a><a class="target" name="windowsmessagecallback/closingthewindow">&nbsp;</a><a class="target" name="toc1.1">&nbsp;</a><h2>Closing the Window</h2>
<p>


In our <code>MainWindowCallback</code>, we left out a couple of things to fix. One thing is that you cannot close it without interrupting the process from the debugger (<code>Shift-F5</code>) or the Task Manager. The reason for it is that we are not currently handling <code>WM_CLOSE</code> message (aside from printing <code>WM_CLOSE</code> to Output whenever we hit it). 

</p><p>

To handle <code>WM_CLOSE</code> message properly there're a few things that we can do. 

</p><p>

First, let's look at our message loop inside the <code>WinMain</code>. As you might remember from the <a href="day2.html#createwindow/windowmessagequeue">previous chapter</a>, if <code>GetMessage</code> receives <code>WM_QUIT</code> message, its result is <code>0</code> (and if the window handle provided is invalid, the result is <code>-1</code>). That is why we're checking if the message result is greater than <code>0</code>: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">for</span>(;;)</span>
<span class="line">{</span>
<span class="line">    MSG Message;</span>
<span class="line">    BOOL MessageResult = GetMessage(&amp;Message, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span>
<span class="line">    <span class="hljs-keyword">if</span> (MessageResult &gt; <span class="hljs-number">0</span>)</span>
<span class="line">    {</span>
<span class="line">        TranslateMessage(&amp;Message);</span>
<span class="line">        DispatchMessage(&amp;Message);</span>
<span class="line">    }</span>
<span class="line">    <span class="hljs-keyword">else</span></span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-keyword">break</span>;                      </span>
<span class="line">    }</span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;1:</b> <file>[win32_handmade.cpp > WinMain]</file> Our message loop.</div></center>
<p>


So, at the moment, if we want to exit the application, we simply need to receive a quit messsage! Luckily there's a <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postquitmessage">handy function</a> that does just that:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">case</span> WM_CLOSE:</span>
<span class="line">{</span><div class=" add "><span class="line">    PostQuitMessage(<span class="hljs-number">0</span>);</span></div><span class="line">    OutputDebugStringA(<span class="hljs-string">"WM_CLOSE\n"</span>);</span>
<span class="line">} <span class="hljs-keyword">break</span>;</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;2:</b> <file>[win32_handmade.cpp > MainWindowCallback]</file> Requesting <code>WM_QUIT</code> message from <code>WM_CLOSE</code>.</div></center>
<p>


The <code>0</code> that we pass to the <code>PostQuitMessage</code> is our <em class="underscore">exit code</em>. As in our <code>WinMain</code>, this simply means &ldquo;all good, program terminated correctly&rdquo;. In case of some error, you could use some other number so that you're able to analyze why your program might have crashed. We don't really care about this because we won't see much interaction with Windows. 

</p><p>

<div class="admonition warning">This is your daily reminder to lookup the function names in <code>MSDN</code> yourself! While we're providing all the functions and extract the important bits out of them, this course might not have all the calls that you might need for your own programs. 

</p><p>

    Be sure also to make sure the articles you find are for your target architecture. You can check it in the <strong class="asterisk">Requirements</strong> section at the bottom of each article where you can see some useful information like &ldquo;Minimum supported client&rdquo;. You can also find here other useful information like the library (that we used already a couple of times).</div>

</p><p>

Let's compile and debug our program.

</p><p>

<ol start=1>
<li class="number">Set up a breakpoint at the <code>WM_CLOSE</code> case in your <code>MainWindowCallback</code> and at the message loop <code>break</code> point (<code>F9</code>).
</li>
<li class="number">Start debugging (<code>F5</code>).
</li>
<li class="number">Hit the red <code>X</code> button in your window. You will notice that your program halts at the breakpoint you've set. 
</li>
<li class="number">Hit <code>F10</code> to advance the program until <code>PostQuitMessage</code>. This function will then trigger and post a new <code>WM_QUIT</code> message to the queue.
</li>
<li class="number">Continue running the program (<code>F5</code>). 
</li>
<li class="number">One of the new messages that we receive with our <code>GetMessage</code> will be <code>WM_QUIT</code> which will trigger the breakpoint at our <code>break</code> statement.
</li>
<li class="number"><code>F10</code> &rarr; <code>break</code> will throw us out of the message loop.
</li>
<li class="number">If you hit <code>F10</code> a couple more times, the program will reach its end and exit.</li></ol>

</p><p>

<div class="admonition ">Keep in mind that <code>WM_QUIT</code> might not come immediately after <code>WM_CLOSE</code>. Usually there would be a plethora of other messages the queue should go through before it gets to <code>WM_QUIT</code>.</div>

</p><p>

<center><div class="image" style=""><a href="../media/day3/quit1.png" target="_blank"><img class="markdeep" src="../media/day3/quit1.png" /></a><center><span class="imagecaption"><a class="target" name="figure_x">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;1:</b> Hitting our breakpoint to exit the loop. Notice that this happens (shortly) after we have processed <code>WM_CLOSE</code> message, as the <code>Output</code> line states.</span></center></div></center>

</p><p>

If you're wondering out why aren't we closing our window, check out subsection  <a href="#toc8.1">8.1</a>.

</p><p>

There's a bit of an oddity in that we are handling the <code>WM_CLOSE</code> message but not the <code>WM_DESTROY</code>. If you want to write a bit <em class="underscore">cleaner</em> code, you may also add the same <code>PostQuitMessage</code> to <code>WM_DESTROY</code>:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">case</span> WM_DESTROY:</span>
<span class="line">{</span><div class=" add "><span class="line">    PostQuitMessage(<span class="hljs-number">0</span>);</span></div><span class="line">    OutputDebugStringA(<span class="hljs-string">"WM_DESTROY\n"</span>);</span>
<span class="line">} <span class="hljs-keyword">break</span>;</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;3:</b> <file>[win32_handmade.cpp > MainWindowCallback]</file> Requesting <code>WM_QUIT</code> message from <code>WM_DESTROY</code>.</div></center>
<p>


If you want to go even one step further to tidy everything up, you could <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroywindow">destroy the window</a> (and from there quit): 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">case</span> WM_CLOSE:</span>
<span class="line">{</span><div class=" edit"><span class="line">    DestroyWindow(Window);</span></div><span class="line">    OutputDebugStringA(<span class="hljs-string">"WM_CLOSE\n"</span>);</span>
<span class="line">} <span class="hljs-keyword">break</span>;</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;4:</b> <file>[win32_handmade.cpp > MainWindowCallback]</file> Requesting <code>WM_DESTROY</code> message from <code>WM_CLOSE</code>.</div></center>
<p>


In reality, we aren't going to do any of these things. We will introduce a <em class="underscore">global variable</em> that, if set to false, will lead us out of the game loop.

</p><p>

This brings to us the following chain of changes:

</p><p>

<ol start=1>
<li class="number">Inside <code>WinMain</code>, what used to be an infinite <code>for</code> loop becomes a <code>while</code> loop (from &ldquo;forever&rdquo; it will become &ldquo;while we are running&rdquo;).
</li>
<li class="number">As the criteria for the <code>while</code> loop, we will use a global boolean variable called <code>Running</code> that we will create on top of our <code>win32_handmade.cpp</code> file. 
<ul>
    <li class="asterisk">In the future, this variable might be moved somewhere else, but it will be global for now. 
</li></ul>
<li class="number">Inside our <code>WM_CLOSE</code> case of <code>MainWindowCallback</code>, we will set it to <code>false</code>. This means that, whenever we receive a <code>WM_CLOSE</code> message, user wants to quit &rarr; stop running &rarr; go out of the <code>while</code> loop and exit our application. We can add the same line in <code>WM_DESTROY</code> for consistency. In a grand scheme of things, this is a temporary measure. In the final game there're a few considerations against such a solution:
<ul>
    <li class="asterisk">We might not want the user to close the application right away, but maybe spawn a confirmation dialogue before switching off the game loop.
</li>
    <li class="asterisk">In another case, we might not expect the window to be destroyed; in that case we might treat it as an error of some sort and try to recreate the window.
</li></ul>
<li class="number">Set <code>Running</code> to true just before entering the <code>while</code> loop.</li></ol>

</p><p>

In total, this will result in the following set of changes:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span></span>
<span class="line"></span><div class=" add"><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> Running;</span></div><span class="line"></span>
<span class="line"><span class="hljs-function">LRESULT CALLBACK</span>
<span class="line"><span class="hljs-title">MainWindowCallback</span><span class="hljs-params">(...)</span></span>
<span class="line"></span>{</span>
<span class="line">    <span class="hljs-keyword">switch</span> (Message)</span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-keyword">case</span> WM_CLOSE:</span>
<span class="line">        {</span><div class=" add"><span class="line">            Running = <span class="hljs-literal">false</span>;</span></div><span class="line">        } <span class="hljs-keyword">break</span>;</span>
<span class="line">        </span>
<span class="line">        <span class="hljs-keyword">case</span> WM_DESTROY:</span>
<span class="line">        {</span><div class=" add"><span class="line">            Running = <span class="hljs-literal">false</span>;</span></div><span class="line">        } <span class="hljs-keyword">break</span>;</span>
<span class="line">        <span class="hljs-comment">// ... </span></span>
<span class="line">    }</span>
<span class="line">    <span class="hljs-comment">// ...</span></span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> CALLBACK</span>
<span class="line"><span class="hljs-title">WinMain</span><span class="hljs-params">(...)</span></span>
<span class="line"></span>{</span>
<span class="line">    <span class="hljs-comment">//... </span></span>
<span class="line">    <span class="hljs-keyword">if</span> (Window) {</span><div class=" add"><span class="line">        Running = <span class="hljs-literal">true</span>;</span></div><div class=" edit"><span class="line">        <span class="hljs-keyword">while</span> (Running) <span class="hljs-comment">// Replaces "for" loop</span></span></div><span class="line">        {</span>
<span class="line">            <span class="hljs-comment">//...</span></span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;5:</b> <file>[win32_handmade.cpp]</file> Adding <code>Running</code> global variable</div></center>

<a class="target" name="differentmeaningsofstatic">&nbsp;</a><a class="target" name="differentmeaningsofstatic">&nbsp;</a><a class="target" name="toc2">&nbsp;</a><h1>Different Meanings of <code>static</code></h1>
<p>


Let's make a small detour here. 

</p><p>

We <a href="day2.html#drawingsomethingtoourwindow/“animating”thewindow">already encountered</a> the <code>static</code> keyword. We mentioned that <code>static</code> has three meanings in C, depending on where you put it (we used it to identify a &ldquo;locally persistent&rdquo; variable inside our <code>WM_PAINT</code>), so let's define it as three different keywords. We'll add them at the top of <code>win32_handmade.cpp</code>: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span></span>
<span class="line"></span><div class=" add"><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> internal static </span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> local_persist static </span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> global_variable static </span></span></div><span class="line"><span class="hljs-comment">// the rest of our program</span></span></code></pre><p>



<div class="admonition note">Learn more about the <code>#define</code> in the subsection  <a href="#toc8.2">8.2</a>.</div>

</p><p>

In our case, we <code>#define</code> three different names to translate as the <code>static</code> keyword. Let's look in which situations to use which.

</p>
<a class="target" name="global_variable">&nbsp;</a><a class="target" name="differentmeaningsofstatic/global_variable">&nbsp;</a><a class="target" name="toc2.1">&nbsp;</a><h2>global_variable</h2>
<p>


<code>global_variable</code> is a variable that, once declared, is available in the entirety of the file it's in. Any function can access it, read its value and modify it. 

</p><p>

Additionally, any <code>global_variable</code>, once declared, is initialized to <code>0</code>. 

</p><p>

Before we move on, let's rename our <code>static bool Running</code> into a <code>global_variable</code>: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span></span>
<span class="line"></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> internal static </span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> local_persist static </span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> global_variable static </span></span>
<span class="line"></span><div class=" edit"><span class="line">global_variable <span class="hljs-keyword">bool</span> Running;</span></div><span class="line"><span class="hljs-comment">// the rest of our program</span></span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;6:</b> <file>[win32_handmade.cpp]</file> Renaming <code>static</code> Running</div></center>
<p>




<div class="admonition note"><div class="admonition-title"> About Global Variables</div>

</p><p>

    You can read some additional consideration about the global variables in the subsection  <a href="#toc9.1">9.1</a>.</div>

</p>
<a class="target" name="local_persist">&nbsp;</a><a class="target" name="differentmeaningsofstatic/local_persist">&nbsp;</a><a class="target" name="toc2.2">&nbsp;</a><h2>local_persist</h2>
<p>


Locally persistent <code>static</code> variable stays around similar to a <code>global_variable</code> but it's locally scoped.This is the way we used it <a href="day2.html#drawingsomethingtoourwindow/“animating”thewindow">last time</a>. 

</p><p>

Normally, whenever you enter a <em class="underscore">scope</em>, area designated by braces (<code>{}</code>), variables declared inside it live until you go out of it. Then that memory is cleared, variable becomes undefined and, if there was already a variable with the same name declared further &ldquo;above&rdquo;, the latter's value is returned to the variable.

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;</span>
<span class="line">{ <span class="hljs-comment">// enter scope</span></span>
<span class="line">    <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>; </span>
<span class="line">    <span class="hljs-keyword">int</span> y = <span class="hljs-number">2</span>; </span>
<span class="line"></span>
<span class="line">    <span class="hljs-built_in">printf</span>(x); <span class="hljs-comment">// 1</span></span>
<span class="line">    <span class="hljs-built_in">printf</span>(y); <span class="hljs-comment">// 2</span></span>
<span class="line">} <span class="hljs-comment">// exit scope</span></span>
<span class="line"></span>
<span class="line"><span class="hljs-built_in">printf</span>(x); <span class="hljs-comment">// 0</span></span>
<span class="line"><span class="hljs-built_in">printf</span>(y); <span class="hljs-comment">// compilation error: y is undefined</span></span>
<span class="line"></span></code></pre><center><div class="listingcaption tilde"><file>[Example 1]</file>. Redaclaring a variable will also produce a warning on a higher warning level.</div></center>
<p>


If you mark a variable with <code>static</code> (or, in our case, <code>local_persist</code>), it will be declared only once for the whole duration of the program. Each time that your program returns to that point (in a loop, or by calling the function multiple times), the application will remember the variable's value from the last time it was at this point in the program.

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetNextNumber</span><span class="hljs-params">()</span></span>
<span class="line"></span>{</span>
<span class="line">    <span class="hljs-keyword">int</span> Result = <span class="hljs-number">0</span>;</span>
<span class="line">    <span class="hljs-keyword">int</span> x = <span class="hljs-number">-1</span>;</span>
<span class="line"></span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; </span>
<span class="line">        x = x + <span class="hljs-number">1</span>;</span>
<span class="line">        Result = x;</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    <span class="hljs-keyword">return</span> (Result);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="line"></span>{</span>
<span class="line">    <span class="hljs-built_in">printf</span>(GetNextNumber()); <span class="hljs-comment">// 1</span></span>
<span class="line">    <span class="hljs-built_in">printf</span>(GetNextNumber()); <span class="hljs-comment">// 2</span></span>
<span class="line">    <span class="hljs-built_in">printf</span>(GetNextNumber()); <span class="hljs-comment">// 3</span></span>
<span class="line">    <span class="hljs-built_in">printf</span>(GetNextNumber()); <span class="hljs-comment">// 4</span></span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><file>[Example 2]</file>. Note that this wouldn't change the variable's scope, it will still be only available inside its block.</div></center>
<p>


In <file>example 2</file>, inner <code>x</code> is initialized to 1 only once. The rest of the times, when we call our <code>GetNextNumber</code> function, it &ldquo;remembers&rdquo; its value from the last time, and correctly increments itself by 1.

</p><p>

While we're at it, let's rename our only <code>static</code> variable to <code>local_persist</code>.

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">case</span> WM_PAINT: </span>
<span class="line">{</span>
<span class="line">    <span class="hljs-comment">// ...</span></span><div class=" edit"><span class="line">    local_persist DWORD Operation = WHITENESS;</span></div><span class="line">    PatBlt(DeviceContext, X, Y, Width, Height, Operation);</span>
<span class="line"></span>
<span class="line">    EndPaint(Window, &amp;Paint);</span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;7:</b> <file>[win32_handmade.cpp > MainWindowCallback]</file> Renaming <code>static</code> Operation.</div></center>
<p>




<div class="admonition warning"><div class="admonition-title"> Don't use <code>local_persist</code> in your final code!</div>

</p><p>

    There're many reasons to <em class="underscore">never</em> use static variables in the final code. This is a very bad idea for thread safety and other advanced things. 

</p><p>

    It was one of the reasons we even split the <code>static</code> keyword into three keywords: so that we can search for <code>local_persist</code> variables and strip them away from the final code.

</p><p>

    However, they are a handy tool for development purposes, because they allow to quickly introduce something to the code without having to worry about passing things around, and this is exactly what we are doing right now in <code>WM_PAINT</code>: making sure our <code>PatBlt</code> does exactly what we want to it to do.</div>

</p>
<a class="target" name="internal">&nbsp;</a><a class="target" name="differentmeaningsofstatic/internal">&nbsp;</a><a class="target" name="toc2.3">&nbsp;</a><h2>internal</h2>
<p>


If a <code>static</code> keyword is applied to a function, the function is marked as &ldquo;internal&rdquo; to that specific file, and no one from outside may access it.

</p><p>

<div class="admonition ">Actually, the locality may extend to more than one file, i.e. to the entire <em class="underscore">translation unit</em> of the program. We'll speak about the translation units much, much later down the line.</div>

</p>
<a class="target" name="layouttheplan">&nbsp;</a><a class="target" name="layouttheplan">&nbsp;</a><a class="target" name="toc3">&nbsp;</a><h1>Lay Out the Plan</h1>

<a class="target" name="backbuffer,windows,gdiandus">&nbsp;</a><a class="target" name="layouttheplan/backbuffer,windows,gdiandus">&nbsp;</a><a class="target" name="toc3.1">&nbsp;</a><h2>Backbuffer, Windows, GDI and Us</h2>
<p>


Now that we've got that out of the way, let's compile and run our program. If you still can see your window, which you can close correctly, you succeeded in this <em class="underscore">refactoring</em>. We initialize our <code>Running</code> to <code>true</code> which keeps the <code>while</code> loop running, until we hit a <code>WM_CLOSE</code> message. At that point <code>Running</code> becomes <code>false</code>, we fall out the <code>while</code> loop and Windows cleans up the program for us, whether we like it or not.

</p><p>

We fixed the only problem with our application that we had: that we couldn't close it. We can close it now! <em class="underscore">Very exciting</em>. We could handle now the <code>WM_SIZE</code> and <code>WM_ACTIVATEAPP</code> which we left out as stubs. But the real problem right now is that we can't paint anything meaningful. There a few considerations here:

</p><p>

<ul>
<li class="asterisk">When we had to do our paint, we had to use Windows' graphics API called &ldquo;GDI&rdquo;. This makes heavy use of a lot of instruments like Device Contexts, Brushes, <code>PAINTSTRUCT</code>s, etc.
</li>
<li class="asterisk">Since we want to do everything from scratch, we want to interface with GDI as little as possible. In practice, we will use it only pass a bitmap to display in our window.
<ul>
    <li class="minus">Think of a bitmap as simply a picture. It's literally a <em class="underscore">bit map</em>, a sequence of colors: Red, Green, Blue, Red, Green, Blue, etc<sup><a href="#endnote-bitmap">1</a></sup>.
</li></ul>
<li class="asterisk">The bitmap itself would be created (rendered) using our own code and techniques. 
</li>
<li class="asterisk">To create the bitmap, we need to ask Windows to <em class="underscore">allocate</em> (prepare and assign to us) a <em class="underscore">memory buffer</em> (a block of memory) that we can write into. 
<ul>
    <li class="minus">We need to ask for the memory because we can't simply create a variable with many <em class="underscore">bits</em> and write into it: for very big memory blocks (like our buffer) you need to <em class="underscore">allocate memory</em> (or reserve it for our use).
</li>
    <li class="minus">Also we need to ask for it because Windows (or any other good operating system) is very protective of the memory its applications use.
</li>
    <li class="minus">We will then arrange it in a format that Windows is comfortable with us handing back to it.</li></ul></li></ul>

</p>
<a class="target" name="create/resizedibsection">&nbsp;</a><a class="target" name="layouttheplan/create/resizedibsection">&nbsp;</a><a class="target" name="toc3.2">&nbsp;</a><h2>Create / Resize DIB Section</h2>
<p>


In practice, we are going to introduce the function called <code>ResizeDIBSection</code>. It will serve to resize (or initialize if it doesn't exist) a <b>Device</b> <b>independent</b> <b>Bitmap</b> (DIB). This is the name Windows gives to the bitmaps that we can display using GDI. We will call it every time we get a <code>WM_SIZE</code> message. 

</p><pre class="listing tilde"><code><span class="line">global_variable <span class="hljs-keyword">bool</span> Running;</span>
<span class="line"></span><div class=" add"><span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">ResizeDIBSection</span><span class="hljs-params">()</span></span>
<span class="line"></span>{</span>
<span class="line">}</span></div><span class="line"></span>
<span class="line"><span class="hljs-function">LRESULT CALLBACK</span>
<span class="line"><span class="hljs-title">MainWindowCallback</span><span class="hljs-params">(...)</span></span>
<span class="line"></span>{</span>
<span class="line">    LRESULT Result;</span>
<span class="line">    </span>
<span class="line">    <span class="hljs-keyword">switch</span> (Message)</span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-keyword">case</span> WM_SIZE:</span>
<span class="line">        {</span><div class=" add"><span class="line">            ResizeDIBSection();</span></div><span class="line">            OutputDebugStringA(<span class="hljs-string">"WM_SIZE\n"</span>);</span>
<span class="line">        } <span class="hljs-keyword">break</span>;</span>
<span class="line">        </span>
<span class="line">        <span class="hljs-comment">// ...</span></span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    <span class="hljs-keyword">return</span>(Result);</span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;8:</b> <file>[win32_handmade.cpp]</file> <code>ResizeDIBSection</code> is created.</div></center>

<a class="target" name="calculateclientarea">&nbsp;</a><a class="target" name="layouttheplan/calculateclientarea">&nbsp;</a><a class="target" name="toc3.3">&nbsp;</a><h2>Calculate Client Area</h2>
<p>


A key piece of information that we will need to resize our buffer is the size of our window's <em class="underscore">client area</em>, i.e. the area which we can draw into (it's smaller than the actual window area)<sup><a href="#endnote-fullscreen">2</a></sup>. The Windows API function responsible for it is called simply <code>GetClientRect</code>. Take a moment to find it on MSDN!

</p><p>

<hr/>

</p><p>

As you can see, this function takes a window handle and a <em class="underscore">pointer</em> to a RECT structure. Windows will write the size of our window to this struct. This will give us the top, left, bottom and right coordinates that we will need to convert to width and height like we did when we were doing our <code>PatBlt</code>. 

</p><p>

We will then pass these values to our <code>ResizeDIBSection</code>.

</p><pre class="listing tilde"><code><span class="line">internal <span class="hljs-keyword">void</span></span><div class=" edit"><span class="line">ResizeDIBSection(<span class="hljs-keyword">int</span> Width, <span class="hljs-keyword">int</span> Height)</span></div><span class="line">{</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hljs-comment">// ...</span></span>
<span class="line">        <span class="hljs-keyword">case</span> WM_SIZE:</span>
<span class="line">        {</span><div class=" add"><span class="line">            RECT ClientRect;</span>
<span class="line">            GetClientRect(Window, &amp;ClientRect);</span>
<span class="line">            <span class="hljs-keyword">int</span> Width = ClientRect.right - ClientRect.left;</span>
<span class="line">            <span class="hljs-keyword">int</span> Height = ClientRect.bottom - ClientRect.top;</span></div><div class=" edit"><span class="line">            ResizeDIBSection(Width, Height);</span></div><div class=" delete"><span class="line">            OutputDebugStringA(<span class="hljs-string">"WM_SIZE\n"</span>);</span></div><span class="line">        } <span class="hljs-keyword">break</span>;</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;9:</b> <file>[win32_handmade.cpp]</file> Calculating client area size</div></center>

<a class="target" name="somerefactoring">&nbsp;</a><a class="target" name="layouttheplan/somerefactoring">&nbsp;</a><a class="target" name="toc3.4">&nbsp;</a><h2>Some Refactoring</h2>
<p>


Before we move on, let's do some cleaning up. Because we're operating on a Windows platform at the moment, you might incur in the naming conflicts. We will simply add a <code>Win32</code> prefix our functions to indicate the platform we're on.

</p><pre class="listing tilde"><code><span class="line">internal <span class="hljs-keyword">void</span></span><div class=" edit"><span class="line">Win32ResizeDIBSection(<span class="hljs-keyword">int</span> Width, <span class="hljs-keyword">int</span> Height)</span></div><span class="line"></span>
<span class="line">LRESULT CALLBACK</span><div class=" edit"><span class="line">Win32MainWindowsCallback(...)</span></div><span class="line">{</span>
<span class="line">    <span class="hljs-comment">// ...</span></span>
<span class="line">    <span class="hljs-keyword">case</span> WM_SIZE:</span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-comment">// ...</span></span><div class=" edit"><span class="line">        Win32ResizeDIBSection(Width, Height);</span></div><span class="line">        <span class="hljs-comment">// ...</span></span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> CALLBACK</span>
<span class="line"><span class="hljs-title">WinMain</span> <span class="hljs-params">(...)</span> <span class="hljs-comment">// WinMain remains with the old name since Windows _expects_ WinMain function</span></span>
<span class="line"></span>{</span>
<span class="line">    WNDMCLASS WindowClass = {};</span><div class=" edit"><span class="line">    WindowClass.lpfnWndProc = Win32MainWindowCallback;</span></div><span class="line">    <span class="hljs-comment">// ...</span></span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;10:</b> <file>[win32_handmade.cpp]</file> Adding <code>Win32</code> Prefix</div></center>
<p>


If you prefer, you could introduce a <code>namespace</code> around the code instead.

</p>
<a class="target" name="updatewindow">&nbsp;</a><a class="target" name="layouttheplan/updatewindow">&nbsp;</a><a class="target" name="toc3.5">&nbsp;</a><h2>Update Window</h2>
<p>


We now have our buffer. Each frame, we will redraw it using the procedures that we'll write. After that, the buffer will be <code>PAINT</code>ed into the window. To do that, we will ask Windows to do a copy of our buffer into a space occupied by our window inside <code>WM_PAINT</code>. 

</p><p>

<div class="admonition ">In order to create smooth animation, we will be forcing Windows to redraw at a specific framerate (30/60+ frames per second). This means that at some point we will need to also paint in our main loop, outside of <code>WM_PAINT</code>. But we'll get there later.</div>

</p><p>

Let's introduce a function which we will call <code>Win32UpdateWindow</code>. For this function to work, we can imagine we'll need the device context and the client rect (<code>X, Y, Width</code> and <code>Height</code> we calculated). We then can call it in our <code>WM_PAINT</code>. Let's also remove all the temporary code used for <code>PatBlt</code>:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32ResizeDIBSection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> Width, <span class="hljs-keyword">int</span> Height)</span></span>
<span class="line"></span>{</span>
<span class="line">}</span><div class=" add"><span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32UpdateWindow</span><span class="hljs-params">(HDC DeviceContext, <span class="hljs-keyword">int</span> X, <span class="hljs-keyword">int</span> Y, <span class="hljs-keyword">int</span> Width, <span class="hljs-keyword">int</span> Height)</span></span>
<span class="line"></span>{</span>
<span class="line">}</span></div><span class="line"></span>
<span class="line"><span class="hljs-comment">// Win32MainWindowCalback</span></span>
<span class="line">    <span class="hljs-comment">// ...</span></span>
<span class="line">    <span class="hljs-keyword">case</span> WM_PAINT:</span>
<span class="line">    {</span>
<span class="line">        PAINTSTRUCT Paint;</span>
<span class="line">        HDC DeviceContext = BeginPaint(Window, &amp;Paint);</span>
<span class="line"></span>
<span class="line">        <span class="hljs-keyword">int</span> X = Paint.rcPaint.left;</span>
<span class="line">        <span class="hljs-keyword">int</span> Y = Paint.rcPaint.top;</span>
<span class="line">        <span class="hljs-keyword">int</span> Width = Paint.rcPaint.right - Paint.rcPaint.left;</span>
<span class="line">        <span class="hljs-keyword">int</span> Height = Paint.rcPaint.bottom - Paint.rcPaint.top;</span><div class=" delete"><span class="line">        local_persist DWORD Operation = WHITENESS;</span>
<span class="line">        <span class="hljs-keyword">if</span> (Operation == WHITENESS)</span>
<span class="line">        {</span>
<span class="line">            Operation = BLACKNESS;</span>
<span class="line">        }</span>
<span class="line">        <span class="hljs-keyword">else</span></span>
<span class="line">        {</span>
<span class="line">            Operation = WHITENESS;</span>
<span class="line">        }</span>
<span class="line">        PatBlt(DeviceContext, X, Y, Width, Height, Operation);</span></div><div class=" add"><span class="line">        Win32UpdateWindow(DeviceContext, X, Y, Width, Height);</span>
<span class="line"></span>
<span class="line">        EndPaint(Window, &amp;Paint);</span></div><span class="line">    }<span class="hljs-keyword">break</span>;</span>
<span class="line">    <span class="hljs-comment">// ...</span></span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;11:</b> <file>[win32_handmade.cpp]</file> Introducing <code>Win32UpdateWindow</code>.</div></center>

<a class="target" name="implementlogic">&nbsp;</a><a class="target" name="implementlogic">&nbsp;</a><a class="target" name="toc4">&nbsp;</a><h1>Implement Logic</h1>
<p>


We now have 2 functions: <code>Win32ResizeDIBSection</code> and <code>Win32UpdateWindow</code>. But they don't do anything yet. Let's fix that: we know that one will be necessary to create or resize our DIB section, while the other will be used to output our buffer to window. We also have a rough idea what they should take.

</p><p>

A quick research on MSDN (using words as <code>Create</code>, <code>DIB</code>, etc.) leads us to two functions: <a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createdibsection">CreateDIBSection</a> and <a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-stretchdibits">StretchDIBits</a>. Let's start from the latter, and make our way to the former.

</p>
<a class="target" name="stretchdibitsimplementation">&nbsp;</a><a class="target" name="implementlogic/stretchdibitsimplementation">&nbsp;</a><a class="target" name="toc4.1">&nbsp;</a><h2><code>StretchDIBits</code> Implementation</h2>
<p>


<code>StretchDIBits</code> is a rectangle-to-rectangle image copy. If the destination rectangle is bigger, the image is increased, if not, shrunk down. 

</p><p>

<div class="admonition tip">Look up the function syntax on MSDN! If you can't find it, use <a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-stretchdibits">this link</a>.</div>

</p><p>

As you can see, the function takes quite a few parameters, but most of them are pretty straightforward.

</p><p>

<ul>
<li class="asterisk"><code>HDC</code>: handle to our device context. Just pass it in.
</li>
<li class="asterisk"><code>xDest, yDext, DestWidth, DestHeight</code>: These are the four parameters that we just got from our client <code>rect</code>. Again, just pass them in.
</li>
<li class="asterisk"><code>xSrc, ySrc, SrcWidth, SrcHeight</code>: These are the same parameters but for our source rectangle. For today it's the same exact rectangle as the client <code>rect</code>.
</li>
<li class="asterisk"><code>*lpBits</code> and <code>*lpbmi</code>: We can skip these for now.
</li>
<li class="asterisk"><code>iUsage</code>: specified what kind of buffer is passed (whether it's palettized or RBG). We'll use <code>DIB_RGB_COLORS</code>. 
</li>
<li class="asterisk"><code>rop</code>: raster operation code. This code allows to specify what do we want to do with the destination on bitwise level. We only want to copy from <code>Src</code>, so let's use <code>SRCCOPY</code> constant.</li></ul>

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32UpdateWindow</span><span class="hljs-params">(HDC DeviceContext, <span class="hljs-keyword">int</span> X, <span class="hljs-keyword">int</span> Y, <span class="hljs-keyword">int</span> Width, <span class="hljs-keyword">int</span> Height)</span></span>
<span class="line"></span>{</span><div class=" add"><span class="line">    StretchDIBits(DeviceContext, </span>
<span class="line">                  X, Y, Width, Height,</span>
<span class="line">                  X, Y, Width, Height,</span>
<span class="line">                  <span class="hljs-keyword">const</span> VOID       *lpBits, <span class="hljs-comment">// TODO!</span></span>
<span class="line">                  <span class="hljs-keyword">const</span> BITMAPINFO *lpbmi,  <span class="hljs-comment">// TODO!</span></span>
<span class="line">                  DIB_RGB_COLORS, SRCCOPY);    </span></div><span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;12:</b> <file>[win32_handmade.cpp > Win32UpdateWindow]</file> Filling out <code>StretchDIBits</code>.</div></center>
<p>


We don't really care about the return of this function. If it succeeds, it returns a non-zero value, so we could in theory capture it to ensure it went smoothly. We leave this as an excercise for the reader.

</p><p>

<div class="admonition note"><div class="admonition-title"> RGB and Palette colors</div>

</p><p>

    <div class="image" style="float:right;margin:4px 0px 0px 25px;"><a href="../media/day3/colorcop.png" target="_blank"><img class="markdeep" src="../media/day3/colorcop.png" /></a><center><span class="imagecaption"><a class="target" name="figure_x">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;2:</b> Color cop.</span></center></div>
    We assume that you have knowledge of how the RGB values work in computers. If you bring up a color picking utility, you will see that each color (in RGB mode) has a Red, Green and Blue component, each represented by a number from 0 to 255. 

</p><p>

    This is what's intended under RBG color mode. Each pixel is represented by a Red byte, a Green byte and a Blue byte per each pixel drawn.

</p><p>

    A Palette however is when you want to be more indirect (and potentially save buffer memory). For example, if you want to have 16 colors total in your image (from 0 to 15), in your buffer you will write just numbers, from 0 to 15, and have a &ldquo;palette&rdquo; passed somewhere together with your buffer, where each index has its corresponding RGB color. This is how, for example, a GIF image works, or &ldquo;Posterize&rdquo; effect in Photoshop.

</p><p>

    On the topic of color-picking utilities, we highly recommend one called <a href="http://colorcop.net/">Color Cop</a>. It's a lightweight utility which allows you to pick any color on the screen</div>

</p><p>

To conclude, we now miss the bitmap info and the actual buffer. And to get those, we need to go back to <code>Win32ResizeDIBSection</code> and <code>CreateDIBSection</code>.

</p>
<a class="target" name="createdibsectionimplementation">&nbsp;</a><a class="target" name="implementlogic/createdibsectionimplementation">&nbsp;</a><a class="target" name="toc4.2">&nbsp;</a><h2><code>CreateDIBSection</code> Implementation</h2>
<p>


Now, <code>CreateDIBSection</code>, the main call inside <code>Win32ResizeDIBSection</code>, may be even less straightforward than the <code>StretchDIBits</code> we just saw. 

</p><p>

From the get-go, we can fill out a few parameters:

</p><p>

<ul>
<li class="asterisk"><code>hdc</code>: Device Context, we'll get back to it.
</li>
<li class="asterisk"><code>*pbmi</code>: a pointer to a BITMAPINFO struct that we will need to fill out.
</li>
<li class="asterisk"><code>usage</code>: same thing as <code>iUsage</code> we've just seen, <code>DIB_RGB_COLORS</code>.
</li>
<li class="asterisk"><code>**ppvBits</code>: a pointer to a <code>void</code> pointer.
<ul>
    <li class="asterisk">It simply means that Windows will need an address of a <code>void *</code>. 
</li>
    <li class="asterisk">This <code>void *</code> will contain the address to our <code>BitmapMemory</code>, the reason for why we actually started this whole enterprise.
<ul>
        <li class="asterisk">To read more about the <code>void *</code>, check out <a href="#voidtype">void Type</a> subsection.
</li></ul>
</li></ul>
<li class="asterisk"><code>hSection</code>: As you can see from its description in MSDN, this is something we need to specify if we want to get fancy with our DIB section. We just need the memory, so <code>0</code> is fine.
</li>
<li class="asterisk"><code>offset</code>: An offset referencing the <code>hSection</code> above. We'll also leave it at <code>0</code>.</li></ul>

</p><p>

We will also make use of the handle that this function returns, so let's capture it, as well. 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32ResizeDIBSection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> Width, <span class="hljs-keyword">int</span> Height)</span></span>
<span class="line"></span>{</span><div class=" add"><span class="line">    BITMAPINFO BitmapInfo;</span>
<span class="line"></span>
<span class="line">    <span class="hljs-keyword">void</span> *BitmapMemory;</span>
<span class="line"></span>
<span class="line">    HBITMAP BitmapHandle = CreateDIBSection(DeviceContext, <span class="hljs-comment">// TODO</span></span>
<span class="line">                                            &amp;BitmapInfo,   <span class="hljs-comment">// TODO</span></span>
<span class="line">                                            DIB_RGB_COLORS,       </span>
<span class="line">                                            &amp;BitmapMemory, </span>
<span class="line">                                            <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span></div><span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;13:</b> <file>[win32_handmade.cpp > Win32ResizeDIBSection]</file> Drafting <code>CreateDIBSection</code>.</div></center>
<p>




<div class="admonition note"><div class="admonition-title"> Returning More Than One Value in C</div>

</p><p>

    Sometimes, you want a function to return more than one value. For instance, <code>CreateDIBSection</code> returns the bitmap handle but also a pointer to the bitmap memory. But, in C, you can only <em class="underscore">return</em> one thing. How would such a problem solved? 
        * One way would be to create a &ldquo;return variable&rdquo; before calling a function, and pass its <em class="underscore">address</em>. The function would then overwrite whatever value there was with the return value. This is how most of Windows API is implemented.
        * Another way would be packaging all the data in a custom &ldquo;response&rdquo; struct. If we were to implement CreateDIBSection, we might have a similar API as a result: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">create_dib_section_result</span></span>
<span class="line">{</span></span>
<span class="line">    HBITMAP Handle;</span>
<span class="line">    <span class="hljs-keyword">void</span> *Memory;</span>
<span class="line">};</span>
<span class="line"><span class="hljs-function">create_dib_section_result <span class="hljs-title">CreateDIBSection</span><span class="hljs-params">(DeviceContext, BitmapInfo, usage, etc, etc2)</span></span>;</span></code></pre><p>

    Of course, this might potentially create some issues if you return more than a few values, but then you'd need to re-evaluate if your function doesn't do too much work anyway. Additionally, this is a more recent way; before C was standardized in 1989, you could not return structs, so some older API still linger in the old ways before of legacy compatibility.</div>

</p>
<a class="target" name="filloutbitmapinfo">&nbsp;</a><a class="target" name="implementlogic/createdibsectionimplementation/filloutbitmapinfo">&nbsp;</a><a class="target" name="toc4.2.1">&nbsp;</a><h3>Fill Out <code>BITMAPINFO</code></h3>
<p>


The next thing that we are going to tackle is the <code>BitmapInfo</code>, a <code>BITMAPINFO</code> structure which we need to pass a pointer to. This is the structure which, at first, will be filled out by us. 

</p><p>

If you open the structure on <a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-bitmapinfo">MSDN</a> you will notice that it has only two components. That's not that bad, right? And we can safely ignore the <code>bmiColors</code> array as it's only relevant if we're in the Palette mode (which we are not).

</p><p>

However, if you open <a href="https://docs.microsoft.com/en-us/previous-versions/dd183376(v=vs.85)">documentation</a> for the <code>BITMAPINFOHEADER</code> structure you will be presented a more familiar wall of text. 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagBITMAPINFOHEADER</span> {</span></span>
<span class="line">  DWORD biSize;</span>
<span class="line">  LONG  biWidth;</span>
<span class="line">  LONG  biHeight;</span>
<span class="line">  WORD  biPlanes;</span>
<span class="line">  WORD  biBitCount;</span>
<span class="line">  DWORD biCompression;</span>
<span class="line">  DWORD biSizeImage;</span>
<span class="line">  LONG  biXPelsPerMeter;</span>
<span class="line">  LONG  biYPelsPerMeter;</span>
<span class="line">  DWORD biClrUsed;</span>
<span class="line">  DWORD biClrImportant;</span>
<span class="line">} BITMAPINFOHEADER, *PBITMAPINFOHEADER;</span></code></pre><center><div class="listingcaption tilde"><file>[MSDN]</file> <code>BITMAPINFOHEADER</code> structure syntax.</div></center>
<p>


We can fill it out directly by referencing it directly via the <code>BitmapInfo.bmiHeader</code> as follows: 

</p><p>

<ul>
<li class="asterisk"><code>biSize</code>: Size of the <code>bmiHeader</code> structure. We can easily calculate it by using a handy <code>sizeof</code> function.
</li>
<li class="asterisk"><code>biWidth, biHeight</code>: Width and Height of our DIB section
</li>
<li class="asterisk"><code>biPlanes</code>: This is an obsolete value which by now should always be <code>1</code>. 
<ul>
    <li class="asterisk">In the past, it was used when multiple chunks of memory were combined to get the required color. 
</li></ul>
<li class="asterisk"><code>biBitCount</code>: How many <em class="underscore">bits per pixel</em> we will use. We will have 3 bytes of color (1 for Red, Green an Blue channels), so each byte being 8 bits, we'd need 24 of them... but we'll ask for <code>32</code> for the reasons which will become clearer later down the line (spoiler: it has to do with alignment). 
</li>
<li class="asterisk"><code>biCompression</code>: What type of compression we want. Since we don't want our image to be compressed at all (we want the fastest thing possible), we indicate <code>BI_RGB</code>.</li></ul>

</p><p>

We don't care about the remaining parameters, so let's just <em class="underscore">clear to zero</em> the whole struct upon initialization.

</p><pre class="listing tilde"><code><div class=" edit"><span class="line">BITMAPINFO BitmapInfo = {};</span></div><div class=" add"><span class="line">BitmapInfo.bmiHeader.biSize = <span class="hljs-keyword">sizeof</span>(BitmapInfo.bmiHeader);</span>
<span class="line">BitmapInfo.bmiHeader.biWidth = Width;</span>
<span class="line">BitmapInfo.bmiHeader.biHeight = Height;</span>
<span class="line">BitmapInfo.bmiHeader.biPlanes = <span class="hljs-number">1</span>;</span>
<span class="line">BitmapInfo.bmiHeader.biBitCount = <span class="hljs-number">32</span>;</span>
<span class="line">BitmapInfo.bmiHeader.biCompression = BI_RGB;</span></div><span class="line"></span>
<span class="line"><span class="hljs-keyword">void</span> *BitmapMemory;</span>
<span class="line"></span>
<span class="line">HBITMAP BitmapHandle = CreateDIBSection(DeviceContext,       <span class="hljs-comment">// TODO</span></span><div class=" edit"><span class="line">                                        &amp;BitmapInfo,</span></div><span class="line">                                        DIB_RGB_COLORS,       </span>
<span class="line">                                        &amp;BitmapMemory, </span>
<span class="line">                                        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;14:</b> <file>[win32_handmade.cpp > Win32ResizeDIBSection]</file> Specifying <code>BitmapInfo</code>.</div></center>

<a class="target" name="decideonmemoryallocation">&nbsp;</a><a class="target" name="implementlogic/createdibsectionimplementation/decideonmemoryallocation">&nbsp;</a><a class="target" name="toc4.2.2">&nbsp;</a><h3>Decide on Memory Allocation</h3>
<p>


Now, let's remember that we will allocate a <strong class="asterisk">new</strong> buffer each time that we resize our window. This can potentially be very bad as our application could explode in memory consumption very quickly if we aren't careful. We need to free the memory that we're getting. Now here comes a dilemma: 

</p><p>

<ul>
<li class="asterisk">We could try and free a DIB section each time before we create a new DIB section, or
</li>
<li class="asterisk">We can wait and see if we can get a new DIB section first, and if we can't, try to free an already existing one.</li></ul>

</p><p>

Both scenarios are not ideal, but let's go for the first one. We're running a risk to find no BitmapMemory to free to begin with (and we can therefore crash), but it's still better than potentially creating memory leaks. Plus we can &ldquo;bulletproof&rdquo; this later.

</p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-comment">// TODO(casey): Bulletproof this.</span></span>
<span class="line"><span class="hljs-comment">// Maybe don't free first, free after, then free first if that fails.</span></span>
<span class="line"></span>
<span class="line"><span class="hljs-comment">// TODO(casey): Free our DIBSection</span></span></div><span class="line">BITMAPINFO BitmapInfo = {};</span>
<span class="line"><span class="hljs-comment">// ...</span></span>
<span class="line"><span class="hljs-keyword">void</span> *BitmapMemory;</span>
<span class="line"></span>
<span class="line">HBITMAP BitmapHandle = CreateDIBSection(DeviceContext,       <span class="hljs-comment">// TODO</span></span>
<span class="line">                                        &amp;BitmapInfo,</span>
<span class="line">                                        DIB_RGB_COLORS,       </span>
<span class="line">                                        &amp;BitmapMemory, </span>
<span class="line">                                        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;15:</b> <file>[win32_handmade.cpp > Win32ResizeDIBSection]</file> Specifying <code>BitmapInfo</code>.</div></center>
<p>


We'll return to this in a minute.

</p>
<a class="target" name="extractmoreglobalvariables">&nbsp;</a><a class="target" name="implementlogic/createdibsectionimplementation/extractmoreglobalvariables">&nbsp;</a><a class="target" name="toc4.2.3">&nbsp;</a><h3>Extract More Global Variables</h3>
<p>


Now, we will need some information shared by both of these parties. The simplest solution (that we'll go for now) is to take it out as <code>global_variables</code>. We will pull out <code>BitmapInfo, BitmapMemory</code> and <code>BitmapHandle</code>.

</p><p>

This has also an added benefit that they will be initialized to <code>0</code> automatically.

</p><pre class="listing tilde"><code><span class="line">global_variable <span class="hljs-keyword">bool</span> Running;</span><div class=" add"><span class="line">global_variable BITMAPINFO BitmapInfo;</span>
<span class="line">global_variable <span class="hljs-keyword">void</span> *BitmapMemory;</span>
<span class="line">global_variable HBITMAP BitmapHandle;</span></div><span class="line"></span>
<span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32ResizeDIBSection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> Width, <span class="hljs-keyword">int</span> Height)</span></span>
<span class="line"></span>{</span>
<span class="line">    <span class="hljs-comment">// ...</span></span>
<span class="line">    <span class="hljs-comment">// TODO(casey): Free our DIBSection</span></span><div class=" delete"><span class="line">    BITMAPINFO BitmapInfo = {};</span>
<span class="line">    <span class="hljs-keyword">void</span> *BitmapMemory;</span></div><span class="line">    <span class="hljs-comment">// ...</span></span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;16:</b> <file>[win32_handmade.cpp]</file> Expanding the scope of key variables.</div></center>

<a class="target" name="freememory">&nbsp;</a><a class="target" name="implementlogic/createdibsectionimplementation/freememory">&nbsp;</a><a class="target" name="toc4.2.4">&nbsp;</a><h3>Free Memory</h3>
<p>


Now we can also free up our buffer memory if it's already occupied! Simply check if <code>BitmapHandle</code> exists, if not, call <a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deleteobject">DeleteObject</a> on it.

</p><pre class="listing tilde"><code><div class=" delete"><span class="line"><span class="hljs-comment">// TODO(casey): Free our DIBSection</span></span></div><div class=" add"><span class="line"><span class="hljs-keyword">if</span> (BitmapHandle)</span>
<span class="line">{</span>
<span class="line">    DeleteObject(BitmapHandle);</span>
<span class="line">}</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;17:</b> <file>[win32_handmade.cpp > Win32CreateDIBSection]</file> Freeing memory if we previously created a buffer.</div></center>

<a class="target" name="getthedevicecontext">&nbsp;</a><a class="target" name="implementlogic/createdibsectionimplementation/getthedevicecontext">&nbsp;</a><a class="target" name="toc4.2.5">&nbsp;</a><h3>Get the Device Context</h3>
<p>


The last thing that we have to figure out is where do we get the <code>DeviceContext</code> from. The Device Context that we need to get should be something suitable for drawing bitmaps into. 

</p><p>

This can be achieved by asking Windows to create a DC compatible with the device we're trying to use. This is important because, even if we're not drawing with the device context, we still need one to give us a compatible buffer. The call for it is called <a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createcompatibledc">CreateCompatibleDC</a>. 

</p><p>

Since this DC is created for us to use, we might as well store it as a global variable. Moreover, we can only initialize it on the first run, or if we find that this device context was somehow lost. In theory, we won't ever have to release this DC. Let's take a mental (and a physical) note of it however so that we don't lose track of it as we move along:

</p><p>

For consistency, let's also rename it to <code>BitmapDeviceContext</code>:

</p><pre class="listing tilde"><code><span class="line">global_variable BITMAPINFO BitmapInfo;</span>
<span class="line">global_variable <span class="hljs-keyword">void</span> *BitmapMemory;</span>
<span class="line">global_variable HBITMAP BitmapHandle;</span><div class=" add"><span class="line">global_variable HDC BitmapDeviceContext;</span></div><span class="line"></span>
<span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32ResizeDIBSection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> Width, <span class="hljs-keyword">int</span> Height)</span></span>
<span class="line"></span>{</span>
<span class="line">    <span class="hljs-comment">// ...</span></span>
<span class="line">    <span class="hljs-keyword">if</span> (BitmapHandle)</span>
<span class="line">    {</span>
<span class="line">        DeleteObject(BitmapHandle);</span>
<span class="line">    }</span>
<span class="line">    </span><div class=" add"><span class="line">    <span class="hljs-keyword">if</span>(!BitmapDeviceContext)</span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-comment">// TODO(casey): Should we recreate these under certain special circumstances? </span></span>
<span class="line">        BitmapDeviceContext = CreateCompatibleDC(<span class="hljs-number">0</span>);</span>
<span class="line">    }</span></div><span class="line">    </span><div class=" edit"><span class="line">        BitmapHandle = CreateDIBSection(BitmapDeviceContext,</span></div><span class="line">                                        &amp;BitmapInfo,</span>
<span class="line">                                        DIB_RGB_COLORS,       </span>
<span class="line">                                        &amp;BitmapMemory, </span>
<span class="line">                                        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;18:</b> <file>[win32_handmade.cpp > Win32CreateDIBSection]</file> Creating Device Context</div></center>
<p>




<div class="admonition note"><div class="admonition-title"> Not (<code>!</code>) operator</div>

</p><p>

    In C, exclamation mark (<code>!</code>) at the beginning of a boolean value serves to invert it. For example, <code>!true</code> means <code>false</code>, and the contrary. 

</p><p>

    In this case, we check if we <em class="underscore">don't</em> have a device context. Only if our <code>BitmapDeviceContext</code> is <code>0</code> it gets converted to <code>1</code> and thus we step into the <code>if</code> code block to create a new DC.</div>

</p>
<a class="target" name="finishwin32updatewindow">&nbsp;</a><a class="target" name="implementlogic/finishwin32updatewindow">&nbsp;</a><a class="target" name="toc4.3">&nbsp;</a><h2>Finish <code>Win32UpdateWindow</code></h2>
<p>


We now have everything in place on one side - let's hook it up to the other side. Fill out the remaining couple parameters in <code>StretchDIBits</code> with the values we put as global. Remember that we need to pass the <code>pointer</code> (address using <code>&amp;</code>) to our BitmapInfo!

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32UpdateWindow</span><span class="hljs-params">(HDC DeviceContext, <span class="hljs-keyword">int</span> X, <span class="hljs-keyword">int</span> Y, <span class="hljs-keyword">int</span> Width, <span class="hljs-keyword">int</span> Height)</span></span>
<span class="line"></span>{</span>
<span class="line">    StretchDIBits(DeviceContext, </span>
<span class="line">                  X, Y, Width, Height,</span>
<span class="line">                  X, Y, Width, Height,</span><div class=" edit"><span class="line">                  BitmapMemory,</span>
<span class="line">                  &amp;BitmapInfo,</span></div><span class="line">                  DIB_RGB_COLORS, SRCCOPY);    </span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;19:</b> <file>[win32_handmade.cpp > Win32UpdateWindow]</file> Hooking things up</div></center>

<a class="target" name="inspectyourwork">&nbsp;</a><a class="target" name="inspectyourwork">&nbsp;</a><a class="target" name="toc5">&nbsp;</a><h1>Inspect Your Work</h1>
<p>


This should be it, we should be compilable! If you run now, you should see a black square in your <code>ClientRect</code>. Let's step through the code to see if everything behaves as we expect it to: 

</p><p>

<ol start=1>
<li class="number">Set up your breakpoint at the beginning of the <code>WM_SIZE</code> case in your <code>Win32MainWindowCallback</code>. 
</li>
<li class="number">Start debugging. 
<ul>
    <li class="asterisk">The program will initialize the window and start receiving the messages. 
</li>
    <li class="asterisk">At one point it will hit <code>WM_SIZE</code> call and stop at your breakpoint.
</li></ul>
<li class="number">Navigate using <code>F10</code> to step <em class="underscore">over</em> some functions (like <code>GetClientRect</code>) and <code>F11</code> to step <em class="underscore">into</em> them.
</li>
<li class="number">In the <code>Watch</code> window, type in <code>Width</code> and <code>Height</code> to inspect the <code>Width</code> and <code>Height</code> variables, once you calculate them. Compare them with the data in the <code>ClientRect</code>.</li></ol>

</p><p>

<center><div class="image" style=""><a href="../media/day3/debug1.png" target="_blank"><img class="markdeep" src="../media/day3/debug1.png" /></a><center><span class="imagecaption"><a class="target" name="figure_x">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;3:</b> Inspecting the variables. Note <code>Width</code> and <code>Height</code> in the <code>Watch</code> window, as well as current position in the <code>Call Stack</code>.</span></center></div></center>

</p><p>

<ol start=5>
<li class="number">Once you step into <code>Win32ResizeDIBSection</code> (<code>F11</code>):
<ol start=1>
    <li class="number">If it's the first time you hit <code>WM_SIZE</code> you shouldn't have a <code>BitmapHandle</code> so you skip memory freeing.
</li>
    <li class="number">You also won't have the <code>BitmapDeviceContext</code>, so you'll try and get it using <code>CreateCompatibleDC</code>. Inspect <code>BitmapDeviceContext</code> to make sure it's a valid handle (shouldn't be <code>0</code>).
</li>
    <li class="number">You then fill out the <code>BitmapInfo</code>. You can inspect it as well to make sure it's filled out as expected.
</li>
    <li class="number">Last, we call <code>CreateDIBSection</code>. If you step over it (<code>F10</code>) you should expect getting a) a <code>BitmapHandle</code> and b) a <code>BitmapMemory</code> pointer.
</li></ol>
<li class="number">Release all the breakpoints and get the program running. Open the Task Manager (<code>Ctrl-Shift-Esc</code>) &rarr; Details section. Find your process (<code>win32_handmade.exe</code>) and check its memory footprint. Resize your window many times and make sure the memory doesn't explode in size (&ldquo;leaking memory&rdquo;).
<ul>
    <li class="asterisk">You can see the memory in the <code>Working Set (Memory)</code> and <code>Commit Size</code> columns. 
</li>
    <li class="asterisk">If you don't see these columns, you can right click the existing ones and choose the menu option &ldquo;Select columns&rdquo;.</li></ul></li></ol>

</p><p>

If you got all these steps correct, congratulations! This is a complex road you have embarked upon, and it's fine to make mistakes along the way. This is fine, as during their correction they become happy accidents where you learn something new in a place where you least expected to.

</p>
<a class="target" name="recap">&nbsp;</a><a class="target" name="recap">&nbsp;</a><a class="target" name="toc6">&nbsp;</a><h1>Recap</h1>
<p>


We covered a lot of ground here. We got a more robust way of closing our window, and learned about different meanings of <code>static</code> keyword. After this, we roughly planned and sketched our next steps and we got them completed! You now have your own buffer to write into. Unfortunately, it's still sad and empty, but we will fix that tomorrow.

</p><p>

In the next chapter, we will start animating our buffer with our own data.

</p><p>

<hr/>

</p><p>

<div class="endnote"><a class="target" name="endnote-bitmap">&nbsp;</a><sup>1</sup> In reality it's <em class="underscore">slightly</em> more complicated than this but we'll get there soon, and you get the point.
</div>
</p><p>

<div class="endnote"><a class="target" name="endnote-fullscreen">&nbsp;</a><sup>2</sup> This will not matter once we go into fullscreen mode, but until then, we have to accept the window borders that we have to take into account.
</div>
</p>
<a class="target" name="exercises">&nbsp;</a><a class="target" name="exercises">&nbsp;</a><a class="target" name="toc7">&nbsp;</a><h1>Exercises</h1>

<a class="target" name="experimentwiththedebugger">&nbsp;</a><a class="target" name="exercises/experimentwiththedebugger">&nbsp;</a><a class="target" name="toc7.1">&nbsp;</a><h2>Experiment with the Debugger</h2>
<p>


Start a debug session. Step in your code, inspect different variables into your <code>Watch</code> window. Navigate your program through the <code>Call Stack</code> by double-clicking the previous calls. Check your <code>Output</code>. Try to see how your data looks by inserting various pointers at your disposal in the <code>Memory</code> window.

</p>
<a class="target" name="peekingintoassemblylanguage">&nbsp;</a><a class="target" name="exercises/peekingintoassemblylanguage">&nbsp;</a><a class="target" name="toc7.2">&nbsp;</a><h2>Peeking into Assembly Language</h2>
<p>


If you end up in the <code>Disassembly</code> (by stepping into a function you don't have code for) try to see what's going on there. Each line represents machine instructions as converted from the C code, written in the language called <code>assembly</code>, and you can learn more about it <a href="https://en.wikipedia.org/wiki/Assembly_language">here</a>. You can also watch an excellent video on the matter <a href="https://www.youtube.com/watch?v=yOyaJXpAYZQ">here</a>. 

</p>
<a class="target" name="programmingbasics">&nbsp;</a><a class="target" name="programmingbasics">&nbsp;</a><a class="target" name="toc8">&nbsp;</a><h1>Programming Basics</h1>

<a class="target" name="aboutresourcehandling">&nbsp;</a><a class="target" name="programmingbasics/aboutresourcehandling">&nbsp;</a><a class="target" name="toc8.1">&nbsp;</a><h2>About Resource Handling</h2>
<p>


If you have experience programming in an Object-Oriented languages like C++ of Java, you might be asking: what about closing our window? 

</p><p>

When programming in Object-Oriented languages, people usually make extreme care in making sure they have completely symmetric construction and destruction (or aquisition and release) of their resources. Some programmers know it as <b>R</b>esource <b>A</b>cquisition <b>I</b>s <b>I</b>nitialization (or RAII), others wrap it inside class Constructors and Distructors, but it all boils down to a rather simple concept. This means every time you make something, such as <code>CreateWindowEx</code> or <code>RegisterClass</code>, you want to make sure: if there is some way to clean up, you do so.

</p><p>

As an example we've seen in our program, in <code>WM_PAINT</code>, where there is <code>BeginPaint</code>, there should be a correspondent <code>EndPaint</code> somewhere along the line. However, we registered a window class and opened a window with no intention of cleaning it up, and it would be a no-go for RAII. Why so?

</p><p>

The problem with this pattern is it sounds good on paper or on test dummy projects, but it's less than ideal in real world applications. If you care about performance and many other things, you will quickly discover it's almost always better that resources are acquired and released in <em class="underscore">aggregate</em>. 

</p><p>

Instead of thinking about things individually, you should think about them as a part of a group bundled together. As a result, you will notice that resources are better acquired and released in <em class="underscore">waves</em>. You don't have to worry about what this means for now: we're going to get into those things much later, when we have more resources to deal with. 

</p><p>

Back to the present, we're creating a window which we know will be running for the rest of our game's execution. When we exit the application, Windows will clean up all of our windows, handles, memory, etc. So if we actually ask to close our window before we exit, we're wasting the user's time. 

</p><p>

If you ever encountered those applications that you try to close, and it takes a while to close down, you know what we are talking about here. Those programs try to close everything manually, tidy everything up... things that, if they would be thought about in waves, would be gone right away.

</p><p>

<em class="underscore">(Back to Subsection  <a href="#toc1.1">1.1</a>)</em>

</p>
<a class="target" name="definedirective">&nbsp;</a><a class="target" name="programmingbasics/definedirective">&nbsp;</a><a class="target" name="toc8.2">&nbsp;</a><h2>Define Directive</h2>
<p>


<code>#define</code> is a so-called &ldquo;preprocessor directive&rdquo; (it's in the same family as <code>#include</code> above). It has a syntax of <code>#define NAME value</code> and serves for <em class="underscore">macro definition</em>. That is, you designate <code>NAME</code> as a <em class="underscore">macro</em>, and whenever you type <code>NAME</code> in your code the compiler simply reads it as <code>value</code>.

</p><p>

In its simplest form, it works the following way: 

</p><pre class="listing tilde"><code><span class="line"></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Pi32 3.1415926535 </span></span>
<span class="line"></span>
<span class="line"><span class="hljs-comment">// later in your code</span></span>
<span class="line"></span>
<span class="line">x = x * Pi32; <span class="hljs-comment">// Compiler sees it as "x = x * 3.1415926535;"</span></span>
<span class="line"></span></code></pre><p>

A more advanced form would be using parameters <code>#define SOMETHING(param)</code>, where <code>param</code> is an arbitrary number of parameters you can pass to the macro. Note the absence of space between the name and the parenthesis.

</p><pre class="listing tilde"><code><span class="line"></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Square(number) (number * number)</span></span>
<span class="line"></span>
<span class="line"><span class="hljs-comment">// later in your code</span></span>
<span class="line"></span>
<span class="line">x = Square(x); <span class="hljs-comment">// Compiler sees it as "x = (x * x);"</span></span>
<span class="line"></span></code></pre><p>

As a preprocessor directive, <code>#define</code> is translated before the rest of the code. This enables us to do various tricks to achieve our goals.

</p><p>

<em class="underscore">(Back to Section  <a href="#toc2">2</a>)</em>

</p>
<a class="target" name="voidtype">&nbsp;</a><a class="target" name="programmingbasics/voidtype">&nbsp;</a><a class="target" name="toc8.3">&nbsp;</a><h2>void Type</h2>
<p>


A <code>void</code> is a very special type in C. 

</p><p>

<ul>
<li class="asterisk">If it's a return from a function, it simply means nothing. Moreover, you will receive an error if you try to return from a <code>void</code> function.
</li>
<li class="asterisk">If you don't have any parameters to pass to a function, in C you also used to type <code>void</code> as a parameter (in more recent versions of C it's no longer necessary, and it's been deprecated in C++). 
</li>
<li class="asterisk">Finally, a <code>void *</code> (&ldquo;void pointer&rdquo;) variable is a pointer to raw memory, without any &ldquo;type&rdquo; associated with it. Compiler doesn't care what type of data does this pointer points to, any address is fine. 
<ul>
    <li class="asterisk">This is useful when you don't know the format of the data you're getting, for example from some opaque API which ends up consuming the same pointer later on. 
</li>
    <li class="asterisk">Alternatively, if you know what data does it point to, you can <em class="underscore">cast</em> it to the type of your choice. In our case, we will use the <code>BitmapMemory</code> to cast it as several different types, depending on the operation we're doing.</li></ul></li></ul>

</p><p>

<em class="underscore">(back to Subsection  <a href="#toc4.2">4.2</a>)</em>

</p>
<a class="target" name="sideconsiderations">&nbsp;</a><a class="target" name="sideconsiderations">&nbsp;</a><a class="target" name="toc9">&nbsp;</a><h1>Side Considerations</h1>

<a class="target" name="aboutglobalvariables">&nbsp;</a><a class="target" name="sideconsiderations/aboutglobalvariables">&nbsp;</a><a class="target" name="toc9.1">&nbsp;</a><h2>About Global Variables</h2>
<p>


In the programming world, the usage of global variables is generally being frowned upon. And, while we don't agree that their usage should be avoided at all costs, there's a reason while such an adversity exists. Many of the common critisisms of the global variables are totally valid, and here is how we are going to try and go around them: 

</p><p>

<ul>
<li class="asterisk">Prevent the code from &ldquo;touching&rdquo; variables it shouldn't
</li>
<li class="asterisk">Make our code clear about what it can and cannot access</li></ul>

</p><p>

This is where global variables pose a problem. Since everyone can change their value, tracking those changes may become difficult. In this case, the risk is small since the <code>Running</code> variable is totally harmless (it controls the exit from the main loop and nothing else). Additionally, because of how Windows API is constructed our code will always be somewhat &ldquo;janky&rdquo;, globals are somewhat inevitable in the Win32 platform layer. Most of our code will not be in that layer, and most of our code will not be touching any Win32 platform globals (or even be aware of its existence). Even then, we will probably move <code>Running</code> somewhere outside at some point. 

</p><p>

That said, it's a totally valid strategy of using globals while you are levelling up your code during the development, as long as that usage is cleaned up by the time the codebase is solidified, and we are ready to ship our code. 

</p><p>

<em class="underscore">(Continue to Section  <a href="#toc2.2">2.2</a>)</em>

</p>
<a class="target" name="navigation">&nbsp;</a><a class="target" name="navigation">&nbsp;</a><a class="target" name="toc10">&nbsp;</a><h1>Navigation</h1>
<p>


Previous: <a href="day2.html">Day 2. Opening a Win32 Window</a>

</p><p>

Up Next: <a href="day4.html">Day 4. Animating the Back buffer</a>

</p><p>

<a href="../index.md.html">Back to Index</a>

</p>
<div class="nonumberh1">Glossary</div>
<p>


<ul>
<li class="asterisk">Define
</li>
<li class="asterisk">Memory Allocation
</li>
<li class="asterisk">Memory Leaks
</li>
<li class="asterisk">Translation Unit</li></ul>

</p>
<div class="nonumberh1">References</div>
<p>


<a href="http://colorcop.net/">Color Cop</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-bitmapinfo">BITMAPINFO structure</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/previous-versions/dd183376(v=vs.85)">BITMAPINFOHEADER structure</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createdibsection">CreateDIBSection</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroywindow">DestroyWindow</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deleteobject">DeleteObject</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getclientrect">GetClientRect</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createcompatibledc">CreateCompatibleDC</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postquitmessage">PostQuitMessage</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-stretchdibits">StretchDIBits</a>

</p><p>

<style class="fallback">
  body {
    visibility: hidden;
    font-family: sans-serif;
  }
</style>

</p><p>

<script>markdeepOptions = { tocStyle: 'long' }; window.alreadyProcessedMarkdeep || (document.body.style.visibility = 'visible');</script>
</windows.h></windows.h></windows.h></p></span><div id="mdContextMenu" style="visibility:hidden"></div><div class="markdeepFooter"><i>formatted by <a href="https://casual-effects.com/markdeep" style="color:#999">Markdeep&nbsp;1.10&nbsp;&nbsp;</a></i><div style="display:inline-block;font-size:13px;font-family:'Times New Roman',serif;vertical-align:middle;transform:translate(-3px,-1px)rotate(135deg);">&#x2712;</div></div>