{\rtf1\ansi\ansicpg1252\cocoartf2759
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 No really good in the full stack of the game because it just makes a lot more powerful and basically you know let you have complete control when you need it. Let you know that no matter what happens you can always go down to the you can always go make your own stuff if you need to work around something because you k makes else I'm having a blast so far and we finally got what I think is much more fun things we spent 25 hours worth of time working out ourselves so we have something to make but we have done that and now we are in a position to make our game and we have the shipping of the platform for purposes of getting the game running and developing the game to a certain point so with that in mind today I would like to actually start doing the game development proper which I think is really cool cause that's gonna be a lot more fun than monkey so if you pre-ordered the game, you should have gotten a link an email with a link in it. That email link will download the source code and the code comes as a giant file which has every day so if you wanna follow along we are on 2726 source that is what I'm starting. Previous exactly where I am starting right now OK so first thing first let's go to the little diagram I did a bunch of talking yesterday just to kind of get everyone on the same page about what architects are and that sort of stuff and today I wanna talk very briefly maybe spend about 10 minutes here talking about how we go about the fact that a lot of things typically happen with crazy like upfront architecture, and all that stuff is is basically like confusing, and perhaps nonproductive way to go about things, so I kinda wanted people to understand what sort of what the basic concepts of architecture are sort of like how to approach how to think about it in your mind, but we didn't do any architecture yesterday, or any sort of work like that didn't really explain how we would go about that first part of the stream explain that part of it and then start doing what we're trying to do and how I think about the process of doing it and then we will do it and then this will be a continues for like essentially the entire length of the stream where we're constantly sort of thinking about so I want to introduce you my lecture API design for understanding the way that develop overtime is put on your imagination like a fantasy like unicorns running around and trolls bridges and I don't know Pegasus certainly would be there and I know it sounds a little fancy, but all I wanna do is just have a geometric representation just some representation of saying you are here on a project of a project, which self-contained so the starting point for the actual game of the game in the game itself that is what we're starting today essentially think about it as kind of like you are here kind of a thing where we have absolutely nothing we have nothing right and in our imaginary state, there is some like state up here, right which is what we will ship right so there's some you know, imaginary geography of projects and in the state of the project what's in it and design all that stuff where we start somewhere and we go and we end up somewhere else right and that somewhere is that project now as anyone who ever knows doesn't look like a straight right it's not like you start with nothing you know this is this is your project and this is you know who knows what 700 or something you're talking about OK it's a linear path every day I do a little bit of that's not at all if you think about projects there's often there's a lot of this sort of thing that happens like you know there's there's all sorts of meandering and you go around and you know you you make changes that maybe you even further away and that was a mistake and you come back and that's eventually it's not often don't even know what this thing looks like. You don't have a perfect vision for exactly what the code looks like you have nothing and you have a vague idea if it's a you don't really have an idea of what that looks like so what I want to talk about, how to conceptualize what you are doing every day in that drive as far as degree as far as individual talking about the fact that when you were at a particular time, it doesn't have to be day could be any day we could be somewhere a little further along, you know, maybe on day or something at any point you think about what you're going to do towards some new location in the state and you don't actually know where this is you don't know the actual ending of this right you just have some big notion and maybe you have a range. I think the shit kinda looks a little bit like something that would be in here where that destination is so you might aim for something over here and then when you start to kind of get towards it maybe you realize that what you really needed was the shipping right where I'm at you have no idea where that final piece of structure looks like sort of doing is doing like a dead and going OK from where I'm at now and given the code that I'm trying to write right now whatever it is like. I'm trying to upgrade the object system because it can't handle some of the things that we want to do in the design right no and what you're doing when you sit down for the day towards some point right in the state you're kind of like going towards something depending on that and then when you finish that you're gonna do the same thing again you're gonna choose to do something and that something drives you in a direction that way you kind of build this path that sor shit and you are with your dead wasted less switchbacks there are less going on here again I think that sort of cement what's going on here the reason that I really like programming see how it works at the low level and try to specifically because preplan assumes, you know what this thing looks like already you know what the code is going to look like because if you have to do a bunch of planning on how the code will go the whole way you basically have to say I know where this is and I'm making the waypoint along the way that we're g if you don't know what this is, there's really no way to do these right so usually what happens but people do a lot of upfront design is totally wrong stuff they're like OK this is how this is our path it's gonna be great we just go to here and then we go to here we go here and then we ship it and when you by the time you get here you're like this is a disaster. This is awful design of the architecture and either you end up shipping something kind of crappy and not even close to what probably would've been optimal or at some point you realize your mistakes and you try to start correcting right upfront design is basically putting in waypoint on this map but you're putting in waypoint when you don't know the destination and that just doesn't work right it just plain doesn't work so what I want to encourage, and the way we will be approaching everything and we've already been approaching this way to a large extent although like so many times I kind of know what the result is I do know what this is, so I could kind of like I said that isn't an interesting architectural problem because that's more like just couldn't past your break. It's not even a waypoint I know what skills that I hope to encourage to develop over the course of the stream is what to do when you don't when you haven't written the thing before that's the hard thing that's where the real architecture because if you've already written it many times before and you're totally ex learn how to do it on how to encourage is not to set those bogus points not to look too far ahead, so what we are constantly going to do is we're constantly going to basically take a sort of an explore and then approach we're basically going to do the opposite of that waypoint instead of picking a set of things that we think are the directions to go rig wrong we're going to explore around the space and we're going to see what we find him that we find something that we feel is along the path to shipping. We will lock that in and make that our new location and then we will repeat the process right so constantly going to I don, so we are going to look at things as this stage which is where we are that are just us whatever comes to mind for the thing that we need to implement so if we need to tile map today or whatever it is we're just gonna try to tile with the architecture we're gonna explore and see what works in t we find that we are happy with. We think that we're gonna start from now and then the next problem we do is basically assume that there is sort of a gradient along the path shipping that you can learn to sense as you gain good programming skills that you could learn. Architecture are good and bad and you can basically say th appears to be good at this and this is fair and this is like bad you know and then this is like audit OK I'm kidding I'm kidding I'm sorry you know generally have more experience with general. You will learn how to do this sort of sensing of where you are so that you can pass these things even though you don't know the destination by doing an exploration and accepting step right when you do architecture that are that you've never done before for things that you've never done before you can still leverage all of the experience you've had doing other things to get you to a good point, so that kind of model I want you to think about in your head. I don't think you can do waypoint for an architecture you've never done before I've never seen it and I just don't think it probably does but what you can do is once you learn to where you are and you constantly kind of course to stay in that trough of good design all the way to the end so that minimize the degrees out into the bad areas that you would've had if you know you predefined your waypoint to be here and drove it, and just had the whole time, so this is how I want you to conceptualize. We are doing a right goal constantly with a rear channel and we sent ourselves going outside. We just got back. Make sure we stay there OK this is all hypothetical. This is all my programming no one has ever proved, or analyze any of this thing. Nobody whoever does design ever proves or analyze anything so we have no formalism to back us up, but neither does anyone else and so all I can say is my experience. This has been the truest thing I have ever found, in terms of conceptual developing , let's get started quickly. We are in terms. In a world that had a lot of richness and interest in it, but didn't give you any constraints or dictates about what you were trying to do. There wasn't like this you know a little fairy that shows up like there are leaders, Zelos who like don't go into that forest yet cause you're not ready to go there first blacksmith sword but I can't because I don't have any water for my wheel. The ferry popped up and we get like those kind of ruins Zelda for me and I appreciate the fact that game design is obviously personal preference so there's probably lots of people who like that sort of thing and that's fine so I don't wanna say that that's bad and like I said, I am a game designer, so I'm not trying to. I'm not trying to tell you any from any kind but personally that really ruins me anymore because what I liked about that very original one that very first Zelda was that sort of that feeling of exploration that you get when you really just have no idea what's coming next and you know you have the freedom to think about what you want to do on your own and that is the sort of core concept that I want in the game that is the main thing that I'm going for and I want kind of legend of Zelda is a very classic game written in the classic style there you know obviously it was a very limited system. I think it's kind of appropriate for handmade kind of mo is OK. What would we do though if we want kind of modernized everything that goes on in one of those kind of old games where I have you know spray guy who walks around the handholding approach I've been working on sort of talking about later. I want a bunch of things that are going to support me in making that kind of experience, so what I do wanna do right is I wanna have a way for us to make a tile map kind of thing I wanna be able to make screens that are like th, I wanna be able to make that kind of a game where it has a feel of the old sort of classics but I don't really wanna have to do tile graphics right I don't I feel like graphics are possibly something that doesn't really need to be preserved from the old days I think that that was mostly just because that's what they could do. I don't think that necessarily needs to be in a modern game design for the game design to be g I do however, think there's something perhaps important about the map design like the player understanding that they are on a tile map and that like if this tile is blocked and this tile is blocked and there's a push thing here that you know they can push it this way and it ends up here that leads to important understanding of puzzles, and like it simplifies things in the mind of the player in a way that's kind of important where if I just said OK, scrap the whole tile map thing entirely and we're just gonna have a free floating world. You know where everything is just at X position so if there's something to push it's here I just don't feel like that is work as well. I feel like there's something concrete and that gets lost when you try to go a little too far in the direction of completely generic so basically I am going to try and design our engine to do is to create a playable game on a tile map, but the tile map is not render directly as a tile map it's rendered as something a little more flexible than a tile map it just takes sort of the shape of a tile so that you don't see like big obvious repeating tiles where it's like OK here's the like one tree that we had and here's the tree agai looks a little more flexible maybe even has a little bit of smoothing around it so it's not 100% hard when I walk into these things, but it still can preserve the properties of a tile map where the gameplay logic is kind of operating on the tile map for a certain set of objects anyway like maybe there are some objects we know there are because even the original legend of Zelda for example, your character could move not aligned with the boundary right so push logic type to stay on the tile, but the character didn't have to certain things to just kind of be free floating around as necessary. Those will probably be like enemies and the guy or whatever but then we wanna be able to kind of have this concept of understandable to the player so they can see it, and we can sort of gameplay things on the tile that are easy to understand for a p so I want that that is the basic thing they're gonna be doing so we need to basic construct something that allows us to have you know a tile underneath right that could be rendered. It Hass to have you know stuff that moves around moves on top right on tile so we need those things traditional but we're also gonna do kind of like a fancy fancy render right we are a fancy compositor however, you wanna talk about it we're gonna get fancy here so these may be a little traditional. These will be like operated version of exactly the kind of stuff you would will probably do a better job than they could've had a lot more limited resources but this part will be a complete departure so we get to our present the visuals will go. We will go in a totally different direction than they ever have for that matter, so we wanna do th and what I would like to do is I would like to make this game totally procedural so I want everything to be generated by essentially an algorithm of some kind that will produce totally New World every time, so I want it to be the case that essentially for the most part nothing that we do will ever be like a hardcoded there will never be like screams you know, unless there's just like the starting screen or the ending screen of some very specific screens, that we want a hard code for some reason for the most part every last little thing should be such that you play it you are you are seeing new a new map every time that you go in and when I say that again, so what I wanted to talk about nothing you know nothing particularly confusing about these goals. Maybe this fancy render thing may be pretty confusing to implement kind of maybe blazing a little bit of a new trail or some things I'm thinking about trying to do but I'm out you can hopefully want to move on top of the tile and interact cleanly with it. We want a render this much fancier so that thing doesn't look like a tile map it looks kind of more organic and nice and pretty but that's still understandable as a time to the player so they can understand puzzles that are based o so I would like to basically maintain the sort of Zelda style conceptualization of a game world so I would like to have an overworld map right which you walk around on and then I would like dungeons that are in there so I want to be able to generat that essentially produces some kind of overworld map with these type of tile portions out of which viewing a small one you know you're viewing this one at a time when you walk off the end of it you come onto the next one right I want to be able to do that and on certain locations on here right I want you to be able to enter something that will then be another I'm not sure exactly what I want to take but I believe I'm gonna put this up here because this is what I would like to try first of all because I don't think there's any reason not to so I'm just gonna write it down here. I want to try and make a completely consistent space so rather than this map and the dungeon map being separate essentially I want them to all be the same so when you come here right and there there won't be like this Dundon that you know tons of screens and why that just happens to all occupy like one space on the map. It'll actually be more l you go down into the dungeon through the entrance and the dungeon is actually like underneath so the dungeon tiles actually are underneath the actual real map so these are like happening below many levels let's say, but you know they could come back up, so there could be like another entrance to it here and if you went into this entrance and followed it through and came out. You would actually be in exactly the same space that you would think you would be on the world map so I kind of want I wanna kinda make the space be 100% consistent so there's never Like any kind of a unrealistic shrinking or expanding of what a tile is tiles should always be the same size and they have to actually fit where they are and the only time that I would want to break that is if we had some kind of magical thing we were like if we were going to break that it would have to be inside some magical context, where it was clear that was suppose and so furthermore I want no dimension limits. This is a pretty important one to talk about so basically I don't want to have to say that the whole map or something fits inside you know something that's that's 256 screens by 256 screens by 256 screen or something like that I don't want there to be a dimension limit there could be a dimension limit that's just impractical like say, if if it was 4,000,000,000 x 4,000,000,000 x 4,000,000,000 or something I'm OK with that if that's the act if that's a limitation because we know that the player could never walk across 4 billion things so I'm OK with basically AA limitation if it's never something we could ever possibly hit, but I'm not OK with a limitation of something like this, so we're not gonna do anything where we have to like coordinate something that would fit we're not gonna allow anything that would restrict our ability to create world that are as large as we w with the restriction being that it's OK if we know that a single continuous line from one end to the other is longer than a player could ever hope to walk in you know less than a week of continuous or something so if we can determine that I'm OK with limitation, but I'm not OK with any so I think that's mostly everything we need to start going in and working on the actual game I don't think there's much more that I need to say about it but basically you know this is this is a pretty straightforward concrete specification of what I wanna do I wanna make it so we can generate the world. I don't want them to be really constraints we generate the world so we can generate giant world if you do whatever we want we wanna allow and I want to be consistent so that you know there's everything kind of fits together and I kind of I want to be able to have a bunch of things happen on top of you on top of that and then I want to be cathedral now because this is a because I want this in the game I think it'll be cool as a general thing but also because this is a series about teaching you how to program complex architectural issues I also obviously and we don't need to get into this now because it'll be a little further down the road, but eventually the core game engine. I want to support it like sort of insane level of comminatory and what I mean by that is all of the things in this world whether they're tiles or the things that move on top of the tiles whatever is anything that's interactive in anyway I want to be extremely combinatory rich such that anything that you can any property that you can imagine about that thing can be dealt with in a consistent way that interacts with other properties so for example, you know if there is such a thing as a monster who has a brain any monster that's like actually has a brain of some kind that's walking around or whatever and there are things that have affects like fear or whatever I always want you to be able to. If there should be a reason why the monster got hit with something that should cause them fear I want them to become fearful, and this should work entirely through the pipeline in the sense that, if, for some reason, we eventually give you something that's like a sector that allows you to cast spells on the title in the environment, and the sector can be loaded with gems of this jam is a fear jam i, and you cast that cast with receptor on the tile fearful, and if there were like anybody, who's both fearful and weak suddenly, just you know, runs away immediately or something like this that should happen to him if he was a creature who was already had weakness those are the things, r so we're gonna be focusing on combat a lot because they are the hardest thing to program in a day and so not only do I think they make for very interesting games but I also think that they're gonna make for a very interesting programming and so watching me have to deal with a lot of those comment I think is is mostly what I want to have happened in the later stages of working on this ga and so so we're gonna focus on that a lot but we're not probably gonna get to that real soon. This is we wanna try and focus on generating world that we can walk around in first just to make just to get ourselves up and running first but once all that stuff is working, then we will move onto the actual development game design side of things and this will really be we're spending almost all of our time will be on here OK so how am I gonna approach this? Like I said remember the diagram that I drew earlier today where were in a space and around it so I know that's what I'm going for. I know that this is I have this in my head I'm like I can sort of see the game that I wanna make right but I have no idea what the code looks like at the end I've never made even a legend of Zelda clone let alone a new game who's design is very different from something like legend of Zelda that just happens to be in the same genre, which is we're here and certainly legends. Zelda had none of that stuff so that's all totally as well so we just have a ton of stuff. It's totally unkn and I don't even have a plan. I don't even know how I wanna do this tile stuff I know I have a lot of experience programming lots of different things so I could brainstorm right now I'm number of ways that we could imagine implementing tile stuff and all that sort of thing so that certainly true but I do not have I haven't written like 50 games that are like this before and I can sit down and look. I am in that position that I was talking about diagram day zero we're not sure where the shipping code is or what it looks like so I'm gonna do exactly the thing that I said we're gonna start here at zero with nothing we're going to start exploring around the space by just looking at what it takes to implement basic version. How do I get a rectangle moving around on a tile map? How do I make a tile? Go try it we'll see what starts and we will let the architecture work itself up from there, so it feels like it's working pretty well will say OK that is you know that that's about it for the drawings I think and let's start we've got about a half hour left roughly so we should be able to do th, but we should be able to do a little bit of coding here to get ourselves started so I did remember there was one thing that we never passed to the game loop by the way that we wanted I don't know if we actually need to use it at all today but I wanted to mention that I don't know if you remember when we were doing the wind coating we didn't like the target game there's there's like a target per frame thing that we computed this thing right here which is how much like the game has this game input thing and and we we even have to do insert clock values here and we never did it so we want that thing right we want you know target for free we want to advance right overtime step over. We basically want to pass that value there because that is the thing that's gonna let the game be any frame you want so I'm gonna go ahead just pass it like I said we've already got it. We did all the work we just I don't know. I probably just because we had so much stuff we were looking at yo and then we never actually bothered to do it at the same one, so where is our game input written to game input OK so basically I think I really need to do is just say new input target per frame so that's the end of that so what I would like to do now is just take a look at what we've got here and sort of clean this out because we have a bunch of Tesco in here that we don't really need anymore or we don't really wanna run anymore? Because we're you know we're currently generating some weird g thing going on and that's not something that we actually want anymore so we certainly don't want it to be that sort of tone or anything like that so I'm gonna actually say that this is debug game output sound right now and well I guess I could leave it there first thing I'm gonna do is I'm gonna go ahead and say from now on let's just output zero so it should be completely silent and also I suppose since we're no longer working on the platform I can actually do I believe I can actually just do this from now on right I can just do leave the game running and t controller what happened? Everything is falling over here that's no good at all. That's no good that's no good right there. All I need to do is get rid of our gradients so the render ingredient that we were calling these will just no longer call. I will get rid of that guy and so if I oops I do that well so I don't like this morning cause we're gonna have fun so I think I'm gonna turn that guy off if you, 505 because I have functions that I don't and that's just you know that you might wanna call them later so we're gonna say 4505 so in theory we're not drawing anything so you can see that the buffer is not cleared anymore I made that change so I get rid of that thing we got the render players there and looks like we're still rendering stuff for mouse testing that's what those were up there in the corner are here so we don't need that anymore these guys are sort of showing us the location of so we don't really care about that. We don't need any of this stuff. This is all the Tesco looks like so we have our reading stuff. We don't need any of this all. Yeah, this just looks entirely not necessary so that can go away. All the stuff c see if there's anything in structure don't need to be there. None of this stuff needs to be there at all and then we've got really all I'm doing is just cleaning out all that I can leave this guy in here obviously but maybe I'll move them down kind of out-of-the-way just in case i know we don't let anything else render player will probably use that rectangle thing. We have our controller reading these things entirely. We don't need any of this. This is really where we're at. I think I'm not very much an error so let's see here this is not going to be updated eit should be good to go so tone hurts just go ahead. Absolutely we are back to square one and end another thing that I guess I'm not sure exactly what we want to do with, but I should probably think about in terms of when we're starting to do testing here, I should p with 3-D really have to think very hard about what resolution you're going to run because everything is always resample right your mapping polygons your mapping textures on a polygons and that sort of stuff so you don't really have a need to think about what the resolution is other than to think about ho for this game since we are doing a game we may want especially for background elements. We kind of want the elements to be drawn so that they are the size that they will appear on the screen so the pixels will be crisp in the cases where the artist wan we wanna think about what we want to run and I would say we probably wanna do like a 19 20 x 10 80 so you know 1080 target for the game and for our software render since that's gonna be a lot slower than using the GPU we would probably want to just do like half size or something while we're working but basically what I'm thinking is is that you know we pro an HDTV right we would probably ship this on for people on a normal Setup. They're probably gonna play it on a 19 20 x 10 80 x 60 Hz display right so when we're running on GPU we would probably be targeting to trying and hit that right a nice second full PhD sort of graphics system so for our purposes since we're gonna be doing our own renderer and it will be much slower than a GPU. Obviously I was thinking maybe we just do essentially what amounts to eight times less than what this does right we do 30 Hz for you know for this this for . We do half of each of these right so this is actually gonna be what is that that that 960 is that 960 always horrible and then and then oops help me why is it OK this guy is 549 6540 is is what we're shooting here by 30 so in terms of the number of pixels per second we have to fill right this is half this is half and this is half so ideally this is the 1/8 the work, ri so you could think about it as we're writing a eight times slower we're targeting something eight times slower than a GPU and hopefully we can make that work for our software if we can no big deal cause we don't have to ship this off render it's for educational purposes, but you know we're gonna try to do authorization stuff so I feel like that would be a reasonable goal to nine 6540 I think is roughly what I might like to do. Let's just say that it is for now because I don't have a better idea so nine 60 x 5 40 x 30 were already at 30 Hz and I believe we just have a thing here where we can just basically flat out say what the actual size of the thing is I think it's just that right there so if I want to I can say we're jus so I believe that is something that I will have to restart the app that's in the two platform layer I'm not very much in error so go ahead and run it and there we go so there is our there is our our target. Our target size is that big so first things in order to sort of get things working I am .\
\
OK, so first things first in order to sort of get things working I am going to write some kind of a rectangle function where you can pass a color right and draw a rectangle on the screen and that rectangle will be in a properly clip like it won't crash if I go outside of the region or whatever so I wanna make a simple rectangle so I can have some way of drawing something on the screen as we start to build things so I'm gonna take this render player which basically was drawing a rectangle and I'm going to turn it into something that is officially trying to draw a rectangle so it's going to be something that looks like rectangle. I will take that to and it will take some integer coordinates. I guess what I'm gonna say point coordinates because I would like to always be able to take point coordinates for reasons we'll see you later, when we start to cover render topics a little later on, you'll see why I might want to start having things always be inflating point because we'll actually be able to do sub pixel positioning of sprites by using you interpolation so I'm gonna say that we're gonna pass you know why I think starting off let's do max max and there's an interesting thing that happens with rectangles here and this is the sort of thing that I am awful at this is the kind of thing where you really want Barrett to do a stream or something although the last time I said we should ask him to do a stream on software synthesis he he steadfastly refused, so maybe I'm barking up the wrong tree, but there's there's things to be aware of, and will kind of go with them in the in the stuff, but I will probably even have to do some refresher stuff for my own self for them because there's all these sorts of complexities that com you have to understand that anytime you're working with very specific things like rendering there is sort of the precise definition of what you want actually matters quite a bit so if you think about it like this is my pixel grid,  then, how do you specify how you want it filled is actually kind of complicated because let's say that I number these locations right like a standard thing like you learned in math class right 123401234567. Well it's pretty easy for me to talk about a specific pixel at that point because I can just say well whatever the two numbers are here's the X here is the Y, so zero, zero is this one you know in three, two is this one right or something like that that's not so hard but when you start to say, I want to feel something and you end up with a little bit of confusion because when I specify the pixels, am I talking about them being inclusive or exclusive if I tell you to fill from 11 to 33 right so if I tell you to fill from this to this am I talking about filling these and not the outbound or am I talking about including the outbound right? And that may not seem like it's very complicated to understand and get right and get right confusing term here there when we get to the rendering stuff, I'll talk a little bit more about detail what are the things that reason that you would care about things terms right as opposed to whatever you want things get a lot more confusing when you start to allow stuff to move around some pixel on the grid so, for example, if I have a sprite and if it's sprite is three pixels by three pixels well it's pretty obvious what would happen if if the sprite is is lined up exactly like that right but if the spray is lined up exactly like that let's say the sprite is slightly off-center of the pixels right you have to understand. You have to have a good convention for understanding exactly how it writes into each of these pixels how much contributes and the specified right because now if I was specified that rectangle draw of draw from 32 to 65 what you didn't actually want to fully draw all of these right you were talking about only draw you know only contributing a portion of the color of each of these things and so there's just a lot of kind of thick that goes on ther so I just wanted to kind of point out. This is what I'm doing this rectangle here there's a lot of things you would think about if this were actually if we were really gonna do a rectangle that's our final rectangle. I'm not gonna do those. I'm just thinking about purely OK. What should this? What does this do just to get us something roughly it's working, so I'm gonna say that it does it does rounding right so it'll basically it'll take the X in the min wide. It will round those to an integer integer. It will fill up but not including whatever the final one is I think that's roughly what I'm gonna do so basically if you were to do the tile you would do like you would fill from 10 to 20 if they were 10 pixels wide the next one you would fill from 10 to 30 right so that they're inclusive that way I'm not gonna do 10 to 22 like 1920 to 30 and the reason that I'm not gonna do that is again because of that floating point really if you think about it it makes it a little bit difficult to talk about what happens in between 19 and 20 if you start to think about these things I have fractional values so I wanna make it so that you could pass two rectangles but perfectly right so I wanna make sure that the the rule for how you feel them doesn't draw over that that common case doesn't draw over 20 so the only one person is responsible for filling thing 20 right so I'm just gonna that's just the rule that I'm gonna use for this, but this is doesn't have to be perfect. We've got this this is our real version of these. We've got a real men in our real maxes, and I want to give us something where we can basically turn those into integers so I am going to do our men here is going to be the real minx, but I need to round it so I need to round a real 32 to 32 I written rounding all of the values once I have these values rounded one thing is that these could be anywhere in the buffer we are going to again that buffer is just a chunk of memory that we write into each 32 bit value in the buffer color so we need to make sure we do is we can't ever write outside of the legal boundary of the buffer right so what we wanna do now is we want to clip essentially two to the actual screen so if this is the screen right and this is 00 is a cord system here right? And this is the width and the height of that screen. If you pass me a rectangle that's like that well what I wanna do is I wanna just fill the actual part that we can fill and never write to the part out here because the part out here would be invalid memory well, in the way, we got a map set up this part would crash attempting to write to that part. We just flat out crash and attempting to write to that part would actually that is actually back here right because you think that the memories laid out in a stripe right? It's kind of looks like this so going backwards off the left edge wraps you around to the right edge on the previous line so anyway, so yeah I just wanna clip it and you can see the clipping a rectangle in that sense is very easy because basically all you're doing is saying if the X value is less than that boundary whatever the left side boundary is you just move it to the left side boundary because the thing that produces is still a rectangle so basically just taking and making sure that you push the outer expense to the outer sense and then the minimum get clipped to zero and the maximum get clipped to the height that's all we have to do to make sure our rectangle comes out so all I really need to do here is less than zero is gonna be equal to zero I'm just saying if it if that rectangle extended before the left side of the screen and then we just go ahead and make it do that and then similarly for the Y is exactly the same and then for the max is I need to do the same thing as well, the max, if that's going to be a greater than this time if that's gonna be greater than the buffer and I believe the buffer has the whip in it so we know what what size it actually is there it is so if it's greater than the width equals the width and if it's greater, and if it's greater on the wise greater than clamping those values to something valid and what I do here when I'm doing this, you'll notice that I left them. I left it so that it was actually right on the boundary now normally that wouldn't be a valid pixel right because if the width is let's say eight then 01234567. The last valid pixel I could fill is seven trying to fill eight with right off the end of the buffer yet I am allowing this to be equal to eat essentially if the buffer was eight wide why is that because I just said before that I'm not going to write the rectangles gonna fill up to but not including that final row, so that's actually OK that makes, so now in order to fill this guy I'm gonna need a color to fill him with and so in order to pass the color I'm gonna pass out real value again RG and I'm gonna go a little bit over to the I need to do I need to I don't have to do the color I'll just use white for now and then we will do the color tomorrow so that way I won't go any further overtime so color I know I wanna start. I don't know why this is probably because if you think about the way is arranged and our wise or not wise to step by this pitch value, where is exes, do not have to do that, and so what I would rather do here is, I would rather step at the other way I'd rat, I'd rather step such that we were not that we were touching continuous pixels right after each other and then only doing a job to the next row. I don't want to do it by rose because it's going to be more friendly with the cash friendly things are right next to each other so I'm gonna go wise first and then that happens to be we're gonna go until we get we're gonna go and then we are going to the pixel so the first pixel that we write is going to be wherever the buffer starts memory we gonna have to go however, pixel it is we're gonna have to go that far over for our men cause we're gonna start it that far in and the same for our midwife so we need to pre-advance the pointer to our to our pixel memory. We want to pre-advance the pointer so that's pointing at the top left corner of the rectangle right so that it's pointing if the rectangle is here right we want we want to take our pointer which starts at here on memory we want to point the pointer right there right we wanna point it at that point, so we need to add however much it takes us to get down to this row which is the pitch which is how much you add per times however, many rows we want to go down down right which is the minimum wide so we go down and then we have to go over by however, many we pixels how many bikes pixel there are for the number of pixels that we are over it, which is why, so we need to kind of bump after we move down to the start of the row that we start on we need to go over to get the start of the column and that's where we're gonna start from there. We just feel the pixels when we get to the end of the row we go down to the next fiel so we need to do here again this is not how we won't do anything like this we just call it simply a simple rectangle, so what we need to do is we need to go ahead and fill pixels here so I should probably call up the row pointer pointer advance every time we go down and then we will go down one row and then the same is true for X we were going to write pixels pixels we're gonna write to 30 of the time so now we have our pixel pointer is going to be equal to our pointer. We're gonna cast it up to you in three so we can write you in three at a time we left this one at eight because we were adding the pitch is in bites and we know that C++ and always do multiplication for you so we don't want to multiply by anything here it's doing that addition we want to add that bike value to the point, so OK so we we write the pixel we write the color and I believe that's mostly all we really need. We do need our rounding function for our rounding function to be honest with you. I don't know if she has ever introduced a proper rounding intrinsic probably is we should look for it, but for now we're gonna implement the old-fashioned way. We'll talk about how to do to do a real value and it wants to do a result that comes out, so what if we actually just cast it right if we actually just cast a real 32 to 32 the default thing that will do is it will truncate the value so what it will do is just lap off the fractional entirely so if you think about what that does on the line I'm in here and here's my number here is zero right here 212. If I'm in here right and I wanted to round this value here is .5 in the middle if I'm around this I wanted to go to be one because we all know that you know when you take which side of that dividing line you're on around upper down right? Well I don't wanna do that because I want I'm sorry if I trunk I'll go down to zero the fractional partly this was 0.75 or something right now so just get rid of zero I don't wanna do that I want to round up so what I can do is I change trunk to round by just buying the number before I trunk so for example if I add five to the number right that will push up the thing that was in this half, it will push it up into right and anything that wasn't here will get pushed up into here when I trunk then all the stuff that wasn't here that got moved to here we still trunk back that was still round back down to zero, which is what it should've done was in here will be moved up to above one I'll be one point something and then I will go back down to one, which is what I wanted which is rounding up, so basically rounding in the trunk for simple values like that are pretty easy for me to do it because I can 05 now there's a lot more to thinking about these sort of things and just that but for now that's gonna have advice so that's an easy way to turn that simple truncation operation into something that roughly does rounding cases we care about but we talk more when we have time there's a whole set of topics ta but we go that's our rectangle before we go to QA. Let's see if it works out and crashes or anything OK so let's see if we can draw something that's like this let's see what happens at all. I guess I'm gonna go ahead and see if it crashes if I move it to something bounce, it looks like that clearing the screen screen if I could pass a color we could pass a color really quickly just to try this out we could pass just a color that doesn't get handled properly right I could do floating point color tomorrow so I can do something where we do like a clear to 0/ first we can clear to something else we can clear to like some hideous purple and then draw something hideous cyan in there and will clear to purple draw cyan so we are 00 and we s game game to the game so it looks like that's not quite right or is that quite right? I actually didn't use that work properly doesn't look like it does not look like it to me. It's bugs and things I would normally have and it's tough because I don't know if , but I will say it it's been difficult programming on the stream because I tend to make careless mistakes because I'm talking that I don't normally make it. It makes sometimes exciting for me to program that makes sense so let's see that looks like it's may be sort of working, I don't wanna say that it definitely is but it does seem to be doing roughly I'm gonna spot check it just in case because again just so I have blah blah blah blah blah blah buggers buggers come out come out wherever you are all right well I think we're gonna have to call out today. Looks like it's sort of working pretty quickly would like a little bit more to make sure we don't have any mistakes in there, let's try we didn't crash that's good didn't crash ridiculousness crashes so I'm pretty happy with that so let us go to the queue and I would say don't wanna be too much overtime. I know that going overtime makes it hard for people who try to catch up and stuff because they have long streams to watch so tr like that is good enough for today I am happy with that. That gets us a position tomorrow do we have a way to draw rectangles so tomorrow I should be able to basically start building apps and we'll see where that goes. So totally good again it's always a little tough stopping the stream. I'm alwa, wait till tomorrow if you want to go ahead and I am pushing the Q&A button now, so if you want to go ahead and ask the question we did today stuff we have done in the past, and I added some new features to the question, so from now on, you should be able to put capital Q: and then whatever you\
\
Why do some pixels? How is it better than just pixels? That's an excellent question and I can't answer it in a short period of time so I would ask if you could keep that in your head if you can remember and you, I will have essentially an entire stream, explaining why that is corre when we get to when we start working on the proper and we're not the reason it makes much more continuous. I don't know if you've ever seen like the difference between something that looks like a perfectly smooth, beautiful scrolling of the background, and like it like slows to a stop and it's just beautiful and clean and then there's these other ones where they kind of jerk up to stop as they get slower you can see it sort of, this thing that's one of them so we want the sub perfectly smoothly.}