04/08/2024
Handmade Hero Day 028 - Drawing a Tile Map
00:00:00    
Reset. There we go. Sorry, cycle the recording, not going to cycle the timer. All right. Welcome to Handmade Hero here on day 28. We are in the middle of our sort of architecture stuff, our game architecture stuff, where we are starting to think about how we want this game's code to be structured and how we want it to work. Yesterday, we wrote a little function so we could draw a rectangle on the screen safely, so that would basically allow us to start doing some debug stuff. I wanted to talk a little bit about how to make the rectangle colored today. We're going to think about, like, basically colors and how those work just really briefly at the beginning of the stream. Again, we're saving any of the hardcore rendering stuff for when we actually write the renderer, but there's a couple things I have to do just to get stuff up on the screen, so I'm kind of explaining them lightly. And then we're going to start generating tile maps and doing some things with, like, trying to move characters 

00:00:47    
around, that sort of stuff. So basically what we're trying to do is we're trying to make sort of the initial game code just a first pass whatever comes to mind so we can start to look at how it looks and think about how we might want it to be structured because one of the big things that I was trying to emphasize on the previous two days when we were basically just talking about architecture and how you should think about it is you don't want to do a lot of pre -planning because pre -planning usually just don't have the information you need to make those good decisions and you're just going to make mistakes that will cost you a lot of time and so usually what's better to do is explore first learn and then go back and say okay, now that I've learned what this code should look like structurally, now I can say definitively, this is the architecture and move forward. So that is exactly what we're doing, and we are going to continue with that today. So, if you have pre -ordered the game here 

00:01:39    
on handmadehero .org, you should have gotten a link in your email that allows you to download the source code. In that source code is a zip file with each day's source. Basically, you open it up and there's a zip for every day. We're on day 28, so you unzip the day before, day 27. Start with day 27 source and you'll be exactly where I am right now. With that said, let's get started. We've got a lot to do. Because we're right here at the beginning of the game. It's a giant open field in front of us basically. So I'm going to go ahead and get everything loaded so we can get started. Alright, so, if I remember correctly, we were at the point where basically we can size the window however we want, but we don't do anything with the exercise right now. we're only drawing it up into this upper corner that's that's basically the entirety of our game there's some things that I want to do with that as well in the future a little bit but we'll talk about that later on so this is our game and we also 

00:02:33    
have our handy -dandy editor here so let me go ahead and open up our handmade .cpp which is here so at first first things first we should probably clear the screen well you know what let's talk about it again I actually do like clearing the screen to purple because you know what we should probably we do, if we clear the screen to this hideous purple, which is not something we're probably going to use in our debug output at all, if I clear the screen to this hideous purple, and then we go ahead and make a little tile map thing that has little squares, and we color the squares in, at least then we'll be able to see anywhere that we are not actually filling, because we'll see this hideous purple show through. So maybe it's a good idea to leave the hideous purple in there. I'm not so against the hideous purple, so that's good. All right, so what I wanted to do before we got started today in terms of the color, I had this to do in here that says floating point color tomorrow. What I wanted to 

00:03:21    
do is just talk a little bit about that and get you a little bit more familiar with that so that we can make the colors make a little more sense. Because, you know, right now we're basically doing what amounts to sort of web colors, right? I know you've seen it like pound, AA, BB, CC, that sort of thing. Or, you know, AA, 00, FF, or something. You've seen this in the... if you've ever done any web programming, that's how web colors work. But basically, right, that is the hexadecimal encoding of the color. And there's a lot of reasons not to like this. It's, I mean, it's basically packing the red, the green, and the blue into the bottom 24 bits, and I guess alpha if you've got it, but into the bottom 24 bits of a 32 -bit integer. And there's not a lot you can really do with that. It's not an efficient way to work with it because the most efficient way to do math in the CPU is using the floating point unit. And this is not floating point at all, right? 

00:04:16    
So if you think about a lot of things that you might want to do with color, like one thing that we might want to do with color is blend two colors together, for example. Another thing we might want to do with color is make it darker or lighter, like blend it towards black, right? These sorts of things. The math for doing that is really easy to do in floating point, but if it's in this crazy packed format, it would be a lot more difficult to do, and we'd have to work out all kinds of fiddly bit things to do it, and so usually what you would do is, you wouldn't ever do that, you would load it into an SSE register or something like this and upconvert it to floating point anyway. So basically what I want to do is get you used to working with some floating point colors to begin with because that is going to be the most efficient way always to think about them. And if we do pack them back into this crazy format for space reasons at certain points in time, like when we want to store them, we may 

00:05:05    
decide that it's more efficient to store them this way, for example, then that's fine, but that should be something that we do explicitly to save space and explicitly for that reason, not as a general way we think about colors. So what I want to do is pass three floating point values here, red, green, and blue, for our color. Now, I guess, again, I'll save a lot of this, talk about it more on the rendering side of things, but I guess I'll point out, the reason that we do red, green, and blue, obviously, you may wonder why we have that as our basis for colors. Essentially, the reason that red, green, and blue are what's used is because that's the cleanest sort of orthogonal basis you can use for the human visual system. The human visual system is sensitive to red, green, and blue light. It doesn't really have a way of sensing other color wavelengths because light is basically a continuous wavelength thing. Light oscillates like light waves, right? Well, you know, what we know about light 

00:06:04    
waves in physics, anyway. Light is kind of this mysterious thing that we're always kind of learning more about. But light essentially has a property when any given sort of photon, any given piece of light has a property that is its color, and that is its oscillation. Sort of its frequency of oscillation that it has is actually at a specific color. So you can have light that is actually a certain shade of yellow, right? And it's not a combination of red and green, which is how we think about yellow in programming or, you know, or artists even think about yellow when they open up GIMP. You know, I mean, we think about it, we go in here, when we actually think about color, I don't even know how to use this little tool, but I assume there's some way for me to get a, I don't know if there's, like, those little, you know, I'm talking about those little sliders that are around, let me use Color Cop, because that's got them. So we tend to think about it as like this sort of thing, where we've got 

00:07:02    
like a red, a green, and a blue, and the red and the green and the blue could contribute a certain amount, right, that sort of thing. Or, you know, there's other color spaces, hue, saturation, value, all this sort of stuff. We think about it that way, but really light isn't that way. Light is not a mixture of red, green, and blue, necessarily. Light can actually be a specific color if it wants to be. it can be exactly yellow or some specific yellow, some specific wavelength of yellow. And so it's just that our eyes, because they only sense, have like red, green, and blue receptors that have these kind of filter patterns that we use, because we only see in terms of those, our eyes can't actually tell the difference between a single piece, a single set of light, you know, single set of photons coming in that all are actually yellow. And oscillating photons that are coming in that are like one's red, one's green, one's red, one's green, one's red, one's green, right? So we just kind of see 

00:08:01    
this like integration of the light that hits our eyes. We don't, we can't tell that what we're seeing is a specific wavelength or not. We wouldn't know is my point. So we've basically built, and again I'm not a physicist, so take all this explanation with a grain of salt. This is like the explanation for computer programmers, right? It's not the explanation for people who study light. People who study light probably would be like, oh don't explain it that way, you're totally wrong. But for programming purposes what's important to understand is we don't need at the moment or have not found any need to in practice actually represent light in any better way than that. Because since the human visual system seems to only be able to really distinguish red, green, blue and it sees other colors by looking at the combinations of the red and green receptor responses, or green and blue, or red, green, and blue responses, we don't really have to worry too much about the fact that we don't actually 

00:08:59    
capture, you know, our monitors don't actually ever produce yellow light. They just produce red and green light very close together, and when they hit our eye, our eye goes, oh, it was yellow, right? Now it's worth noting that if we're simulating light inside the computer, all of this becomes not true. If you are doing a photorealistic renderer, for example. And I'm not talking about photorealistic rendering like the kind that you do in real -time graphics. I'm talking about offline, like the kind you might do for an architectural viz, like Maxwell Renderer or something like that. One of those renderers that takes a long time to generate an image but is supposed to be very accurate as to what light would do. At that point, it's not true anymore. At that point, you do have to worry about the wavelength of light, the actual wavelength that the light should have been. because there are optical phenomena that depend on those wavelengths like prisms and stuff that split light into pieces. I 

00:09:53    
mean I don't really know what they all are to be honest with you, but when you have materials that you want to simulate, certain materials actually respond differently in terms of the light that they reflect based on the wavelength of the light that's coming in. And so if all you know is that you have a certain amount of red and a certain amount of green coming in, and you don't know whether that actually came from a yellow, or came from a separate red and a green that were coming in together, you won't be able to compute the actual color that got reflected off of the surface properly, because you won't know which they are. So it's not true that in computer graphics we can always not care about this, because it depends on the level of realism you're trying to achieve and the circumstances. But it is true that when we finally get to the output layer of things, when we're just trying to draw an image on the screen after it's already been computed, at that point it is true that we have never 

00:10:46    
really found a reason why we would have to produce other colors. Red, green, and blue is sufficient, and as long as we can control the amounts of them, the eye can't really tell the difference between this as being yellow, actual yellow, and this as being a combination of red and green pixels that get lit up, right? Alright, so since we know that that's true, and since we know that our monitor has a particular brightness at maximum that it can output, What we can sort of think about is, you know, we can think about saying we just want a range of values between the darkest red, which is like no red being output, and the brightest red, which is the maximum red that the monitor can output. We've got a range between those, and we typically pick 0 as the no red value and 1 as the red value. And 0 is the no green, 1 is the full green. 0 is the blue, 1 is the, sorry, 0 is no blue, 1 is no blue, as like full blue, right? And the reason that we do that is because it makes our math with them be a 

00:11:46    
lot easier, right? If we set 0 equal to none, right, of something, and 1 equal to full, then the nice part about that is that if we want to get something, if we then want to know sort of any kind of, I'm trying to think of what the easiest way to show how this happens is. Basically, all of your blending operations, everything that you might want to do with numbers is easier when you normalize them to the range 0 to 1, specifically because you can always count on them being sort of in that same scale range, right? What's a good way to show this example? Colors is not the best way to do it because really I think a lot of times with colors because they're separated into channels It's it's not really going to be quite the same, but I'll kind of show you an example in another space so let's say I want to know how much of something I have a like sort of a percentage right so I want to I want to know like I've got a sort of I want to represent in floating point some amount of some arbitrary thing 

00:12:59    
and that thing has Arranged like we said before where you know there's a there's a none of it And there's an all of it, and then we want to represent everything in between right and let's say it could be anything It's like it's like we've got you know we want to say that we've got a pound of almonds Right one pound of almonds or something like this, and we want to represent How much of that we have? So, one interesting thing about normalizing things from 0 to 1 is that it can always be multiplied conveniently into whatever the thing actually is. So if I then have basically a percentage, right? If I have a 0 to 1, you know, 0 .0 to 1 .0 of something. If I ever have a ratio like this, I can trivially multiply whatever the value is into any concept of what the maximum amount is, 1 lb of almonds, 101 dalmatians, however many, anything I have. I can always take one of these normalized values and multiply it by whatever the thing is and get out how many I would have. So for example, if I have 

00:14:08    
101 dalmatians, right? If I have 101 dalmatians and you told me that I had 0 .75 was my ratio number, right, which equivalent of 75%, right? If I want to know how many dalmatians 75 % of the dalmatians is, right, I can just multiply directly by that value. I can say times 0 .75, and there I know I have 75 and 3 quarter dalmatians, right? Similarly for my pound of almonds, if I know I have one pound of almonds, I can do it times the 0 .75 and now I have 3 quarters of, you know, of a pound of almonds. If I have something like 735 viewers on Twitch, right, I don't know how many viewers are on Twitch right now, but let's say we've got some viewers on Twitch, that's probably a lot for a morning stream. So maybe not that many, but let's say it was an evening stream, maybe you get that many. And so then we go ahead and we say how many viewers is 75 % of them? Well, it's five, five, one and a quarter. Unfortunately, one of our viewers gets drawn and quartered, apparently, and we only have a quarter 

00:15:12    
of them. But who knows? Or maybe that's the split attention. So basically, what I wanted to kind of impress here is that doing things as a number between 0 and 1 kind of has this fringe benefit of you can always do math, you can always up -convert from a 0 to 1 range into any other range that you want. But the same is not true for if you store the values in their actual space. So let's say we have 101 Dalmatians, and then I said, well now we have 75 .75 Dalmatians, right? That was the number we had before. And now we wanna know how much is that same percentage in Twitch viewers, right? Well, I can't just multiply 75 .75 times 735 and get the same percentage of Twitch viewers. First, I would have to do the divide. I'd have to do the divide back out. I'd have to say 75 .75 divided by 101 to get me my 75 % again. And then I could multiply it by the 735 viewers on Twitch. And then I would get back the actual number. Does that make sense? So percentage, or which is 0 to 1 represented in floating 

00:16:17    
point, is kind of the universal storage for the amount of something that you have. It's a dimension -free way of storing an amount. And so we typically use it for things like this, where we're just saying, how much of something do we have where we don't really want to talk about any actual output units, it's usually just the most convenient space. So you'll see it happening a lot, and so it's a good thing to be comfortable with. So what I want to do is I want to do exactly that. I want to say that we pass in an R, G, and B. And then what I want to do is reproduce this color value that we used to be making here. I want to reproduce this color value by sort of pulling out what the values of the color value should be if we had this 0 to 1, 0 to 1, 0 to 1. Now this is, again, a color value that's made to write into one of these abgr buffers. Remember we talked about abgr way back in the screen, right? So we know that our bit pattern, right, is going to be, you know, something like AARRGGBB, 

00:17:25    
right? So what I need to do, and again, this is, each one of these is 8 bits, that's 8 bits, 2 nibbles, 8 bits, right? 8 bits, 8 bits, 8 bits, 8 bits makes a 32 -bit number. So to produce one of those 8 -bit values, right, I know I have a number between 0 and 1, and I know the maximum that an 8 -bit value can be is 255, right? So if I wanted to produce an 8 -bit integer value from a floating -point number that's between 0 and 1, I need to first take that and multiply it out so that I get 255 at maximum and 0 at minimum. So that's one way to do it. I could say that I'm going to have r and I'm going to make it be equal to... I'm going to multiply it by 255, which means that I will get... And then I can truncate that to change that to an integer value. So one way I could do it is that. But if you think about it, there's a little bit of trickiness involved here. There's a little bit of subtlety involved. And the reason for that is because, well, when we do this and multiply it by that value, 

00:18:33    
do you remember what I said about the rounding yesterday? um, you know, when we round, when we talk about how the rounding works, oops, got a non -black color there, uh, you remember I was talking about the number line, and I was saying, alright, we've got this number line, and it kinda goes on, right, and it's like 0, 1, 2, 3, 4, and so on, and I was saying in C, this, this int 32, when I, when I do the cast from a floating point value down to an integer value, it's gonna truncate, right? So what that means is, if the color value was like here, right, so let's say I multiply this out, And let's say that the value comes out to be, you know, 0 .9, 0 .9, which is almost 1. So, you know, so this value is something really low. And it multiplies by 255, and the value, so, you know, r times 255 becomes 0 .9, right? That's just what the result is. It's right, like, up here, but the truncation is gonna move that back down to 0, right? So what we might want to do is do the same rounding thing that 

00:19:35    
we did before, right? Now, you could argue about what is the more accurate thing to do here because it would depend on how you were producing these r values to begin with, what you actually wanted to have happen, but it seems like, you know, a totally reasonable thing to want to round, right? Because we know that we'll never produce anything higher than 255. So, because the r, if it was 1 .0, which is the maximum value, we know that we would, that we're going to allow, we know that we would never produce anything higher than 255, So we don't have to worry about it wrapping up to 256 because you can never produce 255 .5 or higher So what I might do is say let's go ahead and do that same rounding operation because that might give us a little bit of a more accurate conversion But rather than doing the truncation right does that make sense so I'm just gonna do that for now We again when we get to the render we can talk a little bit more about those values and and really think about what the 

00:20:24    
Most accurate way is to deal with everything. I'm kind of getting close too close to my head there So what I want to do, right, is I want to be able to produce one of these for each of my color values, right? I want the R, the G, and the B. I want those all in here, right? And, oops. 

00:20:44    
And I want, when I have the R, the G, and the B in there, I'm going to multiply them each out to basically get a number between 55 and 0, 0 and 55, and that's going to now be an integer value. And so now all I have to do is do the bitpacking again to make sure that they each end up in the right place in my thing. Now we know that R was 24 bits up, right, on the bit pattern. So we know that that is... Oops, sorry. We know that it's from bit 24 down to 16. So we've got to shift it up 16 so that it starts at bit 16, 17, 18, 19, 20, 21, 22, 23, 24. Right, the 8 bits starts there. The green value was right below that, so that's 8 bits up. And the blue value was at the bottom, right, so that's 0 bits up. Now we don't actually have to shift by zero, but sometimes it's kind of nice to show that so you can kind of just see it cleanly where each thing is going to go, right? It's kind of just a nice thing to line up. And then if we OR those together using our bitwise OR, right? That will basically 

00:21:35    
combine each set of bits, right? So we've got a set of bits here, the set of bits here, the set of bits here. They're each going to get converted up. Now, of course, I lost my little cast in there. My cast actually needs to be... Oops. Oh, I don't need the cast anymore. Duh. The cast actually is taken care of it right here, right? So that's actually totally fine. Now, I didn't want a signed value here, but I think that's actually fine for it to be signed. So, but you know what? I could actually do this. I could, I could actually make one for signed and one for unsigned for the moment. Just to be explicit, because sometimes, you know, later on maybe we care, who knows. So there we go. Let's see here. And so now we should be able to specify our color values in a way that's a little more, sort of, it doesn't have that weird 0 to 255 thing in it. Um, so now instead of that, let's actually pass it red, green, blue. That's just a little more, uh, convenient and easier to understand. And let's 

00:22:27    
see, to reproduce this, uh, we have, uh, let's see, green, blue. There we go. Okay. Do a rectangle. Uh, and let me see. There is our rectangle up in the corner, as we expected, and the colors are correct. And so now it's kind of nice to, um, because I can sort of, uh, I can sort of see as we go, you know, it's much... There we go. Does that work now? Yeah, that way I can flip back and forth. So basically, if we go in here now, you can see as I go, if I want it half -bright there, I can do that. And... what happened? Oh, I didn't recompile. I always forget to recompile. If I want it half -bright there, I can do that, right? I can change it back up to full -bright. Oops. Change it back up to full -bright. Let's say I want to make this more of a yellow color, right? I can do that. If I want to make it pure red, right? And so it's pretty easy to see how these color values mix together. And they're just between 0 and 1, so you don't have the weird 255 nonsense anymore going on. So that's it. 

00:23:30    
That's just all I wanted to do there, right? So already you can kind of see, and I don't know if now is necessarily the right time to do it, but already you can start to see, too, there's some structures that are starting to emerge here. Like, chances are, we're probably not often going to pass a red value by itself. It's probably going to come with a green and a blue, right? And so you can start to see already, again, game architecture -wise, just low -level stuff, you can sort of start to see what we're going to probably want to do here, right? We're probably going to want to make a struct that will capture the concept of a color so that we don't have to keep passing our RGs and Bs around. I'm not going to quite do it yet, but you can, because, you know, we only have even one function that uses it. But think about that, just keep that in the back of your mind. These are the sorts of things that you should start to be paying attention to, right? You should start kind of having this inkling 

00:24:22    
in the back of your head. When you see that, you're like, okay, there's these operations that are happening on a color. There's a way that represents them in uint32, and then there's this real32 version. I'm passing a bunch of things together. there's just a lot of things you can start to see if you're paying attention that may be that way. A rectangle might be another one you can see that we're doing operations on rectangles here so there's just there's things that you can start to think about in terms of what might be useful for the low -level architecture stuff that we might want to start doing. They're starting to emerge already and we haven't even really done anything yet, right? Alright, so again let's make the most stupid basic tile map that we might want to make let's just make something extremely simple for a tile map that we can draw on screen so what I'm going to do here is really the most basic simple thing that you could possibly imagine I'm just going to say all right I'm 

00:25:17    
just going to have some 32 -bit value and I'm going to make a you know a tile map of them and I'm going to say how big do we want our tile map to be across and down you know and I don't know I think I thought about this a bunch if I remember correctly earlier on and I'm not sure I'm not sure what the value was I'll look it up because I thought about this I think 16 across was was what I thought that the the right value was for the number of of of tiles going this way and I think it might have been nine down it was I think it was 16 by 9 look roughly the same as an HD aspect display ratio 16 tiles across by nine up and down and I don't know that may be a too big I worked this out I was kind of looking at past games and what their tilemap sizes was but we can adjust this in the future but I'm just going to say alright I'm going to make a tilemap so basically all I'm doing is making an array that's 16 by 9 I'm gonna I'm gonna reverse them here because this is the if you look at the way C does 

00:26:16    
its syntax this is actually the one that gets packed together so these go sequentially the 16 goes sequentially and the 9 so it's like rows and so I wanted the the X's kind of to go sequentially there so what I'm going to do is I'm actually going to define my tile map right here as like a little, you know, as like a little, I guess, hand inputted thing, right? 1, 2, 3, 4, actually why did I do that? 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, let's see, do it this way, make it a little clearer, 12, 13, 14, 15, 16, right? So here is a tile map 0 1 2 3 4 5 6 7 8 9 so there we go so this is our little tile map here which I'm just going to hand input right and I'm going to go ahead and make something incredibly simple in the tile map I don't know I'm just going to do something that we would be able to see if it was working properly kind of a thing, there we go, something like this, where I'm just going to hand input some numbers that we should be able to then verify are sort of coming out correct when 

00:27:34    
we look at the tile map at the end of the day. Ok? Right? Very, very simple. So you can kind of see what I did there. I basically just spammed in some ones into our tile map and now what I'd like to do is I'd like to draw the tile map to the screen as the background. So I'm going to clear it first. I'm going to clear the screen just to that purple as a purely debug operation so that I can verify right I can verify what's being written and I can see if there's purple showing through I'm then going to iterate over my entire tile map so I'm going to do the row of the cut tile map right I'm going to do the row and I've got nine of those and then I'm going to do the columns and I've got 16 of those right and again this is not this is just purely like I said before just exploratory code I'm typing whatever I want in here and when you are in this mode and this is a just really important to remember when you're in this mode anything goes do not think about code quality do not think about errors 

00:28:37    
do not think about performance don't think about anything because the point of this code is to see what you would type in if you literally just had to do the thing fast you just want to draw a tile map on the screen. So don't think about anything other than what is the easiest way you can think of to put that tile map up on the screen in a way that you can view, right? That is the only thing that you should be thinking about. You should never ever ever give even a moment's thought to any of the things that you see in those books that are like writing clean code and like how effective C++ all that stuff should be completely shut off in your brain because what this code is for, is for us to see what the CPU has to do in order to do the thing that we want. It's just to get some notion of what the code has to do. And then we're just going to look at that after and figure out what the clean way to make it is, right? So you should be thinking about absolutely nothing at this point other than 

00:29:41    
exactly that. Exactly the how to get the thing up on the screen. That's it. So brain should be exclusively one track in that mode. that's all ok so we have our draw rectangle function so what we need to know now and this is like our this is our tile value or tile ID or whatever you want to call it I don't know we're going to call it but there we go so we have a tile ID and what I'd like to do is say well alright we essentially want the color to be based on this tile ID because we only have that we don't have an ability to draw any sprites or anything yet we haven't written the renderer so basically we only have the ability to draw a color so what I'll do is I'll draw a great grayscale colors and I'll have two of them right so what we'll assume is we'll assume that if the value is 0 in the tile map right we'll have a gray value of let's say 0 .5 and if the tile ID actually is equal to 1 let's say then I'm going to make it be white so we'll have gray and white things in our tile map make 

00:30:35    
sense seems reasonable alright so then when I draw the rectangle I'm going to need some things I'm going to need the minX right I'm going to need the minY, I'm going to need the maxX and the maxY. So basically, I know whatever my min is, the tile width and the tile height, whatever we decide that those are, however big those are. I know that basically, whatever the maxX for my rectangle is, is just the min plus the tile, however big the tile should be across. And the same is true of the vertical extent of the height. right? So minX, minY, maxX, maxY, red, green, blue, and of course we're only doing gray so I can just pass the same value for each of them. There we go. So the only question is, what's our minX? Well, we know we've got a row value and a column value, right? And so for every row, we want to go, like, each time that row increments, we're going to go down by one tile height, right? Which we already know is going to be a value. So we've got the row times the tile height, right? 

00:31:36    
And row is an integer, whereas all the rest of this stuff is float. So we need to convert that up to a floating point value. Again, C, I think, will just do that for you. But I like to make it explicit so everyone can see that it's happening in the code. So I do that usually. And also so that I know, so that there's not weird mistakes. I find that if I do everything explicitly, I don't get caught by some weird C thing where it's decided, because of some rule in the spec, not to do something that I would have thought that it should do. So basically, this is every column we know we're going to go up by a certain amount and every row we know we're... I'm sorry every row we know we're going to go down by a certain amount and every column we're going to go over by a certain amount and that's fine and so what we might want to do though is start an offset so we might want to make these start a little bit further in so let's say we can say upper left x and upper left y right so there we go so now 

00:32:31    
what we need to do is actually find those values, those are just constant values. Upper left x, let's say it starts at 10, right? So there'll be a little border around the thing, and 10. And then the tile width, I don't know what the tile width should be. We can certainly adjust it. Let's say it's 100 by 100 tile height, that, and we can recompile. And hey, there's our tile map on the screen, so that's pretty good. Oh, and I still got that other rectangle, which I don't need anymore. That can go away. So now we've got our tile map on the screen. And of course, we don't even have to do any math, because that's the miracle, again, of hot loading, um, the DLL. Everything gets trivial. We can just do this, and there's our tile map is smaller. All right, let's, let's make it a little larger. Okay, that's good. Maybe there. That's good. Let's say it should be 55 wide, something like that. Uh, a little bit bigger. Just a little bigger. 60. 60. That's a little too big. Uh, so anyway, um, although, 

00:33:30    
you know what? if I actually just started it in the corner and didn't have that offset, right? You know? That's what you were thinking, right? I think that's, I think that's our winner. Yeah! Alright. Um, so there you go. Uh, there's our tile map, it's on the screen, and of course now we can create, I mean, you can create a level if you wanted to, right? I could say that this is a standard dungeon map, uh, which would look something like this. Let's go into insert mode there. If I wanna make a dungeon map, now I'm making a dungeon map, that's always fun. Um, we all know, right, because Legend of Zelda set the, set the bar, and now you see it all the time, like Binding of Isaac, right, looks exactly like this as well. Basically, you've got a, a thing around, you've got walls around the edge, but then you have, like, a door, right, in the middle. Um, and that might be a reason, uh, not to use 16, because we can't, we don't have a middle value. So we may want to use 17, do you know what I'm 

00:34:23    
saying? Um, so there's our doors, we should probably make sure the doors aren't blocked, right? Let's make sure those doors aren't blocked. Don't block the doors, people. The player can't get in or out at that point. There you go. So now our player, you know, could walk in here, he could walk around, he could walk out that way, whatever he wants to do. But that's not centered, so that seems like a pretty obvious reason not to use that. So I'm gonna go ahead and say that 17 is the magic value, right? Um, I don't see why not. Uh, so basically there's, there's this extra row over here, right, if that makes sense, um, that we're gonna push out there. Let's go ahead and do that. Oops. Too much space. Too much white space. So let's go ahead and push that out. do do do do pushing it out and then we can just say all right that's gonna be that so if that's the case then we also have to do we have to figure out our offsets are going to be a little different here so that means that you know the the 

00:35:17    
the upper left is going to have to be offset by a little bit right like that so that essentially you don't quite see the whole tile because it wouldn't fit evenly. And the same is probably, you probably want to do something similar. I don't know if we could. So let's say we did that, so you kind of only see half of that border tile. Then what we would want to do is we'd want to make it 10 wide, but that would make it so that we couldn't center our other guy. 

00:35:47    
You see my dilemma. I don't know, do you see my dilemma? I'm not sure if you see my dilemma or not. I feel like we want the things to be square, but I'm not sure how I handle that. I mean, do I just do this so that basically this tile is always shown as a half tile? I don't know. Something to think about. I'm already thinking about that. And again, like I said, this is why we do all this exploration, because I want to think about all these things up front before I make decisions about what our tile map size is and all that sort of thing. 

00:36:26    
ok so that's our tile map I'm not gonna think too hard about it at the moment but like I said it's already putting thoughts in my head like I gotta start thinking about how I want to deal with that stuff so I'm and I might go study old games that sort of thing to think about what the the dimensions of this tile map should be now one of the things that's interesting is it didn't used to be 16 by 9 like Zelda for example was 4 by 3 aspect ratio right was on the old TVs before HD went widescreen and so I don't know that may be a consequence of the fact that we're 16 by 9 now that things get a little bit different and and we have to think about how we want to handle that exactly it's something to think about and so I would encourage everyone to put their thinking caps on there now the other thing that we could do right is we could say that we have some kind of a gutter on the screen I don't know there's a lot of things we could think about there and so I would encourage you all to think about 

00:37:19    
them maybe post your opinions because this is That's essentially a design question at some level. And maybe think about those and what you think about them, essentially. Because I'll be thinking about them as well, and maybe that's a good exercise to do. All right. So given that I've got this situation where I actually have a tile map on the screen, it seems like the next logical thing to do is to make a little player that can move around on them at a very minimum, because we know we're going to need that. And so if I go ahead in here and I, you know, I want to essentially add some storage for my player, just some really basic stuff inside the GameState structure. Now normally we shouldn't be able to really do much to structures while we're hot -loading, but in this particular case I think it'll actually work. And the reason for that is because there is no actual stuff in the GameState structure, It's just the beginning of our memory block and nothing else is stored in the memory block 

00:38:20    
either So if we just go ahead and start writing to those values, it just works, right? So I can do that and nothing will break because there's nothing actually getting rearranged It's just adding some stuff to the end. And so the hot loading I think will actually still work So what I'm going to do now is I'm going to draw a player in here, right? And the player is probably going to be I don't know. Let's let's say That that the player x and y values should probably be, I would suspect, the player X and Y should probably represent some value that's at the base of the character. I'm trying to think of how to explain this. I might need a diagram for it. Just telling, just trying to tell you what I'm thinking here. So if I have a tile map on the screen right and I'm looking at this tile map sort of as as as grids and you know I've got some notion of things like like this is a wall right and these are filled in and I can't walk there well normally what happens is the player actually the players 

00:39:27    
sprite right doesn't stop when the top of the sprite hits that wall usually what happens is they kind of eclipse the wall a bit so their actual location is typically more about where their center of gravity is projected on the floor if you will right like like usually the the player sprite kind of eclipses the wall like this it comes in front of the wall you know and so the position if I was checking the position against the tile map in some way I'm not checking the center of it right and I'm not checking the upper left corner or the lower right corner I'm checking this sort of center of the bottom of the sprite in some sense now we'll probably do something a little more if we probably make maybe like a little bit of a circle there for collision detection eventually who knows what we'll do we might we're not going to probably literally just check a point when we're moving the guy around but for starters will probably just do that and I want to do something relatively close to what I might 

00:40:29    
actually want, so we can see how it feels when we move him around. So basically, right here is mostly what I want. So, when I draw this guy, I'm thinking that what I want to do is say alright, where I draw the rectangle, if the X and Y for the player comes in you know, I don't actually know exactly what I want here but I want something like the upper corner of the rectangle we want to subtract the height of the player, right? So we want to subtract the height, and then we want to subtract half the width, right? Because this is half, this is the half line. And then we draw the player between there and the width height, right? So we kind of want to, this is our, this is our kind of diagram for how we want to draw that. If this is the player X, player X, player Y, right? So, really straightforward stuff here, but again, since this is the very beginning of our work with this sort of thing. I just kind of want to explain these things in a little more detail for people who've never done stuff 

00:41:28    
like this before. When I do this stuff, it's like second nature. It's like, oh yeah, I just, that would just type and like come out of my fingers if I start typing, right? But that's only because, I mean, like when I was little, I mean, I was, when I was like eight years old, right? I used to draw things on graph paper and input them into the computer for graphics because we didn't even have like paint programs or anything like this, right? And so, a lifetime of doing stuff like this means you can just do it in your head, but if you've never done anything with graphics before, you have to actually think it through, right? And it's only after you've thought it through a bunch of times that you're just, it's second nature to you. It's like anything else, right? And so, yeah, if you've done this before, then you know what I'm talking about, because you've got second nature. But if you've never done this before and you're like, whoa, you know, what's going on? As you do this more, it will become 

00:42:20    
second nature to you. You won't have to sit and think about these things. You'll just be like, boom, and you've got it. But it does take a while to get to that point, right? Like, it's like having done it all the time, it's like riding a bike, right? You're just kind of like, alright, yep, I know how to do rectangle calcs. And similarly, you know how to debug them. So you'll do the rectangle calc in your head, you'll type it out, and sometimes you're wrong, and you see the wrong thing, and you're like, oh, yep, I forgot the blah, and you do it right. So you remember some combination of how to always do it right in your head and how to correct the things you often do wrong in your head, it's real funny. You'll see it happen on the stream, I'm sure. Um, I don't know if it'll happen right now, but it'll happen. So anyway, we want to draw the player. Uh, and I'm just gonna do a player, uh, R, uh, player, uh, G, right? Uh, player B, kind of a thing. That, um, and so I want to draw a rectangle 

00:43:11    
of the player. Uh, I want a player width, right? player width and player height and I'm not sure what those should be right I don't really know I have no idea I'm going to make him the tile width and the tile height at the moment but that's probably a little too wide because if he has to move through I you probably want him to have a little bit of slop when he moves through things so you know we could even say that it's going to be 75 percent of the width or something like that I don't know I'm not sure like I said really don't know so then what we're going to do is say, all right, when we actually go to draw this guy, I want to do player R, player G, player B. And I want to do the minX, minY is going to be our game state, which remember, I did get up here. It's right here. So we pulled that. That's the base of our memory block. So it's going to be the game state, player X. In fact, I probably should do this player top and player left, like that. So I'm going to take that player x and like 

00:44:23    
I said, I want to make the left of the player be minus whatever half his width is, right? So I'm just going to do half, right? Multiplying by 0 .5 is half. I'm going to do half the width, move it back. And again, that corresponds to this error right here, right? So I'm taking the X of the player, and I'm moving it back by half the width. And then I want to take the whole player height here. And I want to go back by the entire player height, like that. Right? And so I'm going to go ahead and say playerLeft, plus playerWidth, um, player top, oops, sorry, top, that, uh, player left, plus player width, don't know how that got in there, uh, player top, plus player height, like this, and so now I've sort of got basically, um, I'm passing the left and the top as the place to start, and then I'm passing for the max, that's the minX, minY, The maxX, maxY is gonna be plus the width and the height, right? And that's the entirety of my player drawing code at the moment. Now, we don't actually know 

00:45:32    
where the player is, of course, is also a problem. So, the values that are in there are whatever the values were. So, that's certainly a bit of a problem. Like, the actual game state playerX, playerY, well, I guess I could do this. Game state playerX equals 10 .0, something like this, let's say. 

00:45:55    
there we go and then you can see him up there right there is and now we're probably going to need some way to move him around so we can go up to our controller code again make this a little bit bigger so we have to program in a little tiny window we can go up to our controller code which we had here and I'm going to use the digital movement I'm going to use the keyboard for now because I don't want to deal with the analog movement at the moment so basically what we want to do is say all right we have these these buttons right and I'm going to say that I have a player x delta and a player y delta and at the end I'm going to take the player x and the player y and I'm going to add those right this 

00:46:45    
ok so if my controller input move up ended down right and I'm just going to kind of do this sort of thing right so move move down move left right I'm going to say that if move up ended down then the the player X is going to be, I'm sorry, the player y is going to be 1 and if it moved up, right, if he's moving up it's negative, if they're moving down it's positive, dPlayer x equals negative 1 if he's moving to the left because he's moving, getting lower in x and higher in x, right? So I'm just going to do that for now, should be pretty basic. That's game state. And so now I should be able to move my guy around yeah there we go so there's the dude right and he's moving around now he moves around pretty slowly and that's fine I'm not a particularly speedy fellow at the moment of course I also don't actually know what our frame rate is right now because we're not even printing it out and so we I wish we are going to have to do some stuff here in a second to think about how that should go so 

00:47:56    
um in fact let's just do that right now because hey we've got a we've got a player sprite moving around on the screen let's think about that so what would happen here if I did this what does that actually mean what did I actually just write well what I wrote is I said that the players exposition is going to be updated by one every time a frame goes by and the like the D key is down basically what that boils down to right there they're moving to the right right so because this is in pixels essentially right all of this is in pixels that just means he's going to move one pixel to the right every frame. Now, there's a couple of reasons why that's not such a great way to do things. One is because our frame rate now determines the speed that the person moves at. If our frame rate is 30 frames a second, 

00:48:53    
then he is going to be moving at 30 pixels a second. But if our frame rate were to jump up to 60 frames a second, because the platform layer decided to run at a faster framerate, then he would move twice as fast and the game would play twice as fast, which is not what we want. So what we want to do is we want to take the actual value that we're getting in here for the amount that we're supposed to move by, right? Seconds to advance over update, right? I don't love that name. I couldn't decide what I wanted that to be. Let's see. I'm going to call it DT, right, for D time. DT for frame. So the amount of time that elapses over the frame is what we're going to use. 

00:49:40    
And so what I'm going to do there is I'm going to go ahead and multiply however much the value should be, however much the motion should be. I'm going to multiply whatever the movement direction is, essentially. I'm going to multiply that by whatever that DT value is. So that way I'm going to get a constant amount, so if the amount of time that has passed goes down, then the amount of movement will go down, and if the amount of time goes up, then the amount of movement will go up, which is what I want. 

00:50:23    
There's stuff that I haven't talked to you about yet, and so I can't do some things that I would normally do here, but I'm going to tell, I'll mention what they are briefly and then we'll move on. Okay, so what I want to do is I want to take this DT and I want to, I want to, that's in the input structure, right? I want to go ahead and multiply that out. So now we have a fixed amount per frame basically. And of course the problem with it is this is now going to be incredibly slow because that means he now moves one pixel a second. These values are now in seconds because we're multiplying by that DT. And again, this is the dimensional analysis again that I've talked about many times. Essentially what we have is we have a DT for frame, right? So for the frame, we have... this is essentially the number of seconds that we're going to have. So this is in seconds. This is some number of seconds. It's DT seconds that we're getting passed in. So we're gonna multiply... we're multiplying that by 

00:51:16    
something, right? We're multiplying that by a value and we're getting pixels out, right? We're gonna... we're taking the result and we're using it as pixels. So dimensional analysis works in reverse as well. we know that if we ended up with pixels and we started with seconds we know that the thing that we're multiplying by, we can fill in the units, right? Pixels is on the top because that's what we ended up with and seconds is on the bottom, right? So we now know that the value is in pixels per second. This is pixels per second, right? That's what we did. So if we're doing one pixels per second, that's just not very many. So let's let the guy move 32 pixels per second, let's say. Or you know what, we can do that in an easier way. We can basically say, at the bottom, let's just give him some speed there. And off we go. Oops, where's my game? There's my game. So now he's moving a little faster. It's not great, but it's faster. And why is my move up button not working? Do we have a bug somewhere? 

00:52:20    
Oh, nice. Oops, sorry about that. 

00:52:25    
Too many windows open. Where's my damn game? There it is. All right, so then the guy's moving around. Still pretty slow, 30 pixels a second is not very many as you can see. Let's get him up a little bit higher. Speed of the game, maybe let's say that he should be at 128 pixels per second, something like that. Let's see how that is. There he goes, moving along. Wow. Although, you know what? I think our frame rate is pretty darn low here, right? Cause look at how slow, look at how jerk, how chunky that is. So maybe we might not actually be, if we're not hitting our frame rate, then this isn't in seconds anymore. We could change to passing the actual time that has elapsed. But that's unfortunate. So I wonder how slow we're actually going. So let's take a look. Let me go ahead and close this out. Let's take a look. Because we have to hit our frame rate. Otherwise, our timing values will be wrong. Now, the other thing we can do here is pass the actual time value that's going through. maybe this 

00:53:24    
is something we'll have to do in the Win32 platform layer relatively soon, actually. If you think about it. I gotta fix the bug now in the platform layer as well. We changed this name to DT for frame, right? So there we go. But I guess our frame rate is pretty darn low, which is unfortunate. Let's take a look at what it actually is. Just so we can see. 

00:53:52    
hmm are we are we not actually measuring the value though my my my doing something wrong here what are we printing out in milliseconds per frame now we're looking at get seconds elapsed so what so I think I've done something so we got a bug here I I feel like, is that actually milliseconds per frame, right? And that is actually being measured by the win32 getSecondsElapsed. So if we're taking 33 milliseconds per frame, we should be animating very smoothly, right? We should see something very smooth happening on here. And yet, do you see how jerky that is? Why is that so jerky? What's the bug? Does anyone know what the bug is? I'm not sure if they do. 

00:54:40    
I certainly don't. So why is that so jerky? If we're getting a totally smooth frame rate, that seems wrong. So what's... like I said, I don't know what the actual problem is there. I would like to know. I suppose it could be... this could be the streaming thing again, but I don't know. I don't want to assume that it's just OBS doing that. And I guess I don't have a real way to test that, unfortunately. But I don't want to assume that that's true, if it's not actually true. But it seems like we should be getting 30 frames a second. and yet we're not. What would happen, let's say, if I changed it to 60 frames a second as our target? I'm just curious. Let's see. So, gameUpdateHertz, isMonitorRefreshRate divided by 2? Well, let's just say that it's not that anymore. It's just by 1. 

00:55:33    
well so that does seem awfully smooth smoother so I wonder if this is OBS is just messing with us that's kind of unfortunate I'll have to test that separately on the stream because we are hitting our frame rate as far as I can tell it's actually working properly and it does get smoother when we output faster which means that that could be because we're getting like a beat frequency hmm that's unfortunate yeah you know I guess maybe I eventually will have to go to using a capture card I was hoping not to have to go to using a capture card for this sort of stuff because I was because they seem kind of unreliable potentially but it looks like I may have to I kind of need to get things out of the out of the equation here if that's the case yeah you can see how jerky that is and that's really annoying to me now maybe it looks smooth to you for all I know it looks smooth on the stream but it looks very jerky to me it's I guess all I can say so yeah so let's see if this holds water as well we 

00:56:35    
know how many pixels up and down we are some of the time how long it takes to get there 1 2 3 4 5 6 7 8 so it takes them eight seconds to get like by my crappy just me counting right which is not a particularly good way to do it but if it takes him eight seconds to get to the bottom, and our declaration was he was going to move 128 pixels per second, then we should expect that it should be somewhere around there is the height of the window. And I was just counting randomly, so it could be more like 800 or something like that. But let's take a look at what it actually is, because I'm just trying to determine what. Yeah, I feel like that's way too long to get from the top to the bottom, if that makes sense. So I feel like I've still got I feel like there's there's a bug in here is I guess all I can say so I believe we said it was 540 right so it feels it feels like maybe that's twice as fast as it should be or somewhere on there now maybe again like I said maybe I was counting a little bit 

00:57:40    
too fast but it just feels it just feels off it just feels off to me and I feel like we've got a bug somewhere but of course it is the end of the stream so I guess basically note Casey we are sorry I should say to do Casey let's take a close look at timing tomorrow and try to verify that it is working properly because it appears that things are moving half as fast as I would have expected. Right? So I think that's our to -do for tomorrow. Alright. Excuse me. Alright, so now it is time to go to the Q &A. And yes, please make sure that you prefix your questions with Q colon so I can see them. And also please keep the questions to what we've done on today's stream or stuff we did on previous streams so that we essentially don't get too far off base with with what we're talking about. So let's take a look here. Let us take a look at the questions. 

00:59:02    
Is sleep still oversleeping and throwing off the FPS asks EnemyMouse. Well we can certainly find out and one thing that we can do is we can adjust our sleep or we can get rid of our sleep entirely for now, right? We could, in our sleep code, I think we have a sleep is granular thing that we set. We could decide to just be a CPU melter and say sleep is granular equals false, right? 

00:59:42    
And at least for me, it doesn't get any better, unfortunately. That's without sleep, right? Because I believe now we can verify that sleep is not actually happening. If I go down here and set a breakpoint in the sleep code, it should never happen, right? Yeah. So basically, it's not sleep. And I think we kind of knew that it wasn't sleep. because, because if it was sleep we would have seen that our millisecond timer is actually timing what happens in that case, right? You can see down here where we print out this FPS buffer thing. Milliseconds per frame was actually computed up here from the actual count that happens after the sleep. So we would have seen our frame rate be wrong if that were the case. Our frame rate number, so we are at least getting through the loop in 33 milliseconds, right? But we're hitting some kind of a beat frequency with either with OBS or just the window compositor where we're not actually able to update at that rate or something, or something else is wrong. So 

01:00:49    
we definitely have some kind of a problem there, but I'm just not sure what it is. So we're gonna have to take a look and see, you know, what our bug is, um, or what Windows is doing that's thwarting us one or the other. 

01:01:09    
It's bugged because you only set DTFrame on one of the two inputs. Oh, did I put that in the wrong place? Ha! Awesome. Thank you for that catch. Oh, you're right. Oh, that's awful. That's not what I wa - that's - that's not where I wanted to put that at all. Yeah, this is again the problem of, thank you, that is definitely our bug. I wanted to put that where we first do our input. It might be time to start cleaning this code up a little bit. I didn't really want to spend any time on it, but... Yeah, what we wanted to do is do it in the actual loop itself. That was a mistake, so I didn't mean to do it here. That was dumb. What I wanted to do is do it here, right? I wanted to do it at the beginning of every frame. And so that's the reason. Yeah, thanks for that catch. The problem is that, um, I thought I was setting it every frame, but I actually set it just at - before we even entered the loop, right? And so one of our inputs was zero, so every other frame it wasn't updating. Which is exactly 

01:02:07    
what I - that's weird. You can sense when these things are wrong. So it was moving exactly half as fast, which is exactly what I felt like was happening. And my timing - yeah, so there we go. That's what I would have expected. It's still not the smoothest thing in the world, um, which I think is just an OBS problem. But you know that's that's much better. Thank you play triangles for Christ. I Love that name to play triangles for Christ is I mean who wouldn't do that for Christ all right? So let's see here. Let's go ahead and put that on there So now that's more what we would expect okay, so that's good now. We're good. Everything's better. I knew there was a bug I'm like something something's busted. Thank you very much This is the magic of the stream basically the fact that there are so many people watching the stream Totally compensates for my lack of ability to concentrate. It's it's like perfect, so that's good So now we don't have that anymore. We can get rid of that to do. Thank 

01:03:01    
you 

01:03:08    
Garlanda bloom possibly we need to sync our refresh rate with the windows v -sync otherwise windows We'll just be tossing out some of our frames and causing jerky movement. Yes, that is absolutely happening Um, unfortunately I don't know of a good way to do that until we move to OpenGL or Direct3D. Uh, I wish I did, but I'm not sure really how to do that. Um, there is a direct, uh, direct, uh, draw call that you can use. Um, but I don't really know... I don't know how supported that is anymore. So once we move to OpenGL or Direct3D, this will be solved for us, because they allow us to do that automatically, but I don't know how to do it until then. 

01:03:50    
On the topic of the tile map size maybe you could go for smaller size tiles keep an even number of them on both sides and use the two middle for the doors yes we could that's a good point we could do that but then are the doors but that doesn't really help though because then aren't the top doors wider than the side doors the problem is it's 16 by 9 is the display so the problem is not how many tiles there are the problem is that we have an odd number of tiles in one direction and an even number of tiles in the other direction if we want the tiles to be square, right? So I don't think that actually helps. 

01:04:27    
Why you don't use any created before engines like OpenGL, SFML, Allegro, XD, SDL? I feel like that's been answered so many times. It's because the whole point of the series is to build a game from scratch. I think you can get tutorials anywhere about how to load up you know Unity and drop some stuff into it and that's not very interesting because if you ever wanted to build anything that wasn't Unity, you can't. And you also have no idea what Unity's doing, so when you have problems, you don't necessarily know how to fix them, right? And all sorts of stuff like this. And you also don't have much of a handle on what things you do in Unity might do in terms of affecting your performance, all that sort of stuff. And so really, the whole point of this stream is to show you all the things you don't see everywhere else. It's to do the opposite of what everyone else does, which is just grab as much off -the -shelf stuff as they can and just kind of cobble it together to make a game. This is the 

01:05:16    
opposite of that. This is to make every last thing ourselves so we learn how everything works and then you can decide what to use and what not to use out of other people's stuff and when you do use them, A, you'll be able to fix bugs in them if you want which is pretty awesome, or improve their performance which is also awesome or you can just not use some of them at all. If you decide that something's crappy and you could do a better job, you can do it. And that's pretty important because I don't think we're at the point yet these days where game development tools are perfect. 

01:05:43    
Are you sticking with floats or would you be changing over to fixed point? Floats! Fixed point is a bad idea these days. Hardware likes floating point and wants to do things with floating point. Fixed point ends up costing you a lot of operations. You can do things twice as wide if you do them in fixed potentially if you really worked it out but I don't even think you can. I think you'd still need 32 -bit because of shifting. Yeah, so I think you can't even do twice as wide so I think you're basically always at a lose you're gonna lose performance by going to fixed point so we're definitely not going to fix blank it's a real bad idea on modern hardware I think 

01:06:22    
wouldn't want to expect four pixels per frame at 30fps to look a little jerky not really I'm not really and it looks it does look pretty smooth now that we fix the bug right yeah it looks pretty smooth you can see a little beat frequency which i think is because we're not on the again not you can well and you can also see the rounding so you can see that when it rounds over so when we get some pixel precision in for our drawing that'll fix that as well so that'll be a good thing yeah have you heard anything about hacks what's your opinion on it i i don't have opinion on it. I know Daniel Ben -Morgui uses it to make Ernesto, which is a game that I like a lot, so obviously you can make a game in it that I like. I can tell you that. That's all I know about it. Shouldn't Hero move one pixel per frame to stop jerkiness? No, okay, so I think we covered that. Let's see... 

01:07:28    
Yesterday you discussed explorative programming. How do you compare that with the Agile development process that's prevalent in software development? Are there major differences between the two?" So Agile software development is... I guess what I would say about that is I don't know what people always mean when they say that because I feel like there's different schools of thought on Agile. Like, I mean, I don't know. I guess I would have to go read what the latest definition of Agile programming is or what you think it means when you say that before I can really give a complete answer. But I guess what I would say is, the problem, or the reason why I think it's important to say things the way I said them versus agile development, is agile development is more about not trying to weigh yourself down with other things you're doing as a productivity measure. I think that's typically how they frame it. But I've never seen them talk about what I talked about, which is why you care about not 

01:08:31    
doing software planning. Because a lot of people think, you know, talk about Agile software development, they just talk about the not doing something, but they don't talk about the why you don't do it in a way that I find compelling. And so the reason that I talked about it the way I did is because hopefully, like drawing that map that I drew of like the project space and the state that it's in, I feel like that crystallizes a lot clearer for people why you care about not doing a lot of upfront design. It's not because you know it's more fun or these other sorts of things which you might say about agile development or because you know it allows you to respond to things more quickly or that sort of stuff. It's more because there is no way to set the waypoints correctly for your map. If you could, then software planning would actually be very useful, right? And it's the fact that you can't set the waypoints is why it's not. So I don't know. So I don't necessarily know if I disagree with things 

01:09:29    
in Agile development or not, because I haven't read much about the latest discussion. Last time I read about Agile software development it was probably like 2001 or something like this. It was probably quite some time. Might have been, actually, might have been a little longer than that. But I read about Agile development when it first came out, let me put it to you that way, which was a long, long time ago. And so I'm not really prepared to talk about the comparison too much there. All I would say is I agree with it to the extent with which it lines up with what I said yesterday. And if it doesn't line up with that, then I don't. 

01:10:05    
Was procrastination a problem for you? Yes, it is absolutely a problem for me. I think it's a problem for everyone. When you hit a hard problem, 

01:10:16    
the tendency is to try to go do something else. It's easier, right? And so, procrastination is a problem, and I talked about this a little bit. I think the key to solving procrastination is to force yourself to do a little bit of programming on the problem every day. Because you may get to a point where you literally can't do eight hours of programming on the problem. And you can try to force yourself to do it, but you won't, right? 

01:10:42    
And so the key is to never let it drop to zero. The key is you gotta get through those points by forcing yourself to do an hour or two hours a day. Do whatever you have to do to force yourself to do two hours of programming on a hard problem every day. Even if the programming is useless and sucks, just type in two hours of code a day. And that will get you through a lot of those procrastination points. Because they do happen. And the key is to not stop. If you stop programming, you could procrastinate forever. But if you program two hours a day, eventually you will randomly hit on the thing that gets you to move forwards. 

01:11:20    
Do you think C++ is easier than C -sharp because I took C -sharp this semester and it was a pain in the butt? That's more of a pre -stream question, so come at the beginning of the stream and I answer questions like that. Try to keep the questions about what we're doing for now. Could all the print outputs have impact on the framerate and be the cause of the roughed input? No, not really. Although I should get rid of those. This machine has plenty of CPUs in it. It's definitely not - plenty of cores. it's definitely not going to be a problem to have windows print out there's a little bit of a sync point thing that happens there but no it's not not and we've solved the jerkiness so we know what it was it was the fact that we didn't set the DT in the right place 

01:12:07    
use some space on the top or bottom of the screen for statistics and UI well we'll talk about a little bit that's a design concern but we can talk We'll talk about that a little later. The desktop v -sync issue will only be a problem on Windows Vista Plus, which means we can use the command to get it from the DWM there and use the direct draw one on Windows XP. The v -sync timing. Is there a DWM v -sync timing, though, or just refresh rate? Can we pack the colors in a struct? Yes, I think I talked about that on the stream. Is there a reason for choosing the tiles to be square except for ease of use? There's no particular reason, in terms of code, we could make the tiles any size we want, but I feel like making them square makes it easy for the player to reason about them. Because they know roughly that if they are moving up, they will cross the same number of tiles as if they're moving left in a certain amount of time. So I feel like that's a little easier for them? I don't know. That could 

01:13:07    
be just me, but I feel like design -wise it's probably a good idea to stick with square tiles. But I don't know. Just something to think about. 

01:13:20    
Do you add anything to your almond milk other than soaked almonds and water? No. From yesterday's stream, how can you tell the difference between needing to correct the direction you're taking your design and an actual fundamentally hard problem? Is it usually just obvious at the time? No, you should... it has nothing to do with obviousness. It's actually... they're two different things. So what you have to understand is, you should always... Problems in programming are never really about design. Or architecture of the code. Basically, solving a problem in programming is about whether the code works. Right? So you know whether you've solved the hard problem as to whether the code works and executes in the amount of time that it needs to execute in. That is solving the problem. So you need to do that first, and that has nothing to do with your design walk. That is just, did you write a piece of code that works at all? Once you have the piece of code that works and meets the specifications 

01:14:19    
that you have for it, right, so it's like, I want to do this renderer, it needs to run in this amount of time, so I'm like, getting some code that can actually do the blip or do the whatever, draw the rectangle, whatever, in the amount of milliseconds that I said it had to do. So you do that first. And that is the part that is the hard or easy problem. It may be really hard to do that, and you've got to spend three months doing all kinds of crazy assembly optimizations to figure out how to get that to work. But you do that, and that has nothing to do with the design. That is strictly about getting an isolated piece of code where you can do anything you want, anything at all, and getting it to work. Then there's the problem of how do you integrate that into the design of the code? And that is just a fundamentally yes or no thing. It's like, here are the constraints on this piece, it has to do these things, So how do we make it do those things within the context of our program? We make the 

01:15:08    
changes necessary to do that and we move forward, right? So what you're doing at that point is you're always sort of just doing a check on how clean is this at this point when I integrate it in. If my answer is things are getting very hairy now and I can't manage them, then you know that you shouldn't move forward yet. You know that you kind of have to go through, rework some things, pull some things out. But that's not about solving a problem. That's just about structuring the code. You know, look at it, what are the reasons why it's getting hard for you to manage? What are the reasons why it's hairy? Decide how to fix those and move forward. So separate the two, you gotta separate the two. There really aren't hard code structure problems. They usually just emerge by themselves. But sometimes, I guess the one caveat I would say is that sometimes you hit the limitations of the language. And that's usually when I go to metaprogramming. But, you know, if you hit the limitations of the language 

01:16:01    
you may be stuck in a place where you're just like okay we gotta accept some badness so things are not going to be ideal and that's just the way it goes or you like like I say you go you go metaprogramming and you solve it that way 

01:16:17    
would it be so bad if the tiles were rectangular if you ortho project a square from three quarter overhead do you get a rectangle anyway it's not that it's bad it's that it's harder for the player to reason about um this is like a big thing that people don't i think appreciate But, you know, in the old days, anyone could pick up a NES controller and play a NES game. Nintendo Entertainment System, right? And part of the reason is because it was 2D, things moved at a consistent rate on the screen, and most people can intuit two -dimensional motion like that very easily. When we started moving to, like, 3D games and a lot of this other stuff, you fundamentally lose a bunch of players, in my opinion, who just, they don't have that 3D intuition. They don't know how to project distances in a rectangular fashion like the way you're talking about. And so modern gamers who play a lot of games nowadays can do it trivially. They totally get perspective projection or orthographic projection of vectors 

01:17:09    
and they know how to ballpark those figures, but it just makes it a lot harder. And like even a modern game that I like a lot, because I mentioned Binding of Isaac earlier, even a modern game that I like a lot can really make it hard for the player. like Binding of Isaac, it's impossible to tell whether your shots are going to hit something or not. Like, it takes a long time to learn that, because it's this weird pseudo -3D height -based thing, and like, in the old days, if a bullet hit your sprite, and they collided, then they collided. Right? And that's really easy for people to understand. And so, a lot of the things that I'm doing with the design of this game is trying to make it easy for people to understand the rules and how the game works in that way. Right? So that they can just see, if a thing hits my guy, then it hit the guy. And it's not about whether that was accurate in 3D or whatever. It's just easy for people to see and understand. So I want to avoid rectangles, because that 

01:17:58    
forces the player to do this kind of projection understanding in their head of how that works. 

01:18:07    
What debugger do you use on Linux? I hate Linux debuggers. They're awful. I've never found one that's any good. I would say best of luck to you. I'm really hoping someone someday makes a good Linux debugger. We don't have one yet. and that's too bad but I've never found a debugger on Linux that was that was even remotely usable and I wish I had Linux VM on this machine right now I would boot it up for you and show you just why I think they're so bad because people sometimes are like oh it's fine use blah blah blah use code blocks or use Qt Creator whatever and no they're all awful they just don't work at all And a lot of times you gotta go back to command line GDB to even get stuff. Um, it's awful. It's real, real awful. Um, yeah. Linux debuggers are absolutely terrible. And so, that's actually what makes developing on Linux bad right now. I - I actually like developing on Linux right up to that point. Um, everything else is okay for me now. Uh, I can use Emacs and it works the same, obviously, 

01:19:10    
as on Windows and all that stuff. And just, yeah, it's real bad. Real, real bad. I really want it to get solved, cause I - I prefer - I would prefer to use Linux. most of the time, um, and, and really that's the thing that really makes it hard for me. 

01:19:31    
Let's see. 

01:19:35    
Why do we see nine threads exiting at the end of the program in debug output? Where are they coming from? So, unfortunately, you will see this sort of thing a lot. Um, so he's, the, the question, the person who's asking the question was asking about this stuff. So, uh, actually what you'll notice, you can actually see these a little more explicitly if you'd like. If we set a breakpoint in our program, uh, you can actually click on this threads window thing here and see them all, right? Uh, and if, if you look, uh, if you don't have that window, um, it's in debug, windows, uh, where is it? Threads. It's down here. Uh, this is the thing that you wanna, wanna pick. And what you can see is you can actually see by looking at, at where those threads are and who created them. and you can see what's going on a little bit more clearer. So you've got basically Windows creating all of these threads. Some of them are system threads in NTDLL, so we can't really tell who is behind them. Other ones we 

01:20:29    
can tell very clearly. These are direct sound threads. There's three of them. Because how could you possibly make sound output with less than three threads? So they're there. And then MMDevAPI, I'm not sure what that is. I don't know if that's the multimedia services. I'm not sure what that is. Yeah, I don't know. I'm not sure. If you go here, you can see the stack a little more explicitly, but usually it doesn't tell you anything. Again, they're all kind of nameless places. It may be that if you install... you can install empty symbols. There's a thing you can install that's like... let me see if I can find it. Windows debug symbols. 

01:21:08    
So... ok, so this thing, right, if you follow the instructions on here, or if you install Windows Symbol Server or these sorts of things, you can actually get symbols for some of this stuff sometimes where it will tell you what functions these threads are in. I don't know if that makes sense, but it would basically tell you what the function names were here. And so if you're really curious about what each thread is doing, install that Symbol Server and take a look at this window and you may get a little more insight into it. So I hope that helps. But those are the threads that are exiting. 

01:21:44    
How many more hours required to get the Win32 layer to shippable quality? Oh, well, so I guess what I would say is if I was programming on my own, I would say it would probably take two weeks of time, maybe. 

01:22:08    
If I was really programming and seriously for two weeks straight. So I suspect it's going to take up a huge chunk. It'll probably take up 50 days on the stream to do a shippable Win32 layer. Now that's my idea of a shippable Win32 quality, a shippable Win32 layer. Other people certainly ship things that are not perhaps as complete as what I would imagine it should be. So you could argue that we could do it shorter. But when we actually go to do that shippable layer, it's, it's a pretty big undertaking. Uh, that's why I didn't do it, that's why I didn't do it now, is because, uh, I felt like we would be sitting here for a hundred days, you know, doing nothing but Win32, and I didn't think that was productive. So I just did the minimum necessary to kind of get something up and running. So, not the absolute minimum, but, you know, not much more than that. 

01:23:03    
Are we locked into a tile size once we get going, or can we make that dynamic per level or per room later in the project? 

01:23:11    
We certainly could make it dynamic. I don't think I will make it dynamic, because I want it to be consistent for the player. Like, I want the player to always see the same tile size everywhere. So I probably won't make it dynamic, but it's not a big deal to write the code to be dynamic. And we probably will sort of write the code to be a little bit dynamic, in the sense that we'll probably be able to change the pixel size of the tiles at any time when we actually get there, to that point. uh, without, so without having really had to, to change any code. Uh, and so we will be doing a little bit of that, but, but I don't think I'm gonna actually ever make the tiles change depending on where you are. I don't think I'll probably do that. 

01:23:56    
Didium timing info dot qpc v blank is the qpc value before the v blank. Okay, so that's, uh, that would be what we need, if that makes sense. But again, I'm not sure that we really need to do that. I don't know. It seems like kind of a waste of time to go chasing vertical retrace sync on our prototype layer. But if you guys want to do it, you could always do it too in your copy of the platform layer if you'd like. 

01:24:22    
Let's see. Why do you not clean up your code? It will be harder to find bugs if you do not. Which code are you talking about that you would like to see cleaned up? 

01:24:32    
Let's see. 

01:24:37    
What do you think if you sell a t -shirt from Handmade Hero and write on them, I learned how to make a game from scratch, I will buy it. Good to know. I don't know. Go post on the forums if you want to do t -shirts, we could think about it. I don't know. I haven't given any thought to it yet. Sorry. 

01:24:58    
With your compression -based approach, do you find yourself writing facades for everything so that both you and others you're working with can to access your individual modules, regardless of how you've implemented it. 

01:25:10    
So I don't know what you mean by facades. Typically what I will do is I do expose interfaces that are relatively clean if I'm exporting it to someone else. I will typically expose interfaces that I think are clean and insulate me from having to worry about them doing anything too specific with my code that I know that I might want to change if that's the question you're asking but facade is kind of a loaded word because that's not very specific so yeah what's wrong with GDB basically what's wrong with GDB is it does not display data in a convenient way it does not provide you a quick good visualization of your source code your Your source code, your assembly, your registers, your watch, your debug output. 

01:26:05    
Visual Studio does a very good job of that relative to other debuggers, and GDB does not. It's really bad at that. Why not use Clang? I do use Clang on Linux. I always use Clang. 

01:26:23    
Let's see... 

01:26:27    
I am a young adult who would like to get into coding, but everywhere I go lands up with the same stuff, which leads to be boring and not interactive. How does one learn code? That is a good question for the pre -stream. Come to a stream early sometime, usually like 15 minutes before the Handmade Hero broadcast starts. Come there and ask. We talk about that sort of stuff in the pre -stream all the time. 

01:26:50    
Since how you arrange the elements in your struct can influence the size. Is there a rule to follow on how to organize your structure? Yes. I think we talked about this. Basically, it's about padding. You might want to post on the forums about that, actually, because I've talked about this extensively on previous episodes. And maybe they could link you to where it was. 

01:27:12    
Let's see. 

01:27:19    
A Melcher says, you just have to right -click the stack frame in the call stack view and download from MS symbol servers really just do that automatically where you guys talking about load this or and let's try it load symbols that work whoa holy cow that's a lot easier than it used to be Wow, can I do that here too? 

01:27:53    
Oh man, that is a lot easier than it used to be, guys. That is pretty cool. That is pretty cool. Alright, so if that's true, that we could do that for everything, then that's pretty handy. So let's say we take one of these threads that we don't know what it is. We could go to, I think we can just double -click on it or something to switch to it, right? How do I switch to it? Switch to thread. So if I right -click on it and hit switch to thread, right? now I should be looking at this threads yeah there we go look at that NT wait for work via worker factory oh god maybe I didn't want to see this look at all this 

01:28:36    
oh alright well now you can see what they actually are you can see D sound waiting in here let's see wait for multiple objects these guys are just all waiting on handle space they're waiting for a trigger, something to trigger them. ZWTraceControl, oh it's event tracing for Windows! Oh god, event tracing for Windows is, is, ugh, I hate event tracing for Windows. That's who that is. 

01:29:03    
TPPWaiterPthread, I don't know what TPP is, that's probably Threadpool maybe? So we can't really tell what these guys are doing because they're really just sitting around waiting to do work. Um, and so we don't actually know what it is that they're doing, what they would be doing when the work comes. So they could be doing any sort of, any number of things, essentially. Yeah. So not very lightening there, but that's a pretty cool trick. Right clicking on this call stack and doing that load symbols thing was pretty cool. It's gone now because it's already been loaded, but right clicking on the call stack on somewhere that you don't know, like NTDLL and hitting load symbols, it totally worked. That's great. Thanks for the tip. 

01:29:41    
Is there any thought to using GDI plus to help from a bridge between GDI and DX. Not really, because we're just prototyping. So we don't care about this at all. We're going to switch to OpenGL or Direct3D for the shippable version. I think that we're at the end of the stream here. So I'm just going to double click through the questions real quickly and see if there's anything else that I need to do that should be addressed. Let's see. 

01:30:06    
What if we don't use rooms at all, just have levels that scroll? So I don't want to do scrolling because I I want the rooms to be able to do the self -contained sort of puzzle -slash -encounter thing where, like, you walk in and, like, again, like the original Legend of Zelda did, where you lock the doors and the player has to deal with what's in there first before they can move on. So I don't really want scrolling. I want the player to think about the screens as individual screens that are self -contained, for the most part. I want that feel of the game so I don't really want to have to do scrolling I want to be able to have it look nice when it's just one screen and not rely on scrolling for that. Let's see, ok. 

01:30:59    
Someone says, assert assumptions and draw a rectangle. well we could I don't know if I really want to do that though so basically what the person is suggesting is this they're want to do something along the lines of make sure that each of the color values is where we think it should be right Because we said that these have to be in that range, right? The reason I'm not super concerned about that... I mean, oops. That's supposed to be a less than. The reason I don't love that idea is because in practice, I don't think we're actually going to care. I think we'll be able to... the way that we do it, we'll probably do something that does saturation. So that you can actually pass 1 .5 and it'll be fine. And we also may decide to do something with high dynamic range where we actually need to Allow twos and threes and fours or something who knows so I don't want to do that but I wouldn't Say if you were certain that you always wanted exactly this in the future and you never wanted to deal with 

01:32:16    
color vials any other Way than those assertions are are probably okay But for right now, I don't know that I want to go that route if anything what I would probably do is clamp them Um, like I'd actually go ahead and clamp the RGB values, but I don't think that's necessary at the moment. Um, so, alright. I think, oh, why do you hate event trace? I will answer that one question just because I really hate event trace. Uh, and I'll show you why. Um, go to mollyrocket .com Casey, that is me. post 29 the worst API ever made this blog post should answer your question as to why I hate event tracing for Windows with a passion so yeah please check that out if you want to know why I hate event tracing all right everyone thank you very much for joining me I hate to say it but we've got a tile map and a player on the screen who can stop us now right this is going to get fun real real soon here. I'm kind of happy with the way this is going. We're going to start to have an actual game happening here. 

01:33:25    
We have so much stuff to talk about. We've got the renderer to do. We've got to soon talk about coordinate systems because we don't want to be in pixels going forward and stuff. We've got tons of stuff to do and we've got tons of stuff to explain and investigate in detail. So I don't want to say that we're going to be in like oh the game is totally up and running anytime soon or anything like that, but I'm just saying it's kind of fun to have a little thing moving around on a tile map and pretty soon we're to have something that's actually kind of playable right like we're going to have a little rectangle running around going between tile maps and fighting a little rectangle monster and I don't know if you're like me you kind of get excited about these sorts of things I think one of the things that says that you're going to be a programmer in in your life is when you get excited about the simple things right because anyone gets excited about a bunch of really cool sprites flying around 

01:34:10    
on the screen and doing stuff that's not hard to get excited about but when you're excited about the little things it says something about probably where your inclinations lie. So thank you so much for joining me. If you would like to have a copy of the source code to work on yourself at home, you can pre -order the game here on handmadehero .org. Just click on the pre -order button. You will get an email with a link that allows you to download the source code every day. After I finish it, I upload it and you will be right in the same place that I am. And if you just want to kind of play around with things, that's a good way to do it. If you just want to kind of drop it in and play with things a little bit yourself. If you would like to support the series, we do have a Patreon you can subscribe to. Just go ahead and click on that Patreon. And also we have a great forums community that people have been really doing some amazing work on and it's just a great site. So if you click on here 

01:34:55    
and go news and forums, the main page has the schedule that I post every Monday so you can see when all the times are going to be. There's an episode guide that some volunteers do that's just awesome. You can go on here and look at past episodes and they're all kind of linked with like kind of time values and everything. It's just fantastic the the work they've been doing on that, it's just great. And then there's a coding resources page, which has ports. It's got ports to Mac OS X, ports to Linux, other things about Windows as well. Someone even is working on a port to Swift. If you're interested in that, it's crazy how much porting is going on, it's great. And then there's also other materials on there for like editors and stuff. And then the code discussion forums are on here. There's a bunch of stuff where people talk about things where they're having trouble working on stuff, all sorts of things. So again, check all that out. It's a great site and the people on it have been really 

01:35:41    
great. So I highly encourage it. All right. We will be back here again 10 a .m. Every day. So 10 a .m. Tomorrow as well I will be back here and we will get our guy Maybe colliding with the tile map and maybe walking to new tile maps. I don't know what we'll do We'll do whatever comes to mind Again to try and get ourselves in a position where we have a little zygote game running So we can start to sort of think about what we want the architecture to be and we can start building it up Into some proper pieces what we're trying to get to really is having the renderer set up the way we want so that we can sort of say what the renderer needs to do so we're kind of keep pushing towards that and I hope you will join me for that because I think it's gonna be a lot of fun so thank you for joining me and and Merry Christmas Eve for those of you who celebrate Christmas alright thanks everyone and I will see you tomorrow 
