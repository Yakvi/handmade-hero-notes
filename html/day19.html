<meta charset="UTF-8">
<meta http-equiv="content-type" content="text/html;charset=UTF-8">
<meta name="viewport" content="width=600, initial-scale=1">
<link rel="stylesheet" href="../css/html-style.css">
<link rel="stylesheet" href="../css/style.css">

<script type="text/x-mathjax-config">MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "AMS"} } });</script><span style="display:none">$$\newcommand{\n}{\hat{n}}\newcommand{\thetai}{\theta_\mathrm{i}}\newcommand{\thetao}{\theta_\mathrm{o}}\newcommand{\d}[1]{\mathrm{d}#1}\newcommand{\w}{\hat{\omega}}\newcommand{\wi}{\w_\mathrm{i}}\newcommand{\wo}{\w_\mathrm{o}}\newcommand{\wh}{\w_\mathrm{h}}\newcommand{\Li}{L_\mathrm{i}}\newcommand{\Lo}{L_\mathrm{o}}\newcommand{\Le}{L_\mathrm{e}}\newcommand{\Lr}{L_\mathrm{r}}\newcommand{\Lt}{L_\mathrm{t}}\newcommand{\O}{\mathrm{O}}\newcommand{\degrees}{{^{\large\circ}}}\newcommand{\T}{\mathsf{T}}\newcommand{\mathset}[1]{\mathbb{#1}}\newcommand{\Real}{\mathset{R}}\newcommand{\Integer}{\mathset{Z}}\newcommand{\Boolean}{\mathset{B}}\newcommand{\Complex}{\mathset{C}}\newcommand{\un}[1]{\,\mathrm{#1}}$$
</span>
<span class="md"><p><title>Day 19. Improving Audio Synchronization</title><div class="title"> Day 19. Improving Audio Synchronization </div>

<div class="afterTitles"></div>
<em class="underscore">Video Length (including Q&A): <a href="https://hero.handmade.network/episode/code/day019/">1h45</a></em> 

</p><p>

Welcome to &ldquo;Handmade Hero Notes&rdquo;, the book where we follow the footsteps of <a href="https://handmadehero.org/">Handmade Hero</a> in making the complete game from scratch, with no external libraries. If you'd like to follow along, preorder the game on <a href="https://handmadehero.org/">handmadehero.org</a>, and you will receive access to the GitHub repository, containing complete source code (tagged day-by-day) as well as a variety of other useful resources.

</p><p>

When we left off last time, our audio had many issues. They came to light after we finished implementing our timed frame loops, so our objective for the next couple of days is to make them go away. 

</p><p>

At the start of the program, we're opening a sound buffer which is outputting 48000 samples every second to the sound card. These are groups of one value for the left and one value for the right audio channel, representing sound amplitude at a point in time. We take 48000 amplitude points, pass them to the sound device which eventually reconstructs the wavelength to the speakers. 

</p><p>

This really is just a first step in sound output, our values undergo a lot of transformations on the way out. While it's somewhat a topic for another day, we can say that the samples are but an approximation of what we will hear in the end. Additionally, it's not actually possible to perfectly synchronize sound output with what you see on the screen due to the delays happening at all stages, some of which external to the computer! In any case, our goal is to prevent <em class="underscore">really bad</em> sync issues, even before it gets to the hardware. 

</p>
<div class="longTOC"><p align="center">
    <span align="right"><a href="day18.html">Day 18</a></span>
    <a href="../index.html"><img src = "../media/logo.png"></a>
    <span align="left"><a href="day20.html">Day 20</a></span>
</p><p><a href="#" class="tocTop">(Top)</a><br/>
&nbsp;&nbsp;<a href="#/propertimetracking" class="level2"><span class="tocNumber">0.1&nbsp; </span>Proper Time Tracking</a><br/>
<a href="#visualizethecursors" class="level1"><span class="tocNumber">1&nbsp; </span>Visualize the Cursors</a><br/>
&nbsp;&nbsp;<a href="#visualizethecursors/displaytheplaycursor" class="level2"><span class="tocNumber">1.1&nbsp; </span>Display the Play Cursor</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#visualizethecursors/displaytheplaycursor/writeusagecodefirst" class="level3"><span class="tocNumber">1.1.1&nbsp; </span>Write Usage Code First</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#visualizethecursors/displaytheplaycursor/processtheplaycursorstodraw" class="level3"><span class="tocNumber">1.1.2&nbsp; </span>Process the Play Cursors to Draw</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#visualizethecursors/displaytheplaycursor/writetheline-drawingfunction" class="level3"><span class="tocNumber">1.1.3&nbsp; </span>Write the Line-drawing Function</a><br/>
&nbsp;&nbsp;<a href="#visualizethecursors/displaythewritecursor" class="level2"><span class="tocNumber">1.2&nbsp; </span>Display the Write Cursor</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#visualizethecursors/displaythewritecursor/compresstimemarkersintoastruct" class="level3"><span class="tocNumber">1.2.1&nbsp; </span>Compress Time Markers Into a Struct</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#visualizethecursors/displaythewritecursor/introducewin32drawsoundbuffermarker" class="level3"><span class="tocNumber">1.2.2&nbsp; </span>Introduce <code>Win32DrawSoundBufferMarker</code></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#visualizethecursors/displaythewritecursor/addwritecursordisplay" class="level3"><span class="tocNumber">1.2.3&nbsp; </span>Add WriteCursor Display</a><br/>
<a href="#addressdebugoutputresults" class="level1"><span class="tocNumber">2&nbsp; </span>Address Debug Output Results</a><br/>
&nbsp;&nbsp;<a href="#addressdebugoutputresults/inspectplaycursors" class="level2"><span class="tocNumber">2.1&nbsp; </span>Inspect Play Cursors</a><br/>
&nbsp;&nbsp;<a href="#addressdebugoutputresults/checkdocumentationonmsdn" class="level2"><span class="tocNumber">2.2&nbsp; </span>Check Documentation on MSDN</a><br/>
&nbsp;&nbsp;<a href="#addressdebugoutputresults/inspectsoundstream" class="level2"><span class="tocNumber">2.3&nbsp; </span>Inspect Sound Stream</a><br/>
&nbsp;&nbsp;<a href="#addressdebugoutputresults/changeplaycursorsnapshot" class="level2"><span class="tocNumber">2.4&nbsp; </span>Change PlayCursor Snapshot</a><br/>
&nbsp;&nbsp;<a href="#addressdebugoutputresults/inspectcursorlogic" class="level2"><span class="tocNumber">2.5&nbsp; </span>Inspect Cursor Logic</a><br/>
&nbsp;&nbsp;<a href="#addressdebugoutputresults/printoutcursorlogicvalues" class="level2"><span class="tocNumber">2.6&nbsp; </span>Print Out Cursor Logic Values</a><br/>
&nbsp;&nbsp;<a href="#addressdebugoutputresults/determinesoundcardgranularity" class="level2"><span class="tocNumber">2.7&nbsp; </span>Determine Sound Card Granularity</a><br/>
&nbsp;&nbsp;<a href="#addressdebugoutputresults/inspectwritecursors" class="level2"><span class="tocNumber">2.8&nbsp; </span>Inspect Write Cursors</a><br/>
<a href="#recap" class="level1"><span class="tocNumber">3&nbsp; </span>Recap</a><br/>
<a href="#sidedebugging" class="level1"><span class="tocNumber">4&nbsp; </span>Side Debugging</a><br/>
&nbsp;&nbsp;<a href="#sidedebugging/accessviolationinwin32debugdrawvertical" class="level2"><span class="tocNumber">4.1&nbsp; </span>Access Violation in <code>Win32DebugDrawVertical</code></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sidedebugging/accessviolationinwin32debugdrawvertical/inspectthepixelaccesslogic" class="level3"><span class="tocNumber">4.1.1&nbsp; </span>Inspect the Pixel Access Logic</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sidedebugging/accessviolationinwin32debugdrawvertical/stepthrough" class="level3"><span class="tocNumber">4.1.2&nbsp; </span>Step Through</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sidedebugging/accessviolationinwin32debugdrawvertical/inspectcomputationofx" class="level3"><span class="tocNumber">4.1.3&nbsp; </span>Inspect Computation of X</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sidedebugging/accessviolationinwin32debugdrawvertical/debugconclusion" class="level3"><span class="tocNumber">4.1.4&nbsp; </span>Debug Conclusion</a><br/>
<a href="#sideconsiderations" class="level1"><span class="tocNumber">5&nbsp; </span>Side Considerations</a><br/>
&nbsp;&nbsp;<a href="#sideconsiderations/windowscoreaudio" class="level2"><span class="tocNumber">5.1&nbsp; </span>Windows Core Audio</a><br/>
<a href="#navigation" class="level1"><span class="tocNumber">6&nbsp; </span>Navigation</a><br/>
</p></div><a class="target" name="propertimetracking">&nbsp;</a><a class="target" name="/propertimetracking">&nbsp;</a><a class="target" name="toc0.1">&nbsp;</a><h2>Proper Time Tracking</h2>
<p>


One thing we need to get out of the way first though is a bug we introduced last time: we aren't timing our frames correctly. If you run the game and take a look at the timing outputs (in the <code>Output</code> window of your debugger), you'll notice that each frame always runs for more than 33.33ms/f we intend it for. This is because we currently have the following structure in our code: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-comment">// ...</span></span>
<span class="line"><span class="hljs-comment">// Do some work</span></span>
<span class="line"><span class="hljs-comment">// ...</span></span>
<span class="line"></span>
<span class="line">LARGE_INTEGER WorkCounter = Win32GetWallClock();</span>
<span class="line">f32 WorkSecondsElapsed = Win32GetSecondsElapsed(LastCounter, WorkCounter);</span>
<span class="line"></span>
<span class="line">f32 SecondsElapsedForFrame = WorkSecondsElapsed;</span>
<span class="line"><span class="hljs-keyword">if</span> (SecondsElapsedForFrame &lt; TargetSecondsPerFrame)</span>
<span class="line">{</span>
<span class="line">    <span class="hljs-comment">// Go to sleep</span></span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hljs-comment">// ... </span></span>
<span class="line"><span class="hljs-comment">// Do more work (blit)</span></span>
<span class="line"><span class="hljs-comment">// ... </span></span>
<span class="line"></span>
<span class="line">LARGE_INTEGER EndCounter = Win32GetWallClock();</span>
<span class="line">f32 MSPerFrame = <span class="hljs-number">1000.0f</span> * Win32GetSecondsElapsed(LastCounter, EndCounter);</span>
<span class="line">LastCounter = EndCounter;</span></code></pre><p>

What we really need is to snap our <code>LastCounter</code> directly after we finished sleeping. Even if it won't technically happen at the very end of the frame, when the program loops back the timing will be correct, and the sleep will happen for the correct amount of time: 

</p><pre class="listing tilde"><code><span class="line">LARGE_INTEGER WorkCounter = Win32GetWallClock();</span>
<span class="line">f32 WorkSecondsElapsed = Win32GetSecondsElapsed(LastCounter, WorkCounter);</span>
<span class="line"></span>
<span class="line">f32 SecondsElapsedForFrame = WorkSecondsElapsed;</span>
<span class="line"><span class="hljs-keyword">if</span> (SecondsElapsedForFrame &lt; TargetSecondsPerFrame)</span>
<span class="line">{</span>
<span class="line">    <span class="hljs-keyword">while</span> (SecondsElapsedForFrame &lt; TargetSecondsPerFrame)</span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-keyword">if</span> (SleepIsGranular)</span>
<span class="line">        {</span>
<span class="line">            DWORD SleepMS = (DWORD)(<span class="hljs-number">1000.0f</span> * (TargetSecondsPerFrame -</span>
<span class="line">                                               SecondsElapsedForFrame));</span>
<span class="line">            <span class="hljs-keyword">if</span> (SleepMS &gt; <span class="hljs-number">0</span>)</span>
<span class="line">            {</span>
<span class="line">                Sleep(SleepMS);</span>
<span class="line">            }</span>
<span class="line">        }</span>
<span class="line">        </span>
<span class="line">        SecondsElapsedForFrame = Win32GetSecondsElapsed(LastCounter,</span>
<span class="line">                                                        Win32GetWallClock());</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"><span class="hljs-keyword">else</span></span>
<span class="line">{</span>
<span class="line">    <span class="hljs-comment">// TODO(casey): MISSED FRAME RATE!</span></span>
<span class="line">    <span class="hljs-comment">// TODO(casey): Logging</span></span>
<span class="line">}</span><div class=" add"><span class="line"></span>
<span class="line">LARGE_INTEGER EndCounter = Win32GetWallClock();</span>
<span class="line">f32 MSPerFrame = <span class="hljs-number">1000.0f</span> * Win32GetSecondsElapsed(LastCounter, EndCounter);</span>
<span class="line">LastCounter = EndCounter;</span></div><span class="line"></span>
<span class="line"><span class="hljs-comment">// ... </span></span>
<span class="line"></span>
<span class="line">game_input *Temp = NewInput;</span>
<span class="line">NewInput = OldInput;</span>
<span class="line">OldInput = Temp;</span><div class=" delete"><span class="line"></span>
<span class="line">LARGE_INTEGER EndCounter = Win32GetWallClock();</span>
<span class="line">f32 MSPerFrame = <span class="hljs-number">1000.0f</span> * Win32GetSecondsElapsed(LastCounter, EndCounter);</span>
<span class="line">LastCounter = EndCounter;</span></div><span class="line"></span>
<span class="line">u64 EndCycleCount = __rdtsc();</span>
<span class="line">s64 CyclesElapsed = EndCycleCount - LastCycleCount;</span>
<span class="line">LastCycleCount = EndCycleCount;</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;1:</b> <file>[win32_handmade.cpp > WinMain]</file> Timing frames correctly.</div></center>
<p>


We also want to correct the sleep cycle itself. We already sleep for exact amount of <em class="underscore">milliseconds</em>, so to prevent additional checks, we can just spin and wait until the last few <em class="underscore">microseconds</em> elapse: 

</p><pre class="listing tilde"><code><span class="line">f32 SecondsElapsedForFrame = WorkSecondsElapsed;</span>
<span class="line"><span class="hljs-keyword">if</span> (SecondsElapsedForFrame &lt; TargetSecondsPerFrame)</span>
<span class="line">{</span><div class=" edit"><span class="line">    <span class="hljs-keyword">if</span> (SleepIsGranular)</span>
<span class="line">    {</span>
<span class="line">        DWORD SleepMS = (DWORD)(<span class="hljs-number">1000.0f</span> * (TargetSecondsPerFrame -</span>
<span class="line">                                            SecondsElapsedForFrame));</span>
<span class="line">        <span class="hljs-keyword">if</span> (SleepMS &gt; <span class="hljs-number">0</span>)</span>
<span class="line">        {</span>
<span class="line">            Sleep(SleepMS);</span>
<span class="line">        }</span>
<span class="line">    }</span>
<span class="line">        </span>
<span class="line">    <span class="hljs-keyword">while</span> (SecondsElapsedForFrame &lt; TargetSecondsPerFrame)</span>
<span class="line">    {</span>
<span class="line">        SecondsElapsedForFrame = Win32GetSecondsElapsed(LastCounter,</span>
<span class="line">                                                        Win32GetWallClock());</span>
<span class="line">    }</span></div><span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;2:</b> <file>[win32_handmade.cpp > WinMain]</file> Updating Sleep loop.</div></center>
<p>


Finally, even this might not provide you with a 100% correct granularity. You will be missing some microseconds here and there, so let's have a quick test and eventually log and do something about it:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">if</span> (SleepIsGranular)</span>
<span class="line">{</span>
<span class="line">    DWORD SleepMS = (DWORD)(<span class="hljs-number">1000.0f</span> * (TargetSecondsPerFrame -</span>
<span class="line">                                        SecondsElapsedForFrame));</span>
<span class="line">    <span class="hljs-keyword">if</span> (SleepMS &gt; <span class="hljs-number">0</span>)</span>
<span class="line">    {</span>
<span class="line">        Sleep(SleepMS);</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"></span><div class=" add"><span class="line">f32 TestSecondsElapsedForFrame = Win32GetSecondsElapsed(LastCounter, Win32GetWallClock());</span>
<span class="line"><span class="hljs-keyword">if</span>(TestSecondsElapsedForFrame &lt; TargetSecondsPerFrame)</span>
<span class="line">{</span>
<span class="line">    <span class="hljs-comment">// TODO(casey): LOG MISSED SLEEP HERE</span></span>
<span class="line">}</span></div><span class="line">    </span>
<span class="line">    </span>
<span class="line"><span class="hljs-keyword">while</span> (SecondsElapsedForFrame &lt; TargetSecondsPerFrame)</span>
<span class="line">{</span>
<span class="line">    SecondsElapsedForFrame = Win32GetSecondsElapsed(LastCounter,</span>
<span class="line">                                                    Win32GetWallClock());</span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;3:</b> <file>[win32_handmade.cpp > WinMain]</file> Finalizing Sleep Routine.</div></center>

<a class="target" name="visualizethecursors">&nbsp;</a><a class="target" name="visualizethecursors">&nbsp;</a><a class="target" name="toc1">&nbsp;</a><h1>Visualize the Cursors</h1>
<p>


As we output the samples, we try to have some control on when they're going out. And our objective is for our sound to be as close to our target frame as possible. Some platforms have more support for this than the others, and on Windows we have to call <code>GetCurrentPosition</code>. This will return a position that the DirectSound <em class="underscore">believes</em> the audio is playing at (&ldquo;Play Cursor&rdquo;), and another one to which DirectSound is writing sound to (&ldquo;Write Cursor&rdquo;). 

</p>
<a class="target" name="displaytheplaycursor">&nbsp;</a><a class="target" name="visualizethecursors/displaytheplaycursor">&nbsp;</a><a class="target" name="toc1.1">&nbsp;</a><h2>Display the Play Cursor</h2>

<a class="target" name="writeusagecodefirst">&nbsp;</a><a class="target" name="visualizethecursors/displaytheplaycursor/writeusagecodefirst">&nbsp;</a><a class="target" name="toc1.1.1">&nbsp;</a><h3>Write Usage Code First</h3>
<p>


It will be easier for us to understand the issues if we had a way to visualize these in some way. Let's throw in a simple debug overlay which would draw the cursors over time. Just after we request to display our buffer, we'll write a new <code>#if</code> block that would only run if we're in debug mode (or, how we defined it on <a href="../html/day14.html">day 14</a>, <code>HANDMADE_INTERNAL</code>):

</p><pre class="listing tilde"><code><span class="line">win32_window_dimension Dimension = Win32GetWindowDimension(Window);</span>
<span class="line">Win32DisplayBufferInWindow(&amp;GlobalBackbuffer, DeviceContext, Dimension.Width, Dimension.Height);</span>
<span class="line"></span><div class=" add"><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> HANDMADE_INTERNAL</span></span>
<span class="line"><span class="hljs-comment">// NOTE(casey): This is debug code</span></span>
<span class="line">{</span>
<span class="line">    DWORD DebugPlayCursor;</span>
<span class="line">    DWORD DebugWriteCursor;</span>
<span class="line">    GlobalSecondaryBuffer-&gt;GetCurrentPosition(&amp;DebugPlayCursor, &amp;DebugWriteCursor);</span>
<span class="line">}</span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;4:</b> <file>[win32_handmade.cpp > WinMain]</file> Checking cursor position.</div></center>
<p>


Since it's debug code, we don't really care to test whether the operation <code>SUCCEEDED</code> or not, so we'll skip it here. However, we wrapped this code in braces (<code>{}</code>) to make sure that any variables we declare won't escape and potentially interact with the rest of the code.

</p><p>

We want to visualize more than one cursor, to show some progress. Let's say we want to look at all the cursor positions in the last second: simply take whatever our <code>GameUpdateHz</code> is and create an array of debug cursors of that size. We'll need to keep this array outside of the main loop so that the values are preserved. 

</p><p>

We also need an index to the array so that we know where to write. The index will go from 0 to the size of our collection of cursors, to 0 again, and we'll use it to store the latest cursor position.

</p><p>

<center><div class="image" style=""><a href="../media/day19/rolling_buffer.gif" target="_blank"><img class="markdeep" src="../media/day19/rolling_buffer.gif" /></a><center><span class="imagecaption"><a class="target" name="figure_x">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;1:</b> Rolling buffer advances its index at each iteration.</span></center></div></center> 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-comment">// Just before the main loop</span></span>
<span class="line">game_input Input[<span class="hljs-number">2</span>] = {};</span>
<span class="line">game_input* OldInput = &amp;Input[<span class="hljs-number">0</span>];</span>
<span class="line">game_input* NewInput = &amp;Input[<span class="hljs-number">1</span>];</span>
<span class="line"></span><div class=" add"><span class="line"><span class="hljs-keyword">int</span> DebugLastPlayCursorIndex = <span class="hljs-number">0</span>;</span>
<span class="line">DWORD DebugLastPlayCursor[GameUpdateHz];</span></div><span class="line"></span>
<span class="line">LARGE_INTEGER LastCounter = Win32GetWallClock();</span>
<span class="line">u64 LastCycleCount = __rdtsc();</span>
<span class="line">GlobalRunning = <span class="hljs-literal">true</span>;</span>
<span class="line"><span class="hljs-keyword">while</span> (GlobalRunning)</span>
<span class="line">{</span>
<span class="line">    <span class="hljs-comment">// ... </span></span>
<span class="line">    <span class="hljs-comment">// Our main loop</span></span>
<span class="line">    <span class="hljs-comment">// ... </span></span>
<span class="line"></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> HANDMADE_INTERNAL</span></span>
<span class="line">    <span class="hljs-comment">// NOTE(casey): This is debug code</span></span>
<span class="line">    {</span>
<span class="line">        DWORD DebugPlayCursor;</span>
<span class="line">        DWORD DebugWriteCursor;</span>
<span class="line">        GlobalSecondaryBuffer-&gt;GetCurrentPosition(&amp;DebugPlayCursor, &amp;DebugWriteCursor);</span>
<span class="line">        </span><div class=" add"><span class="line">        Assert(DebugLastPlayCursorIndex &lt; ArrayCount(DebugLastPlayCursor));</span>
<span class="line">        DebugLastPlayCursor[DebugLastPlayCursorIndex++] = DebugPlayCursor; </span>
<span class="line">        <span class="hljs-keyword">if</span> (DebugLastPlayCursorIndex == ArrayCount(DebugLastPlayCursor))</span>
<span class="line">        {</span>
<span class="line">            DebugLastPlayCursorIndex = <span class="hljs-number">0</span>;</span>
<span class="line">        }</span></div><span class="line">    }</span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span>
<span class="line">    <span class="hljs-comment">// ... </span></span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;5:</b> <file>[win32_handmade.cpp > WinMain]</file> Capturing Cursor in a rolling buffer.</div></center>
<p>


You'll notice however that this implementation isn't compilable. This is because C and C++ do not allow array length initialization from a variable (even if we never change that variable at runtime), the array size has to be known at compile time. For the time being, let's change <code>MonitorRefreshHz</code> and <code>GameUpdateHz</code> to <code>#define</code>s.

</p><pre class="listing tilde"><code><span class="line">WindowClass.lpszClassName = <span class="hljs-string">"HandmadeHeroWindowClass"</span>;</span>
<span class="line">    </span>
<span class="line"><span class="hljs-comment">// TODO(casey): How do we reliably query on this on Windows?</span></span><div class=" edit"><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MonitorRefreshHz 60</span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GameUpdateHz (MonitorRefreshHz / 2)</span></span></div><span class="line">f32 TargetSecondsPerFrame = <span class="hljs-number">1.0f</span> / (f32)GameUpdateHz;</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;6:</b> <file>[win32_handmade.cpp > WinMain]</file> You could also simply initialize <code>DebugLastPlayCursor</code> to be of length 30.</div></center>
<p>


In order to display the results, we can draw straight to our render buffer, before we request page flip. Let's create a utility function to keep things well separated, called <code>Win32DebugSyncDisplay</code>. To keep things tidy, we'll also scope this inside <code>#if HANDMADE_INTERNAL</code>.

</p><p>

For this function, we're going to need: 

</p><p>

<ul>
<li class="asterisk">Our render buffer, for the output
</li>
<li class="asterisk">The cursors snapshot array
</li>
<li class="asterisk">The size of the array. Unfortunately C or C++ don't provide a way to know the size of an array once you pass it to another function: what you actually pass is a simple pointer. We can call <code>ArrayCount</code> macro that we've defined previously we'll want to get the size, and pass it separately.</li></ul>

</p><p>

We'll also throw in our sound buffer and the <code>TargetSecondsPerFrame</code> that we might use later. We can always remove them later.

</p><pre class="listing tilde"><code><span class="line">win32_window_dimension Dimension = Win32GetWindowDimension(Window);</span><div class=" add"><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> HANDMADE_INTERNAL</span></span>
<span class="line">Win32DebugSyncDisplay(&amp;GlobalBackbuffer, </span>
<span class="line">                      ArrayCount(DebugLastPlayCursor), DebugLastPlayCursor,</span>
<span class="line">                      &amp;SoundOutput, TargetSecondsPerFrame);</span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span></div><span class="line">Win32DisplayBufferInWindow(&amp;GlobalBackbuffer, DeviceContext, Dimension.Width, Dimension.Height);</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;7:</b> <file>[win32_handmade.cpp > WinMain]</file> Introducing <code>Win32DebugSyncDisplay</code>.</div></center>

<a class="target" name="processtheplaycursorstodraw">&nbsp;</a><a class="target" name="visualizethecursors/displaytheplaycursor/processtheplaycursorstodraw">&nbsp;</a><a class="target" name="toc1.1.2">&nbsp;</a><h3>Process the Play Cursors to Draw</h3>
<p>


Let's focus on what's happening inside <code>Win32DebugSyncDisplay</code>. First, let's define the function just outside the <code>WinMain</code>:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> f32</span>
<span class="line"><span class="hljs-title">Win32GetSecondsElapsed</span><span class="hljs-params">(LARGE_INTEGER Start, LARGE_INTEGER End)</span></span>
<span class="line"></span>{</span>
<span class="line">    <span class="hljs-comment">// ... </span></span>
<span class="line">}</span>
<span class="line"></span><div class=" add"><span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32DebugSyncDisplay</span><span class="hljs-params">(win32_offscreen_buffer *Backbuffer,</span>
<span class="line">                      <span class="hljs-keyword">int</span> LastPlayCursorCount, DWORD *LastPlayCursor,</span>
<span class="line">                      win32_sound_output *SoundOutput, f32 TargetSecondsPerFrame)</span></span>
<span class="line"></span>{</span>
<span class="line">}</span></div><span class="line"></span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> CALLBACK</span>
<span class="line"><span class="hljs-title">WinMain</span><span class="hljs-params">(...)</span></span></span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;8:</b> <file>[win32_handmade.cpp]</file> Defining <code>Win32DebugSyncDisplay</code>.</div></center>
<p>


We should now be compilable, with no changes to how our program operates. Take a second to fix all the outstanding errors you might have thus far.

</p><p>

We won't be doing anything fancy inside this function. We don't have any line drawing library just yet, and we certainly won't going implementing one here. What we want is to: 

</p><p>

<ol start=1>
<li class="number">Find a horizontal point in our render buffer to represent our position in the sound buffer.
</li>
<li class="number">Paint that pixel and several more below in white.</li></ol>

</p><p>

Deciding the X position requires:

</p><p>

<ul>
<li class="asterisk">Subtracting some padding from the left and right sides (so that visualization starts a bit more centered). Let's say for now it will be 16.
</li>
<li class="asterisk">Dividing whatever the remaining width of the render buffer is by the size of the sound buffer. We want to store <code>C</code> as a floating-point number for better precision (as well as cast to float the dividends before the division).</li></ul>

</p><p>

This yields us the coefficient <code>C</code>. We can use it for calculating X positions of each play cursor we get (remember that we need to redraw all 30 cursors each frame!), by simply multiplying the cursor by <code>C</code> (which we cast back to integer) and adding the pad.

</p><p>

As for the Y position, we don't really need to recalculate it. To draw a vertical line, we only need to know the top and bottom points which can be whichever. Let's say we simply add some pads to these as well and call it done. 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-comment">// Win32DebugSyncDisplay</span></span><div class=" add"><span class="line"><span class="hljs-keyword">int</span> PadX = <span class="hljs-number">16</span>;</span>
<span class="line"><span class="hljs-keyword">int</span> PadY = <span class="hljs-number">16</span>;</span>
<span class="line"></span>
<span class="line"><span class="hljs-keyword">int</span> Top = PadY;</span>
<span class="line"><span class="hljs-keyword">int</span> Bottom = Backbuffer-&gt;Height - PadY;</span>
<span class="line"></span>
<span class="line">f32 C = (f32)(Backbuffer-&gt;Width - <span class="hljs-number">2</span> * PadX) / (f32)SoundOutput-&gt;SecondaryBufferSize;</span>
<span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> PlayCursorIndex = <span class="hljs-number">0</span>;</span>
<span class="line">        PlayCursorIndex &lt; LastPlayCursorCount;</span>
<span class="line">        ++PlayCursorIndex)</span>
<span class="line">{</span>
<span class="line">    <span class="hljs-keyword">int</span> X = PadX + (<span class="hljs-keyword">int</span>)(C * (f32)LastPlayCursor[PlayCursorIndex]);</span>
<span class="line">}</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;9:</b> <file>[win32_handmade.cpp > Win32DebugSyncDisplay]</file> Defining line-drawing logic.</div></center>
<p>


But wait, you'll say, we still haven't <em class="underscore">drawn</em> anything yet! For simplicity sake, we'll separate line prepping and actual drawing to a separate function. We might use it for other purposes, so having a generic debug vertical line drawing function will always be handy. To this function we'll pass our render buffer, X position, as well as top and bottom boundaries we just defined. Maybe we can also specify the color here. 

</p><pre class="listing tilde"><code><span class="line">f32 C = (f32)(Backbuffer-&gt;Width - <span class="hljs-number">2</span> * PadX) / (f32)SoundOutput-&gt;SecondaryBufferSize;</span>
<span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> PlayCursorIndex = <span class="hljs-number">0</span>;</span>
<span class="line">        PlayCursorIndex &lt; LastPlayCursorCount;</span>
<span class="line">        ++PlayCursorIndex)</span>
<span class="line">{</span>
<span class="line">    <span class="hljs-keyword">int</span> X = PadX + (<span class="hljs-keyword">int</span>)(C * (f32)LastPlayCursor[PlayCursorIndex]);</span><div class=" add"><span class="line">    Win32DebugDrawVertical(Backbuffer, X, Top, Bottom, <span class="hljs-number">0xFFFFFFFF</span>);</span></div><span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;10:</b> <file>[win32_handmade.cpp > Win32DebugSyncDisplay]</file> Introducing a call to draw vertical line.</div></center>

<a class="target" name="writetheline-drawingfunction">&nbsp;</a><a class="target" name="visualizethecursors/displaytheplaycursor/writetheline-drawingfunction">&nbsp;</a><a class="target" name="toc1.1.3">&nbsp;</a><h3>Write the Line-drawing Function</h3>
<p>


Speaking of drawing, since it's debug code we're going to do the simplest thing imaginable (probably the slowest as well): We'll calculate the starting byte of our top pixel and then loop over the buffer until we reach the bottom pixel, &ldquo;painting&rdquo; each pixel the color requested.

</p><p>

A small refresher might be useful here. If you recall what we discussed on <a href="../html/day5.html">day 5</a>, here's what we can say:

</p><p>

<ul>
<li class="asterisk">Each pixel is 4 bytes big
</li>
<li class="asterisk">Each pixel has a permanent address in the backbuffer memory.
</li>
<li class="asterisk">Each row is represented by <code>Pitch</code>, which is the size of all the pixels in a row
</li>
<li class="asterisk">It's as many rows down as our Y number multiplied by Pitch</li></ul>

</p><p>

Using this information we can find any pixel we want by using only <code>X</code> and <code>Y</code> coordinates (or, in our case, <code>Top</code>):

</p><p>

<ul>
<li class="asterisk">Get the <em class="underscore">base</em> address of the whole buffer. Remember to convert it to <code>u8</code> so that all the advancements happen in single bytes.
</li>
<li class="asterisk">Add to it however many rows we want to skip (<code>Top</code>) multiplied by <code>Pitch</code>.
</li>
<li class="asterisk">Add to this address however many pixels on the final row we want to skip (<code>X</code>).</li></ul>

</p><p>

Once we have completed our operation with the pixel (applied the color), we can simply add <code>Pitch</code> and move on to the next row (while preserving our X location). We continue this way until our Y coordinate reaches Bottom.

</p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32DebugDrawVertical</span><span class="hljs-params">(win32_offscreen_buffer *Backbuffer,</span>
<span class="line">                       <span class="hljs-keyword">int</span> X, <span class="hljs-keyword">int</span> Top, <span class="hljs-keyword">int</span> Bottom, u32 Color)</span></span>
<span class="line"></span>{</span>
<span class="line">    u8 *Pixel = (u8 *)Backbuffer-&gt;Memory +</span>
<span class="line">                Top * Backbuffer-&gt;Pitch +</span>
<span class="line">                X * Backbuffer-&gt;BytesPerPixel;</span>
<span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> Y = Top;</span>
<span class="line">         Y &lt; Bottom;</span>
<span class="line">         ++Y)</span>
<span class="line">    {</span>
<span class="line">        *(u32 *)Pixel = Color;</span>
<span class="line">        Pixel += Backbuffer-&gt;Pitch;</span>
<span class="line">    }</span>
<span class="line">}</span></div><span class="line"></span>
<span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32DebugSyncDisplay</span><span class="hljs-params">(...)</span></span></span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;11:</b> <file>[win32_handmade.cpp]</file> Drawing vertical line.</div></center>
<p>


This won't compile since we decided to remove <code>BytesPerPixel</code> from <code>win32_offscreen_buffer</code>. Let's add it back and initialize it properly in <code>Win32ResizeDIBSection</code>:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">win32_offscreen_buffer</span></span>
<span class="line">{</span></span>
<span class="line">    BITMAPINFO Info;</span>
<span class="line">    <span class="hljs-keyword">void</span> *Memory;</span>
<span class="line">    <span class="hljs-keyword">int</span> Width;</span>
<span class="line">    <span class="hljs-keyword">int</span> Height;</span>
<span class="line">    <span class="hljs-keyword">int</span> Pitch;</span><div class=" add"><span class="line">    <span class="hljs-keyword">int</span> BytesPerPixel;</span></div><span class="line">};</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;12:</b> <file>[win32_handmade.h]</file></div></center>
<pre class="listing tilde"><code><span class="line">WORD BytesPerPixel = <span class="hljs-number">4</span>;</span><div class=" add"><span class="line">Buffer-&gt;BytesPerPixel = BytesPerPixel;</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;13:</b> <file>[win32_handmade.cpp > Win32ResizeDIBSection]</file> Reintroducing <code>BytesPerPixel</code> to <code>win32_offscreen_buffer</code>.</div></center>
<p>


This should be compilable. Build, run and... crash. What happened? If you'd like to follow along on our debugging journey, head over to subsection  <a href="#toc4.1">4.1</a>. Or, you can try and find the bug yourself!

</p><p>

In the end, we'll have our play cursors up and running.

</p><p>

<center><div class="image" style=""><a href="../media/day19/play_cursors.gif" target="_blank"><img class="markdeep" src="../media/day19/play_cursors.gif" /></a><center><span class="imagecaption"><a class="target" name="figure_x">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;2:</b> Play Cursor Display.</span></center></div></center> 

</p><p>

Depending on your computer's sound latency, you might see old cursors overlapping with the new. In that case, you might want to reduce the array size from <code>GameUpdateHz</code> to <code>GameUpdateHz / 2</code>:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">int</span> DebugLastPlayCursorIndex = <span class="hljs-number">0</span>;</span><div class=" edit"><span class="line">DWORD DebugLastPlayCursor[GameUpdateHz  / <span class="hljs-number">2</span>] = {};</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;14:</b> <file>[win32_handmade.cpp > WinMain]</file> (Optional) Reducing amount of cursor positions stored / displayed.</div></center>

<a class="target" name="displaythewritecursor">&nbsp;</a><a class="target" name="visualizethecursors/displaythewritecursor">&nbsp;</a><a class="target" name="toc1.2">&nbsp;</a><h2>Display the Write Cursor</h2>
<p>


Another thing that we can do is to expand our debug drawing function to also draw the write cursor.

</p>
<a class="target" name="compresstimemarkersintoastruct">&nbsp;</a><a class="target" name="visualizethecursors/displaythewritecursor/compresstimemarkersintoastruct">&nbsp;</a><a class="target" name="toc1.2.1">&nbsp;</a><h3>Compress Time Markers Into a Struct</h3>
<p>


First, we'll introduce a new structure that called <code>win32_time_marker</code>. 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">win32_sound_output</span></span>
<span class="line">{</span></span>
<span class="line">    <span class="hljs-keyword">int</span> SamplesPerSecond;</span>
<span class="line">    <span class="hljs-keyword">int</span> BytesPerSample;</span>
<span class="line">    DWORD SecondaryBufferSize;</span>
<span class="line">    u32 RunningSampleIndex;</span>
<span class="line">    <span class="hljs-keyword">int</span> LatencySampleCount;</span>
<span class="line">};</span>
<span class="line"></span><div class=" add"><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">win32_debug_time_marker</span></span>
<span class="line">{</span></span>
<span class="line">    DWORD PlayCursor;</span>
<span class="line">    DWORD WriteCursor;</span>
<span class="line">};</span></div><span class="line"></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WIN32_HANDMADE_H</span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;15:</b> <file>[win32_handmade.h]</file> Introducing <code>win32_debug_time_marker</code> structure.</div></center>
<p>


As you can probably tell, this will be the structure we'll use as our array. We had one value that we were displaying, and now that we want to have more than one value displayed at a time we can simply throw them in a single structure and record them this way. 

</p><p>

Our <code>Win32DebugSyncDisplay</code> becomes thus the following:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32DebugSyncDisplay</span><span class="hljs-params">(win32_offscreen_buffer *Backbuffer,</span></span></span><div class=" edit"><span class="line">                      <span class="hljs-keyword">int</span> MarkerCount, win32_debug_time_marker *Markers,</span></div><span class="line">                      win32_sound_output *SoundOutput, f32 TargetSecondsPerFrame)</span>
<span class="line">{</span>
<span class="line">    <span class="hljs-keyword">int</span> PadX = <span class="hljs-number">16</span>;</span>
<span class="line">    <span class="hljs-keyword">int</span> PadY = <span class="hljs-number">16</span>;</span>
<span class="line">    </span>
<span class="line">    <span class="hljs-keyword">int</span> Top = PadY;</span>
<span class="line">    <span class="hljs-keyword">int</span> Bottom = Backbuffer-&gt;Height - PadY;</span>
<span class="line">    </span>
<span class="line">    f32 C = (f32)(Backbuffer-&gt;Width - <span class="hljs-number">2</span> * PadX) / (f32)SoundOutput-&gt;SecondaryBufferSize;</span><div class=" edit"><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> MarkerIndex = <span class="hljs-number">0</span>;</span>
<span class="line">         MarkerIndex &lt; MarkerCount;</span>
<span class="line">         ++MarkerIndex)</span></div><span class="line">    {</span><div class=" edit"><span class="line">        win32_debug_time_marker *ThisMarker = &amp;Markers[MarkerIndex];</span>
<span class="line">        Assert (ThisMarker-&gt;PlayCursor &lt; SoundOutput-&gt;SecondaryBufferSize);</span>
<span class="line">        f32 XReal = C * (f32)ThisMarker-&gt;PlayCursor;</span></div><span class="line">        <span class="hljs-keyword">int</span> X = PadX + (<span class="hljs-keyword">int</span>)XReal;</span>
<span class="line">        Win32DebugDrawVertical(Backbuffer, X, Top, Bottom, <span class="hljs-number">0xFFFFFFFF</span>);</span>
<span class="line">    }</span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;16:</b> <file>[win32_handmade.cpp]</file> Using <code>win32_debug_time_marker</code> structure. Simple renaming and dereferencing for now, no change of functionality.</div></center>
<p>


Finally, inside <code>WinMain</code> you will see something like this: 

</p><pre class="listing tilde"><code><span class="line">game_input Input[<span class="hljs-number">2</span>] = {};</span>
<span class="line">game_input* OldInput = &amp;Input[<span class="hljs-number">0</span>];</span>
<span class="line">game_input* NewInput = &amp;Input[<span class="hljs-number">1</span>];</span>
<span class="line"></span><div class=" edit"><span class="line"><span class="hljs-keyword">int</span> DebugTimeMarkerIndex = <span class="hljs-number">0</span>;</span>
<span class="line">win32_debug_time_marker DebugTimeMarkers[GameUpdateHz / <span class="hljs-number">2</span>] = {};</span></div><span class="line"></span>
<span class="line">LARGE_INTEGER LastCounter = Win32GetWallClock();</span>
<span class="line">u64 LastCycleCount = __rdtsc();</span>
<span class="line">GlobalRunning = <span class="hljs-literal">true</span>;</span>
<span class="line"><span class="hljs-comment">// ... </span></span>
<span class="line"><span class="hljs-comment">// Most of main loop </span></span>
<span class="line"><span class="hljs-comment">// ... </span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> HANDMADE_INTERNAL</span></span>
<span class="line">Win32DebugSyncDisplay(&amp;GlobalBackbuffer,</span><div class=" edit"><span class="line">                      ArrayCount(DebugTimeMarkers), DebugTimeMarkers,</span></div><span class="line">                      &amp;SoundOutput, TargetSecondsPerFrame);</span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span>
<span class="line">Win32DisplayBufferInWindow(&amp;GlobalBackbuffer, DeviceContext, Dimension.Width, Dimension.Height);</span>
<span class="line"></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> HANDMADE_INTERNAL</span></span>
<span class="line"><span class="hljs-comment">// NOTE(casey): This is debug code</span></span>
<span class="line">{</span><div class=" delete"><span class="line">    DWORD DebugPlayCursor;</span>
<span class="line">    DWORD DebugWriteCursor;</span>
<span class="line">    GlobalSecondaryBuffer-&gt;GetCurrentPosition(&amp;DebugPlayCursor, &amp;DebugWriteCursor);</span>
<span class="line">    </span>
<span class="line">    DebugLastPlayCursor[DebugLastPlayCursorIndex++] = DebugPlayCursor;</span></div><div class=" edit"><span class="line">    Assert(DebugTimeMarkerIndex &lt; ArrayCount(DebugTimeMarkers));</span></div><div class=" add"><span class="line">    win32_debug_time_marker *Marker = &amp;DebugTimeMarkers[DebugTimeMarkerIndex++];</span></div><div class=" edit"><span class="line">    <span class="hljs-keyword">if</span> (DebugTimeMarkerIndex == ArrayCount(DebugTimeMarker))</span>
<span class="line">    {</span>
<span class="line">        DebugTimeMarkerIndex = <span class="hljs-number">0</span>;</span>
<span class="line">    }</span></div><div class=" add"><span class="line">    GlobalSecondaryBuffer-&gt;GetCurrentPosition(&amp;Marker-&gt;PlayCursor, &amp;Marker-&gt;WriteCursor);</span></div><div class="    "><span class="line">}</span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;17:</b> <file>[win32_handmade.cpp > WinMain]</file> Changing <code>DebugPlayCursors</code> array to an array of <code>win32_debug_time_marker</code>s and using them.</div></center>
<p>


We managed to reduce the amount of lines in this code, while increasing functionality! This is what you can call &ldquo;Compression-Oriented Programming&rdquo; style, in which you first write what you need, and the code marches towards better over time. Each time it just gets a little bit better, a little bit cleaner, a little bit more flexible as you go, and everything (hopefully) works out for the best. 

</p>
<a class="target" name="introducewin32drawsoundbuffermarker">&nbsp;</a><a class="target" name="visualizethecursors/displaythewritecursor/introducewin32drawsoundbuffermarker">&nbsp;</a><a class="target" name="toc1.2.2">&nbsp;</a><h3>Introduce <code>Win32DrawSoundBufferMarker</code></h3>
<p>


Now we can quickly compile (to ensure that our old functionality is preserved) and move on. To make use of the new functionality, we can pull out the X-calculating to a separate function and call it twice from <code>Win32DebugSyncDisplay</code>: 

</p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32DrawSoundBufferMarker</span><span class="hljs-params">(win32_offscreen_buffer *Backbuffer,</span>
<span class="line">                           win32_sound_output *SoundOutput,</span>
<span class="line">                           f32 C, <span class="hljs-keyword">int</span> PadX, <span class="hljs-keyword">int</span> Top, <span class="hljs-keyword">int</span> Bottom)</span></span>
<span class="line"></span>{</span>
<span class="line">    Assert (ThisMarker-&gt;PlayCursor &lt; SoundOutput-&gt;SecondaryBufferSize);</span>
<span class="line">    f32 XReal = C * (f32)ThisMarker-&gt;PlayCursor;</span>
<span class="line">    <span class="hljs-keyword">int</span> X = PadX + (<span class="hljs-keyword">int</span>)XReal;</span>
<span class="line">    Win32DebugDrawVertical(Backbuffer, X, Top, Bottom, <span class="hljs-number">0xFFFFFFFF</span>);</span>
<span class="line">}</span></div><span class="line"></span>
<span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32DebugSyncDisplay</span><span class="hljs-params">(win32_offscreen_buffer *Backbuffer,</span>
<span class="line">                      <span class="hljs-keyword">int</span> MarkerCount, win32_debug_time_marker *Markers,</span>
<span class="line">                      win32_sound_output *SoundOutput, f32 TargetSecondsPerFrame)</span></span>
<span class="line"></span>{</span>
<span class="line">    <span class="hljs-keyword">int</span> PadX = <span class="hljs-number">16</span>;</span>
<span class="line">    <span class="hljs-keyword">int</span> PadY = <span class="hljs-number">16</span>;</span>
<span class="line">    </span>
<span class="line">    <span class="hljs-keyword">int</span> Top = PadY;</span>
<span class="line">    <span class="hljs-keyword">int</span> Bottom = Backbuffer-&gt;Height - PadY;</span>
<span class="line">    </span>
<span class="line">    f32 C = (f32)(Backbuffer-&gt;Width - <span class="hljs-number">2</span> * PadX) / (f32)SoundOutput-&gt;SecondaryBufferSize;</span>
<span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> MarkerIndex = <span class="hljs-number">0</span>;</span>
<span class="line">         MarkerIndex &lt; MarkerCount;</span>
<span class="line">         ++MarkerIndex)</span>
<span class="line">    {</span>
<span class="line">        win32_debug_time_marker *ThisMarker = &amp;Markers[MarkerIndex];</span><div class=" delete"><span class="line">        Assert (ThisMarker-&gt;PlayCursor &lt; SoundOutput-&gt;SecondaryBufferSize);</span>
<span class="line">        f32 XReal = C * (f32)ThisMarker-&gt;PlayCursor;</span>
<span class="line">        <span class="hljs-keyword">int</span> X = PadX + (<span class="hljs-keyword">int</span>)XReal;</span>
<span class="line">        Win32DebugDrawVertical(Backbuffer, X, Top, Bottom, <span class="hljs-number">0xFFFFFFFF</span>);</span></div><div class=" add"><span class="line">        Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom);</span>
<span class="line">        Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom);</span></div><span class="line">    }</span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;18:</b> <file>[win32_handmade.cpp]</file> Introducing <code>Win32DrawSoundBufferMarker</code>.</div></center>
<p>




<div class="admonition ">You will notice that <code>Win32DrawSoundBufferMarker</code> is an <em class="underscore">inline</em> function. This means that instead of having its own space in the program and being referred to each time this function is called, it's &ldquo;copied and pasted&rdquo; in its entirety by the compiler directly in the places where the call happens. 

</p><p>

    Usually compiler may decide to inline a function on its own, but here it's small enough that we can suggest it on our part.</div>

</p>
<a class="target" name="addwritecursordisplay">&nbsp;</a><a class="target" name="visualizethecursors/displaythewritecursor/addwritecursordisplay">&nbsp;</a><a class="target" name="toc1.2.3">&nbsp;</a><h3>Add WriteCursor Display</h3>
<p>


Having a separate function allows us to modify it to include variable values that we can pass to it: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32DrawSoundBufferMarker</span><span class="hljs-params">(win32_offscreen_buffer *Backbuffer,</span>
<span class="line">                           win32_sound_output *SoundOutput,</span>
<span class="line">                           f32 C, <span class="hljs-keyword">int</span> PadX, <span class="hljs-keyword">int</span> Top, <span class="hljs-keyword">int</span> Bottom,</span></span></span><div class=" edit"><span class="line">                           DWORD Value, u32 Color)</span></div><span class="line">{</span><div class=" edit"><span class="line">    Assert (Value &lt; SoundOutput-&gt;SecondaryBufferSize);</span>
<span class="line">    f32 XReal = C * (f32)Value;</span></div><span class="line">    <span class="hljs-keyword">int</span> X = PadX + (<span class="hljs-keyword">int</span>)XReal;</span><div class=" edit"><span class="line">    Win32DebugDrawVertical(Backbuffer, X, Top, Bottom, Color);</span></div><span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32DebugSyncDisplay</span><span class="hljs-params">(win32_offscreen_buffer *Backbuffer,</span>
<span class="line">                      <span class="hljs-keyword">int</span> MarkerCount, win32_debug_time_marker *Markers,</span>
<span class="line">                      win32_sound_output *SoundOutput, f32 TargetSecondsPerFrame)</span></span>
<span class="line"></span>{</span>
<span class="line">    <span class="hljs-keyword">int</span> PadX = <span class="hljs-number">16</span>;</span>
<span class="line">    <span class="hljs-keyword">int</span> PadY = <span class="hljs-number">16</span>;</span>
<span class="line">    </span>
<span class="line">    <span class="hljs-keyword">int</span> Top = PadY;</span>
<span class="line">    <span class="hljs-keyword">int</span> Bottom = Backbuffer-&gt;Height - PadY;</span>
<span class="line">    </span>
<span class="line">    f32 C = (f32)(Backbuffer-&gt;Width - <span class="hljs-number">2</span> * PadX) / (f32)SoundOutput-&gt;SecondaryBufferSize;</span>
<span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> MarkerIndex = <span class="hljs-number">0</span>;</span>
<span class="line">         MarkerIndex &lt; MarkerCount;</span>
<span class="line">         ++MarkerIndex)</span>
<span class="line">    {</span>
<span class="line">        win32_debug_time_marker *ThisMarker = &amp;Markers[MarkerIndex];</span>
<span class="line"></span><div class=" edit"><span class="line">        Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom, ThisMarker-&gt;PlayCursor, <span class="hljs-number">0xFFFFFFFF</span>);</span>
<span class="line">        Win32DrawSoundBufferMarker(Backbuffer, SoundOutput, C, PadX, Top, Bottom, ThisMarker-&gt;WriteCursor, <span class="hljs-number">0xFFFF0000</span>);</span></div><span class="line">    }</span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;19:</b> <file>[win32_handmade.cpp]</file> Using <code>Win32DrawSoundBufferMarker</code> to draw different values in different colors.</div></center>
<p>


This should give us what we want, let's compile and verify.

</p><p>

<center><div class="image" style=""><a href="../media/day19/write_cursor.jpg" target="_blank"><img class="markdeep" src="../media/day19/write_cursor.jpg" /></a><center><span class="imagecaption"><a class="target" name="figure_x">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;3:</b> Debug display of the PlayCursor (white) and WriteCursor (red).</span></center></div></center> 

</p><p>

These lines, which represent position of the cursors in the sound buffer as the time goes by, are not looking pretty. Similarly to the <code>PlayCursor</code>s, <code>WriteCursor</code>s are spread unevenly across time. Moreover, we can see that the amount of write cursors is distinctly lower than the amount of play cursors.

</p><p>

Now, if we want to expand this display, we only need to add more members to the <code>win32_debug_time_marker</code> struct (and of course write data to them). Similarly, if don't need one or both marker types that we already have, we can simply comment out (<code>//</code>) the respective calls to <code>Win32DrawSoundBufferMarker</code>. 

</p>
<a class="target" name="addressdebugoutputresults">&nbsp;</a><a class="target" name="addressdebugoutputresults">&nbsp;</a><a class="target" name="toc2">&nbsp;</a><h1>Address Debug Output Results</h1>

<a class="target" name="inspectplaycursors">&nbsp;</a><a class="target" name="addressdebugoutputresults/inspectplaycursors">&nbsp;</a><a class="target" name="toc2.1">&nbsp;</a><h2>Inspect Play Cursors</h2>
<p>


Let's give a closer look at what we're seeing. If we only enable <code>PlayCursor</code>s (comment out the line drawing <code>WriteCursor</code> inside <code>Win32DebugSyncDisplay</code>), we can observe several things:

</p><p>

<ul>
<li class="asterisk">Most of the time we're getting nice equally-spaced lines
</li>
<li class="asterisk">Sometimes we get quite fat lines. This part is really not related to the sound: it's just an artifact from the buffer resizing.
</li>
<li class="asterisk">Some gaps are quite significant, almost a double of the usual gaps</li></ul>

</p><p>

<center><div class="image" style=""><a href="../media/day19/cursor_inspection.jpg" target="_blank"><img class="markdeep" src="../media/day19/cursor_inspection.jpg" /></a><center><span class="imagecaption"><a class="target" name="figure_x">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;4:</b> A Better Look at Play Cursor Display.</span></center></div></center> 

</p><p>

The best bet for now would be go and investigate what's going on with those gaps.

</p>
<a class="target" name="checkdocumentationonmsdn">&nbsp;</a><a class="target" name="addressdebugoutputresults/checkdocumentationonmsdn">&nbsp;</a><a class="target" name="toc2.2">&nbsp;</a><h2>Check Documentation on MSDN</h2>
<p>


The first place to start searching would be in the DirectSound configuration. Maybe we missed something that could help us here? 

</p><p>

The page detailing contents of the <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416818(v=vs.85)">DSBCAPS</a> structure lists all the possible flags you might pass to a buffer. Among others, a suitable candidate is the flag <code>DSBCAPS_GETCURRENTPOSITION2</code>: 
<blockquote>
 The buffer uses the new behavior of the play cursor when 
 IDirectSoundBuffer8::GetCurrentPosition is called. In the first version of DirectSound, 
 the play cursor was significantly ahead of the actual playing sound on emulated sound 
 cards; it was directly behind the write cursor. Now, if the DSBCAPS_GETCURRENTPOSITION2 
 flag is specified, the application can get a more accurate play cursor. If this flag is 
 not specified, the old behavior is preserved for compatibility. This flag affects only 
 emulated devices; if a DirectSound driver is present, the play cursor is accurate for 
 DirectSound in all versions of DirectX.</blockquote>

</p><p>

This seems like a long shot, but let's try it anyway. 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-comment">// NOTE(casey): "Create" a secondary buffer</span></span>
<span class="line">DSBUFFERDESC BufferDescription = {};</span>
<span class="line">BufferDescription.dwSize = <span class="hljs-keyword">sizeof</span>(BufferDescription);</span><div class=" add"><span class="line">BufferDescription.dwFlags = DSBCAPS_GETCURRENTPOSITION2;</span></div><span class="line">BufferDescription.dwBufferBytes = BufferSize;</span>
<span class="line">BufferDescription.lpwfxFormat = &amp;WaveFormat;</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;20:</b> <file>[win32_handmade.cpp > Win32InitDSound]</file> Adding an extra flag to the secondary buffer.</div></center>
<p>


... No changes. Oh well, it was worth a try. No other flag looks particularly useful for our situation. 

</p><p>

Another thing we could try is to check whether we pass <code>PlayCursor</code> and <code>WriteCursor</code> in a right order to <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mt708925(v%3dvs.85)">GetCurrentPosition</a>. Maybe <code>WriteCursor</code> should go first? Let's check documentation:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">HRESULT <span class="hljs-title">GetCurrentPosition</span><span class="hljs-params">( LPDWORD lpdwCurrentPlayCursor, LPDWORD lpdwCurrentWriteCursor )</span></span>;</span></code></pre><p>

Nope, the order is correct. What else it could be?

</p>
<a class="target" name="inspectsoundstream">&nbsp;</a><a class="target" name="addressdebugoutputresults/inspectsoundstream">&nbsp;</a><a class="target" name="toc2.3">&nbsp;</a><h2>Inspect Sound Stream</h2>
<p>


We know we have to write from the last position we wrote to for the sound to be continuous. That's what we're doing here: 

</p><pre class="listing tilde"><code><span class="line">game_sound_output_buffer SoundBuffer = {};</span>
<span class="line">SoundBuffer.SamplesPerSecond = SoundOutput.SamplesPerSecond;</span>
<span class="line">SoundBuffer.SampleCount = BytesToWrite / SoundOutput.BytesPerSample;</span>
<span class="line">SoundBuffer.Samples = Samples;</span>
<span class="line"></span>
<span class="line"><span class="hljs-comment">// ... </span></span>
<span class="line"><span class="hljs-comment">// Preparing render buffer</span></span>
<span class="line"><span class="hljs-comment">// ... </span></span>
<span class="line"></span>
<span class="line">GameUpdateAndRender(&amp;GameMemory, NewInput, &amp;Buffer, &amp;SoundBuffer);</span>
<span class="line"></span>
<span class="line"><span class="hljs-keyword">if</span>(SoundIsValid)</span>
<span class="line">{</span>
<span class="line">    Win32FillSoundBuffer(&amp;SoundOutput, ByteToLock, BytesToWrite, &amp;SoundBuffer);</span>
<span class="line">}</span></code></pre><p>

With the sound buffer, we're providing our game with the information of how many samples should we write. The game writes the samples through <code>GameUpdateAndRender</code> to our own <code>Samples</code> memory block. Afterwards, we transfer the written samples to DirectSound buffers and ultimately to the hardware (in <code>Win32FillSoundBuffer</code>). So this covers most of the <em class="underscore">writing</em> phase. But how early ahead of the Play Cursor should we be writing?

</p>
<a class="target" name="changeplaycursorsnapshot">&nbsp;</a><a class="target" name="addressdebugoutputresults/changeplaycursorsnapshot">&nbsp;</a><a class="target" name="toc2.4">&nbsp;</a><h2>Change PlayCursor Snapshot</h2>
<p>


Now, before we move on and analyze the debug output thoroughly, there's another potential bug hiding in our code. Similarly to the timing issues we encountered earlier, it's possible there's a snapshot timing matter. 

</p><p>

Instead of capturing the Play Cursor just before we send it to the game, we probably should calculate it at the frame flip. We're already doing it in our recently added debug code section, so parts of it will be promoted to non-debug code. We'll be still using them for our debug purposes. 

</p><p>

Now, because it's no longer debug code, we'll need to test whether the <code>GetCurrentPosition</code> succeeded. We can't allow a failure condition in code exposed to the user, should <code>GetCurrentPosition</code> fail, we'll simply mark our <code>SoundIsValid</code> as false and ignore anything sound-related.

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> HANDMADE_INTERNAL</span></span>
<span class="line">Win32DebugSyncDisplay(&amp;GlobalBackbuffer,</span>
<span class="line">                        ArrayCount(DebugTimeMarkers), DebugTimeMarkers,</span>
<span class="line">                        &amp;SoundOutput, TargetSecondsPerFrame);</span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span>
<span class="line">Win32DisplayBufferInWindow(&amp;GlobalBackbuffer, DeviceContext, Dimension.Width, Dimension.Height);</span>
<span class="line"></span><div class=" add"><span class="line">DWORD PlayCursor = <span class="hljs-number">0</span>;</span>
<span class="line">DWORD WriteCursor= <span class="hljs-number">0</span>;</span>
<span class="line"><span class="hljs-keyword">if</span> (SUCCEEDED(GlobalSecondaryBuffer-&gt;GetCurrentPosition(&amp;PlayCursor, &amp;WriteCursor)))</span>
<span class="line">{</span>
<span class="line">    LastPlayCursor = PlayCursor;</span>
<span class="line">    SoundIsValid = <span class="hljs-literal">true</span>;</span>
<span class="line">}</span>
<span class="line"><span class="hljs-keyword">else</span></span>
<span class="line">{</span>
<span class="line">    SoundIsValid = <span class="hljs-literal">false</span>;</span>
<span class="line">}</span></div><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> HANDMADE_INTERNAL</span></span>
<span class="line"><span class="hljs-comment">// NOTE(casey): This is debug code</span></span>
<span class="line">{</span>
<span class="line">    Assert(DebugTimeMarkerIndex &lt; ArrayCount(DebugTimeMarkers));</span>
<span class="line">    win32_debug_time_marker *Marker = &amp;DebugTimeMarkers[DebugTimeMarkerIndex++];</span>
<span class="line">    <span class="hljs-keyword">if</span> (DebugTimeMarkerIndex == ArrayCount(DebugTimeMarkers))</span>
<span class="line">    {</span>
<span class="line">        DebugTimeMarkerIndex = <span class="hljs-number">0</span>;</span>
<span class="line">    }</span><div class=" edit"><span class="line">    Marker-&gt;PlayCursor = PlayCursor;</span>
<span class="line">    Marker-&gt;WriteCursor = WriteCursor;</span></div><span class="line">}</span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;21:</b> <file>[win32_handmade.cpp > WinMain]</file> Capturing the cursors at the end of frame.</div></center>
<p>




<div class="admonition ">Instead of <code>SUCCEEDED(GetCurrentPosition())</code>, you can also write <code>GetCurrentPosition() == DS_OK</code>.</div>

</p><p>

While we're at it, we can handle the case where the sound is valid now, but it wasn't valid before. At that point, we should simply reset our <code>RunningSampleIndex</code> (storing the position in the DirectSound buffer to write to) to whatever our WriteCursor is (divided by bytes per sample since we write in samples). 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">if</span> (SUCCEEDED(GlobalSecondaryBuffer-&gt;GetCurrentPosition(&amp;PlayCursor, &amp;WriteCursor)))</span>
<span class="line">{</span>
<span class="line">    LastPlayCursor = PlayCursor;</span><div class=" add"><span class="line">    <span class="hljs-keyword">if</span> (!SoundIsValid)</span>
<span class="line">    {</span>
<span class="line">        SoundOutput.RunningSampleIndex = WriteCursor / SoundOutput.BytesPerSample;</span></div><span class="line">        SoundIsValid = <span class="hljs-literal">true</span>;</span><div class=" add"><span class="line">    }</span></div><span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;22:</b> <file>[win32_handmade.cpp > WinMain]</file> Adding sound initialization.</div></center>
<p>


You might have noticed <code>LastPlayCursor</code> to which we register the <code>PlayCursor</code>'s value. This will work similar to how the counters work: <code>LastPlayCursor</code> will live outside the <code>GlobalRunning</code> loop, so that its value can be preserved from one frame to the next. We will also move <code>SoundIsValid</code> up there.

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">int</span> DebugTimeMarkerIndex = <span class="hljs-number">0</span>;</span>
<span class="line">win32_debug_time_marker DebugTimeMarkers[GameUpdateHz / <span class="hljs-number">2</span>] = {};</span>
<span class="line"></span><div class=" add"><span class="line">DWORD LastPlayCursor = <span class="hljs-number">0</span>;</span>
<span class="line">b32 SoundIsValid = <span class="hljs-literal">false</span>;</span>
<span class="line"></span></div><span class="line">LARGE_INTEGER LastCounter = Win32GetWallClock();</span>
<span class="line">u64 LastCycleCount = __rdtsc();</span>
<span class="line">GlobalRunning = <span class="hljs-literal">true</span>;</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;23:</b> <file>[win32_handmade.cpp > WinMain]</file> Initializing <code>LastPlayCursor</code>.</div></center>
<p>


Coming into the cursor logic section, we can start simplifying things significantly. We no longer need to capture <code>PlayCursor</code> here, and we can just check if the sound is valid to proceed with the computation using the last play cursor: 

</p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-comment">// NOTE(casey): Compute how much sound to write and where</span></span></div><span class="line">DWORD ByteToLock = <span class="hljs-number">0</span>;</span>
<span class="line">DWORD TargetCursor = <span class="hljs-number">0</span>;</span>
<span class="line">DWORD BytesToWrite = <span class="hljs-number">0</span>;</span><div class=" delete"><span class="line">DWORD PlayCursor = <span class="hljs-number">0</span>;</span>
<span class="line">DWORD WriteCursor = <span class="hljs-number">0</span>;</span>
<span class="line">b32 SoundIsValid = <span class="hljs-literal">false</span>;</span>
<span class="line"><span class="hljs-comment">// TODO(casey): Tighten up sound logic so that we know where we should be</span></span>
<span class="line"><span class="hljs-comment">// writing to and can anticipate the time spent in the game updates.</span></span></div><div class=" edit"><span class="line"><span class="hljs-keyword">if</span> (SoundIsValid)</span></div><span class="line">{</span>
<span class="line">    ByteToLock = ((SoundOutput.RunningSampleIndex * SoundOutput.BytesPerSample)</span>
<span class="line">                    % SoundOutput.SecondaryBufferSize);</span><div class=" edit"><span class="line">    TargetCursor = ((LastPlayCursor +</span></div><span class="line">                        (SoundOutput.LatencySampleCount * SoundOutput.BytesPerSample))</span>
<span class="line">                    % SoundOutput.SecondaryBufferSize);</span>
<span class="line">    </span>
<span class="line">    <span class="hljs-keyword">if</span>(ByteToLock &gt; TargetCursor)</span>
<span class="line">    {</span>
<span class="line">        BytesToWrite = SoundOutput.SecondaryBufferSize - ByteToLock;</span>
<span class="line">        BytesToWrite += TargetCursor;</span>
<span class="line">    }</span>
<span class="line">    <span class="hljs-keyword">else</span></span>
<span class="line">    {</span>
<span class="line">        BytesToWrite = TargetCursor - ByteToLock;</span>
<span class="line">    }</span>
<span class="line">    </span><div class=" delete"><span class="line">    SoundIsValid = <span class="hljs-literal">true</span>;</span></div><span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;24:</b> <file>[win32_handmade.cpp > WinMain]</file> Updating cursor logic section.</div></center>
<p>


Speaking of latency, we currently defined it as:

</p><pre class="listing tilde"><code><span class="line">SoundOutput.LatencySampleCount = SoundOutput.SamplesPerSecond / (GameUpdateHz / <span class="hljs-number">2</span>);</span></code></pre><p>

This looks a bit confusing, as double division usually is. We could rewrite it to make it clearer that it's 2 frames worth of sound. We simply calculate what's the latency of one frame, and then multiply by however many frames we need.

</p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FramesOfAudioLatency 2</span></span></div><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MonitorRefreshHz 60</span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GameUpdateHz (MonitorRefreshHz / 2)</span></span><span class="line">    <span class="hljs-comment">// ... </span></span>
<span class="line"></span>
<span class="line"><span class="hljs-comment">// NOTE(casey): Sound test</span></span>
<span class="line">win32_sound_output SoundOutput = {};</span>
<span class="line">SoundOutput.SamplesPerSecond = <span class="hljs-number">48000</span>;</span>
<span class="line">SoundOutput.BytesPerSample = <span class="hljs-keyword">sizeof</span>(s16) * <span class="hljs-number">2</span>;</span>
<span class="line">SoundOutput.SecondaryBufferSize = <span class="hljs-number">2</span> * SoundOutput.SamplesPerSecond * SoundOutput.BytesPerSample;</span>
<span class="line">SoundOutput.RunningSampleIndex = <span class="hljs-number">0</span>;</span>
<span class="line">SoundOutput.RunningSampleIndex = <span class="hljs-number">0</span>;</span><div class=" edit"><span class="line">SoundOutput.LatencySampleCount = FramesOfAudioLatency *</span>
<span class="line">                                (SoundOutput.SamplesPerSecond / GameUpdateHz);</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;25:</b> <file>[win32_handmade.cpp > WinMain]</file> Updating Latency notation.</div></center>
<p>


Overall, this refactoring should be a bit more sane in fixing our issue. Let's compile and test it. Yep, the sound bug is still there.

</p>
<a class="target" name="inspectcursorlogic">&nbsp;</a><a class="target" name="addressdebugoutputresults/inspectcursorlogic">&nbsp;</a><a class="target" name="toc2.5">&nbsp;</a><h2>Inspect Cursor Logic</h2>
<p>


Let's dive deep into our cursor logic block (eventually we could pull it out to a separate function but for now we'll leave it there).

</p><pre class="listing tilde"><code><span class="line">DWORD ByteToLock = <span class="hljs-number">0</span>;</span>
<span class="line">DWORD TargetCursor = <span class="hljs-number">0</span>;</span>
<span class="line">DWORD BytesToWrite = <span class="hljs-number">0</span>;</span>
<span class="line"><span class="hljs-keyword">if</span> (SoundIsValid)</span>
<span class="line">{</span>
<span class="line">    ByteToLock = ((SoundOutput.RunningSampleIndex * SoundOutput.BytesPerSample)</span>
<span class="line">                    % SoundOutput.SecondaryBufferSize);</span>
<span class="line">    </span>
<span class="line">    TargetCursor = ((LastPlayCursor +</span>
<span class="line">                        (SoundOutput.LatencySampleCount * SoundOutput.BytesPerSample))</span>
<span class="line">                    % SoundOutput.SecondaryBufferSize);</span>
<span class="line">    </span>
<span class="line">    <span class="hljs-keyword">if</span>(ByteToLock &gt; TargetCursor)</span>
<span class="line">    {</span>
<span class="line">        BytesToWrite = SoundOutput.SecondaryBufferSize - ByteToLock;</span>
<span class="line">        BytesToWrite += TargetCursor;</span>
<span class="line">    }</span>
<span class="line">    <span class="hljs-keyword">else</span></span>
<span class="line">    {</span>
<span class="line">        BytesToWrite = TargetCursor - ByteToLock;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">game_sound_output_buffer SoundBuffer = {};</span>
<span class="line"><span class="hljs-comment">// ... </span></span></code></pre><p>

In this block we calculate <code>ByteToLock</code> (start point of our write), <code>TargetCursor</code> (end point of the write) and <code>BytesToWrite</code> (total written this frame). We got <code>LastPlayCursor</code> position during last frame, by asking Windows directly.

</p><p>

<svg class="diagram" xmlns="http://www.w3.org/2000/svg" version="1.1" height="304" width="424" style="margin:0 auto 0 auto;"><g transform="translate(8,16 )">
<path d="M 16,96 L 16,128 " style="fill:none;"/>
<path d="M 64,80 L 64,96 " style="fill:none;"/>
<path d="M 128,128 L 128,144 " style="fill:none;"/>
<path d="M 272,48 L 272,144 " style="fill:none;"/>
<path d="M 384,96 L 384,128 " style="fill:none;"/>
<path d="M 80,32 L 152,32 " style="fill:none;"/>
<path d="M 184,32 L 256,32 " style="fill:none;"/>
<path d="M 16,112 L 56,112 " style="fill:none;"/>
<path d="M 72,112 L 120,112 " style="fill:none;"/>
<path d="M 136,112 L 264,112 " style="fill:none;"/>
<path d="M 280,112 L 344,112 " style="fill:none;"/>
<path d="M 360,112 L 384,112 " style="fill:none;"/>
<path d="M 144,192 L 184,192 " style="fill:none;"/>
<path d="M 216,192 L 256,192 " style="fill:none;"/>
<path d="M 32,240 L 184,240 " style="fill:none;"/>
<path d="M 216,240 L 336,240 " style="fill:none;"/>
<path d="M 352,240 L 368,240 " style="fill:none;"/>
<path d="M 80,32 C 63.2,32 64,48 64,48 " style="fill:none;"/>
<path d="M 152,32 C 168.8,32 168,16 168,16 " style="fill:none;"/>
<path d="M 184,32 C 167.2,32 168,16 168,16 " style="fill:none;"/>
<path d="M 256,32 C 272.8,32 272,48 272,48 " style="fill:none;"/>
<path d="M 144,192 C 127.2,192 128,176 128,176 " style="fill:none;"/>
<path d="M 184,192 C 200.8,192 200,208 200,208 " style="fill:none;"/>
<path d="M 216,192 C 199.2,192 200,208 200,208 " style="fill:none;"/>
<path d="M 256,192 C 272.8,192 272,176 272,176 " style="fill:none;"/>
<path d="M 32,240 C 15.2,240 16,224 16,224 " style="fill:none;"/>
<path d="M 184,240 C 200.8,240 200,256 200,256 " style="fill:none;"/>
<path d="M 216,240 C 199.2,240 200,256 200,256 " style="fill:none;"/>
<path d="M 368,240 C 384.8,240 384,224 384,224 " style="fill:none;"/>
<polygon points="280,120 268,114.4 268,125.6 "  style="stroke:none" transform="rotate(270,272,120 )"/>
<polygon points="136,128 124,122.4 124,133.6 "  style="stroke:none" transform="rotate(270,128,128 )"/>
<polygon points="72,96 60,90.4 60,101.6 "  style="stroke:none" transform="rotate(90,64,96 )"/>
<circle cx="64" cy="112" r="6" class="closeddot"/><circle cx="128" cy="112" r="6" class="closeddot"/><circle cx="272" cy="112" r="6" class="closeddot"/><g transform="translate(0,0)"><text text-anchor="middle" x="144" y="4">L</text><text text-anchor="middle" x="152" y="4">a</text><text text-anchor="middle" x="160" y="4">t</text><text text-anchor="middle" x="168" y="4">e</text><text text-anchor="middle" x="176" y="4">n</text><text text-anchor="middle" x="184" y="4">c</text><text text-anchor="middle" x="192" y="4">y</text><text text-anchor="middle" x="40" y="68">P</text><text text-anchor="middle" x="48" y="68">l</text><text text-anchor="middle" x="56" y="68">a</text><text text-anchor="middle" x="64" y="68">y</text><text text-anchor="middle" x="72" y="68">C</text><text text-anchor="middle" x="80" y="68">u</text><text text-anchor="middle" x="88" y="68">r</text><text text-anchor="middle" x="96" y="68">s</text><text text-anchor="middle" x="104" y="68">o</text><text text-anchor="middle" x="112" y="68">r</text><text text-anchor="middle" x="352" y="116">.</text><text text-anchor="middle" x="104" y="164">B</text><text text-anchor="middle" x="112" y="164">y</text><text text-anchor="middle" x="120" y="164">t</text><text text-anchor="middle" x="128" y="164">e</text><text text-anchor="middle" x="136" y="164">T</text><text text-anchor="middle" x="144" y="164">o</text><text text-anchor="middle" x="152" y="164">L</text><text text-anchor="middle" x="160" y="164">o</text><text text-anchor="middle" x="168" y="164">c</text><text text-anchor="middle" x="176" y="164">k</text><text text-anchor="middle" x="224" y="164">T</text><text text-anchor="middle" x="232" y="164">a</text><text text-anchor="middle" x="240" y="164">r</text><text text-anchor="middle" x="248" y="164">g</text><text text-anchor="middle" x="256" y="164">e</text><text text-anchor="middle" x="264" y="164">t</text><text text-anchor="middle" x="272" y="164">C</text><text text-anchor="middle" x="280" y="164">u</text><text text-anchor="middle" x="288" y="164">r</text><text text-anchor="middle" x="296" y="164">s</text><text text-anchor="middle" x="304" y="164">o</text><text text-anchor="middle" x="312" y="164">r</text><text text-anchor="middle" x="152" y="228">B</text><text text-anchor="middle" x="160" y="228">y</text><text text-anchor="middle" x="168" y="228">t</text><text text-anchor="middle" x="176" y="228">e</text><text text-anchor="middle" x="184" y="228">s</text><text text-anchor="middle" x="192" y="228">T</text><text text-anchor="middle" x="200" y="228">o</text><text text-anchor="middle" x="208" y="228">W</text><text text-anchor="middle" x="216" y="228">r</text><text text-anchor="middle" x="224" y="228">i</text><text text-anchor="middle" x="232" y="228">t</text><text text-anchor="middle" x="240" y="228">e</text><text text-anchor="middle" x="344" y="244">.</text><text text-anchor="middle" x="88" y="276">D</text><text text-anchor="middle" x="96" y="276">i</text><text text-anchor="middle" x="104" y="276">r</text><text text-anchor="middle" x="112" y="276">e</text><text text-anchor="middle" x="120" y="276">c</text><text text-anchor="middle" x="128" y="276">t</text><text text-anchor="middle" x="136" y="276">S</text><text text-anchor="middle" x="144" y="276">o</text><text text-anchor="middle" x="152" y="276">u</text><text text-anchor="middle" x="160" y="276">n</text><text text-anchor="middle" x="168" y="276">d</text><text text-anchor="middle" x="184" y="276">s</text><text text-anchor="middle" x="192" y="276">e</text><text text-anchor="middle" x="200" y="276">c</text><text text-anchor="middle" x="208" y="276">o</text><text text-anchor="middle" x="216" y="276">n</text><text text-anchor="middle" x="224" y="276">d</text><text text-anchor="middle" x="232" y="276">a</text><text text-anchor="middle" x="240" y="276">r</text><text text-anchor="middle" x="248" y="276">y</text><text text-anchor="middle" x="264" y="276">b</text><text text-anchor="middle" x="272" y="276">u</text><text text-anchor="middle" x="280" y="276">f</text><text text-anchor="middle" x="288" y="276">f</text><text text-anchor="middle" x="296" y="276">e</text><text text-anchor="middle" x="304" y="276">r</text></g></g></svg><center><div class="imagecaption"><a class="target" name="figure_x">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;5:</b> Our cursor logic if <code>BytesToWrite</code> is behind the <code>TargetCursor</code>. There is also <code>WriteCursor</code> but we don't care about it here.</div></center>

</p><p>

<ul>
<li class="asterisk"><code>ByteToLock</code> is defined by us. We want to be continuously writing to the buffer, so we invented the concept of <code>RunningSampleIndex</code>, a number that grows forever. <code>ByteToLock</code> is effectively this index, translated from samples to bytes and confined within the buffer space (<code>% SecondaryBufferSize</code>).
</li>
<li class="asterisk"><code>TargetCursor</code> is largely defined by the <code>PlayCursor</code>. We want to write <em class="underscore">at least</em> until the play cursor and then some (for what we're calling latency). This value would still be ahead of <code>ByteToLock</code> (before being also confined within the buffer space) and in the general vicinity of the actual <code>WriteCursor</code>.
</li>
<li class="asterisk"><code>BytesToWrite</code> thus depends on whether or not <code>ByteToLock</code> is ahead or behind the <code>TargetCursor</code>:
<ul>
    <li class="asterisk">If it's ahead, it means that we're wrapping the circular buffer. We want to write until the end of the buffer, and then from 0 to the <code>TargetCursor</code>.
</li>
    <li class="asterisk">If it's equal or behind, we want to write for however big is the space between the two (see figure above). If the values are equal, we write 0 bytes.</li></ul></li></ul>

</p><p>

All of this seems correct. 

</p>
<a class="target" name="printoutcursorlogicvalues">&nbsp;</a><a class="target" name="addressdebugoutputresults/printoutcursorlogicvalues">&nbsp;</a><a class="target" name="toc2.6">&nbsp;</a><h2>Print Out Cursor Logic Values</h2>
<p>


To better understand what's going on, we can make another one of those debug printouts, to better compare different values over time. We'll put it next to the sound filling buffer routine. If you prefer, you can also disable the FPS printout.

</p><pre class="listing tilde"><code><span class="line">game_offscreen_buffer Buffer = {};</span>
<span class="line"><span class="hljs-comment">// ...</span></span>
<span class="line"></span>
<span class="line">GameUpdateAndRender(&amp;GameMemory, NewInput, &amp;Buffer, &amp;SoundBuffer);</span>
<span class="line"></span>
<span class="line"><span class="hljs-keyword">if</span>(SoundIsValid)</span>
<span class="line">{</span>
<span class="line">    Win32FillSoundBuffer(&amp;SoundOutput, ByteToLock, BytesToWrite, &amp;SoundBuffer);</span>
<span class="line">    </span><div class=" add"><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> HANDMADE_INTERNAL</span></span>
<span class="line">    DWORD PlayCursor;</span>
<span class="line">    DWORD WriteCursor;</span>
<span class="line">    GlobalSecondaryBuffer-&gt;GetCurrentPosition(&amp;PlayCursor, &amp;WriteCursor);</span>
<span class="line">    <span class="hljs-keyword">char</span> TextBuffer[<span class="hljs-number">256</span>];</span>
<span class="line">    sprintf_s(TextBuffer, <span class="hljs-keyword">sizeof</span>(TextBuffer), <span class="hljs-string">"PC:%u BTL:%u TC:%u BTW:%u\n"</span>, PlayCursor, ByteToLock, TargetCursor, BytesToWrite);</span>
<span class="line">    OutputDebugStringA(TextBuffer);</span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span></div><span class="line">}</span>
<span class="line">                    </span>
<span class="line"><span class="hljs-comment">// ... </span></span>
<span class="line">                    </span><div class=" edit"><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 0</span></span></div><span class="line"><span class="hljs-comment">// debug timing output</span></span>
<span class="line"></span>
<span class="line">f32 FPS = <span class="hljs-number">0.0f</span>; <span class="hljs-comment">// To be fixed later</span></span>
<span class="line">f32 MegaCyclesPerFrame = (f32)CyclesElapsed / (<span class="hljs-number">1000.0f</span> * <span class="hljs-number">1000.0f</span>);</span>
<span class="line"></span>
<span class="line"><span class="hljs-keyword">char</span> FPSBuffer[<span class="hljs-number">256</span>];</span>
<span class="line">sprintf_s(FPSBuffer, <span class="hljs-keyword">sizeof</span>(FPSBuffer), <span class="hljs-string">"%.02fms/f, %.02ff/s, %.02fMc/f\n"</span>, MSPerFrame, FPS, MegaCyclesPerFrame);</span>
<span class="line">OutputDebugStringA(FPSBuffer);</span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;26:</b> <file>[win32_handmade.cpp > WinMain]</file> Printing cursor values.</div></center>
<p>


What we will get when we compile and run the game inside the debugger is the progressively increasing <code>PlayCursor</code>, <code>ByteToLock</code>, <code>TargetCursor</code>. As for the <code>BytesToWrite</code>, on our machine it oscillates between 5780 and 7680 bytes. This is indicative of less than precise granularity. 

</p>
<a class="target" name="determinesoundcardgranularity">&nbsp;</a><a class="target" name="addressdebugoutputresults/determinesoundcardgranularity">&nbsp;</a><a class="target" name="toc2.7">&nbsp;</a><h2>Determine Sound Card Granularity</h2>
<p>


If we wanted to calculate the sound card granularity precisely, we can do it by locking ourselves in an infinite loop. Let's have some fun! Just before entering our main <code>GlobalRunning</code> loop, we'll write a new, fake, one:

</p><pre class="listing tilde"><code><span class="line">GlobalRunning = <span class="hljs-literal">true</span>;</span>
<span class="line">                </span><div class=" add"><span class="line"><span class="hljs-keyword">while</span> (GlobalRunning)</span>
<span class="line">{</span>
<span class="line">    DWORD PlayCursor;</span>
<span class="line">    DWORD WriteCursor;</span>
<span class="line">    GlobalSecondaryBuffer-&gt;GetCurrentPosition(&amp;PlayCursor, &amp;WriteCursor);</span>
<span class="line">    </span>
<span class="line">    <span class="hljs-keyword">char</span> TextBuffer[<span class="hljs-number">256</span>];</span>
<span class="line">    _snprintf_s(TextBuffer, <span class="hljs-keyword">sizeof</span>(TextBuffer),</span>
<span class="line">                <span class="hljs-string">"PC:%u WC:%u\n"</span>, PlayCursor, WriteCursor);</span>
<span class="line">    OutputDebugStringA(TextBuffer);</span>
<span class="line">}</span></div><span class="line"><span class="hljs-keyword">while</span> (GlobalRunning) <span class="hljs-comment">// actual game loop</span></span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;27:</b> <file>[win32_handmade.cpp > WinMain]</file> Printing more cursor values.</div></center>
<p>


After compiling, make sure to run the game from the debugger! You'll only be able to close it by stopping debugging (<code>Ctrl-F5</code> from the debugger). Let it run for a couple of seconds and stop. 

</p><p>

You will see an output similar to this one: 

</p><pre class="listing tilde"><code><span class="line">PC:65280 WC:71040</span>
<span class="line">PC:65280 WC:71040</span>
<span class="line">PC:65280 WC:71040</span>
<span class="line">PC:67200 WC:72960</span>
<span class="line">PC:67200 WC:72960</span>
<span class="line">PC:67200 WC:72960</span>
<span class="line">PC:67200 WC:72960</span>
<span class="line">PC:67200 WC:72960</span>
<span class="line">PC:67200 WC:72960</span></code></pre><p>

Now you'll notice that each time you call <code>GetCurrentPosition</code> the system reports the same exact position for a while, until it shifts significantly. If we take two subsequent values and find the difference, we'll see it's \(72960 - 71040 = 1920\) <em class="underscore">bytes</em>. How does this translate to our game?

</p><p>

We know that we have 4 bytes per sample (2 for each channel). So we can make a division \(\frac{1920}{4} = 480\) <em class="underscore">samples</em>. We also set our sound card frequency to 48000 samples per second, so with a framerate of 30 frames per second, we fill \(\frac{48000}{30} = 1600\) <em class="underscore">samples per frame</em>. This means that, with granularity of 480, the cursors should advance \(\frac{1600}{480} \approx 3.33\) times each frame. 

</p><p>

That doesn't sound too bad. For what we're trying to do, this should be enough to work. Ok, let's <code>#if 0</code> our mini loop so that we can re-enable it in the future if needed.

</p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 0</span></span>
<span class="line"><span class="hljs-comment">// NOTE(casey): This tests the PlayCursor/WriteCursor update frequency</span></span>
<span class="line"><span class="hljs-comment">// On the Handmade Hero machine, it was 480 samples.</span></span></div><span class="line"><span class="hljs-keyword">while</span> (GlobalRunning)</span>
<span class="line">{</span>
<span class="line">    DWORD PlayCursor;</span>
<span class="line">    DWORD WriteCursor;</span>
<span class="line">    GlobalSecondaryBuffer-&gt;GetCurrentPosition(&amp;PlayCursor, &amp;WriteCursor);</span>
<span class="line">    </span>
<span class="line">    <span class="hljs-keyword">char</span> TextBuffer[<span class="hljs-number">256</span>];</span>
<span class="line">    _snprintf_s(TextBuffer, <span class="hljs-keyword">sizeof</span>(TextBuffer),</span>
<span class="line">                <span class="hljs-string">"PC:%u WC:%u\n"</span>, PlayCursor, WriteCursor);</span>
<span class="line">    OutputDebugStringA(TextBuffer);</span>
<span class="line">}</span><div class=" add"><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;28:</b> <file>[win32_handmade.cpp > WinMain]</file> Restoring our game functionality.</div></center>
<p>


Recompiling should give us back our beautiful gradient and terrible sound, just as we expected.

</p>
<a class="target" name="inspectwritecursors">&nbsp;</a><a class="target" name="addressdebugoutputresults/inspectwritecursors">&nbsp;</a><a class="target" name="toc2.8">&nbsp;</a><h2>Inspect Write Cursors</h2>
<p>


Let's check our cursors again as they're drawn: 

</p><p>

<center><div class="image" style=""><a href="../media/day19/write_cursor.jpg" target="_blank"><img class="markdeep" src="../media/day19/write_cursor.jpg" /></a><center><span class="imagecaption"><a class="target" name="figure_x">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;6:</b> Debug display of the PlayCursor (white) and WriteCursor (red).</span></center></div></center> 

</p><p>

A distinct possibility is that we're still writing too close to the write cursor. This isn't good, as trying to read while writing is never a good idea. So let's expand our text printout to include not only the last play cursor, but also the latest, as well as the write cursor.

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">if</span>(SoundIsValid)</span>
<span class="line">{</span>
<span class="line">    Win32FillSoundBuffer(&amp;SoundOutput, ByteToLock, BytesToWrite, &amp;SoundBuffer);</span>
<span class="line">    </span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> HANDMADE_INTERNAL</span></span>
<span class="line">    DWORD PlayCursor;</span>
<span class="line">    DWORD WriteCursor;</span>
<span class="line">    GlobalSecondaryBuffer-&gt;GetCurrentPosition(&amp;PlayCursor, &amp;WriteCursor);</span>
<span class="line">    <span class="hljs-keyword">char</span> TextBuffer[<span class="hljs-number">256</span>];</span><div class=" edit"><span class="line">    sprintf_s(TextBuffer, <span class="hljs-keyword">sizeof</span>(TextBuffer), <span class="hljs-string">"LPC:%u BTL:%u TC:%u BTW:%u - PC:%u WC:%u\n"</span>, </span>
<span class="line">                                  LastPlayCursor, ByteToLock, TargetCursor, BytesToWrite,</span>
<span class="line">                                  PlayCursor, WriteCursor);</span></div><span class="line">    OutputDebugStringA(TextBuffer);</span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;29:</b> <file>[win32_handmade.cpp > WinMain]</file> Printing more cursor values.</div></center>
<p>


Which will give us the printout similar to this: 

</p><pre class="listing tilde"><code><span class="line">LPC:86400 BTL:93440 TC:99200 BTW:5760 - PC:88320 WC:94080</span>
<span class="line">LPC:94080 BTL:99200 TC:106880 BTW:7680 - PC:101760 WC:107520</span>
<span class="line">LPC:105600 BTL:112640 TC:118400 BTW:5760 - PC:107520 WC:113280</span></code></pre><p>

We can see that our <code>PlayCursor</code> advances nicely each frame (as LPC and PC values indicate on each line). However, the <code>WriteCursor</code> is significantly far ahead compared to our hypothetic <code>ByteToLock</code> (and even <code>TargetCursor</code>!). This isn't good news because, in Windows' books, any space between <code>PlayCursor</code> and <code>WriteCursor</code> is unsafe territory, where bad things happen. 

</p><p>

In fact, if you calculate the gap between the <code>WriteCursor</code> and <code>PlayCursor</code>, you will get an astonishing \(113280 - 107520 = 5760\) <em class="underscore">bytes</em>! That's 1440 samples, almost a full frame! Which means our dream of having synchronous frame flip for both audio and video at the same time (immediately after this frame) seems quite slim indeed.

</p><p>

Let's just test our hypothesis and increase our latency from 2 to 3 frames.

</p><pre class="listing tilde"><code><div class=" edit"><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FramesOfAudioLatency 3</span></span></div><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MonitorRefreshHz 60</span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GameUpdateHz (MonitorRefreshHz / 2)</span></span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;30:</b> <file>[win32_handmade.cpp > WinMain]</file> Testing higher latency.</div></center>
<p>


If we compile and run... the bug would disappear, and you'll hear nice and clean sound. Yay us?

</p>
<a class="target" name="recap">&nbsp;</a><a class="target" name="recap">&nbsp;</a><a class="target" name="toc3">&nbsp;</a><h1>Recap</h1>
<p>


After a long and strenuous investigation day, we can finally conclude that our sound issues were indeed related to low latency. Having such a big delay between the image and the sound is far from perfect, even more so when we transition from 30 to 60 frames per second. 

</p><p>

This unfortunately is a sad conclusion, which we will try to overcome next time. We want that ultimately our game wouldn't think of any issues that the platform layer might be facing, and work with pure (and immediate) sound stream. There might be also additional bugs that we may uncover which would help us!

</p><p>

Ultimately, it's not as bad as it sounds. Human brain is quite forgiving for any lag between what you see and what you hear, and tends to synchronize those together. Unless we're going for a beat-matching game, we should be fine. Still, narrowing the latency it makes it subjectively better to feel. 

</p><p>

Additionally, we still need to clean up all the loose ends before we are ready to commit to our game layer.

</p>
<a class="target" name="sidedebugging">&nbsp;</a><a class="target" name="sidedebugging">&nbsp;</a><a class="target" name="toc4">&nbsp;</a><h1>Side Debugging</h1>

<a class="target" name="accessviolationinwin32debugdrawvertical">&nbsp;</a><a class="target" name="sidedebugging/accessviolationinwin32debugdrawvertical">&nbsp;</a><a class="target" name="toc4.1">&nbsp;</a><h2>Access Violation in <code>Win32DebugDrawVertical</code></h2>
<p>


We got an access violation while trying to write the color to <code>Pixel</code>. This probably means that we made a mistake somewhere along the calculation of our pixel location, so let's go thoroughly through everything that's happening. 

</p>
<a class="target" name="inspectthepixelaccesslogic">&nbsp;</a><a class="target" name="sidedebugging/accessviolationinwin32debugdrawvertical/inspectthepixelaccesslogic">&nbsp;</a><a class="target" name="toc4.1.1">&nbsp;</a><h3>Inspect the Pixel Access Logic</h3>
<p>


Our pixel access logic seems sound.

</p><pre class="listing tilde"><code><span class="line">u8 *Pixel = (u8 *)Backbuffer-&gt;Memory +</span>
<span class="line">            Top * Backbuffer-&gt;Pitch +</span>
<span class="line">            X * Backbuffer-&gt;BytesPerPixel;</span></code></pre><p>

We correctly cast to <code>u8</code> (which is exactly 1 byte long), so the offsets happen byte after byte. If we inspect <code>Backbuffer</code> in the <code>Watch</code> window, it will give us positive amounts, so we move forward each time: 

</p><p>

<div class='table'>
<table class="table"><tr><th style="text-align:left"> Name </th><th style="text-align:left"> Value </th></tr>
<tr><td style="text-align:left"> <code>Backbuffer</code> </td><td style="text-align:left">  </td></tr>
<tr><td style="text-align:left"> <code>  &gt; Info       </code> </td><td style="text-align:left"> ... </td></tr>
<tr><td style="text-align:left"> <code>  Memory       </code> </td><td style="text-align:left"> 0x... </td></tr>
<tr><td style="text-align:left"> <code>  Width        </code> </td><td style="text-align:left"> 1280 </td></tr>
<tr><td style="text-align:left"> <code>  Height       </code> </td><td style="text-align:left"> 720 </td></tr>
<tr><td style="text-align:left"> <code>  Pitch        </code> </td><td style="text-align:left"> 5120 </td></tr>
<tr><td style="text-align:left"> <code>  BytesPerPixel</code> </td><td style="text-align:left"> 4 </td></tr>
</table><center><div class="tablecaption"><a class="target" name="table_x">&nbsp;</a><b style="font-style:normal;">Table&nbsp;1:</b> Inspection of Backbuffer values inside the <code>Watch</code> window.</div></center></div>

</p><p>

However, if you inspect the difference between the Backbuffer <code>Memory</code> address and <code>Pixel</code> address, you will get some crazy number:
<div class='table'>
<table class="table"><tr><th style="text-align:left"> Name </th><th style="text-align:left"> Value </th></tr>
<tr><td style="text-align:left"> <code>Pixel - (unsigned char*)Backbuffer-&gt;Memory</code> </td><td style="text-align:left"> 45032324  </td></tr>
</table><center><div class="tablecaption"><a class="target" name="table_x">&nbsp;</a><b style="font-style:normal;">Table&nbsp;2:</b> Displaying Pixel Offset.</div></center></div>

</p><p>

That's not good at all. Based on the numbers above, the relative address of the pixel should be somewhere between 0 and <code>(Height + 1) * Pitch * BytesPerPixel</code>, i.e. 14 766 080. Our number came in above 45 million, waaay above from it should have been.

</p>
<a class="target" name="stepthrough">&nbsp;</a><a class="target" name="sidedebugging/accessviolationinwin32debugdrawvertical/stepthrough">&nbsp;</a><a class="target" name="toc4.1.2">&nbsp;</a><h3>Step Through</h3>
<p>


Let's step through our the code. Stop the program, set a breakpoint (<code>F9</code>) before entering in <code>Win32DebugDrawVertical</code>, and inspect our logic as it comes in: 

</p><p>

<ul>
<li class="asterisk">Initially, our offset from the base memory address is somewhere within 80 000. We can quickly repeat the math by typing in the same calculations inside the <code>Watch</code> window:</li></ul>

</p><p>

<div class='table'>
<table class="table"><tr><th style="text-align:left"> Name </th><th style="text-align:left"> Value </th></tr>
<tr><td style="text-align:left"> <code>Pixel - (unsigned char*)Backbuffer-&gt;Memory</code> </td><td style="text-align:left"> 81996  </td></tr>
<tr><td style="text-align:left"> <code>Top * Backbuffer-&gt;Pitch</code> </td><td style="text-align:left"> 81920  </td></tr>
<tr><td style="text-align:left"> <code>X * Backbuffer-&gt;BytesPerPixel</code> </td><td style="text-align:left"> 76  </td></tr>
</table><center><div class="tablecaption"><a class="target" name="table_x">&nbsp;</a><b style="font-style:normal;">Table&nbsp;3:</b> Pixel Offset and X/Y offsets at our first run. (actual numbers might differ slightly on your machine)</div></center></div>

</p><p>

You can repeat the same calculations directly: \(1280 * 4 = 5120\), \(19 * 5120 = 81920\). Looks correct for the start. 

</p><p>

We then step through our Y loop and check our Pixel offset. It increases correctly... until we step out of function.

</p><p>

We can now conclude that our function succeeded the first time through, so the issue must be somewhere else. 

</p>
<a class="target" name="inspectcomputationofx">&nbsp;</a><a class="target" name="sidedebugging/accessviolationinwin32debugdrawvertical/inspectcomputationofx">&nbsp;</a><a class="target" name="toc4.1.3">&nbsp;</a><h3>Inspect Computation of X</h3>
<p>


The only parameter that varies coming into <code>Win32DebugDrawVertical</code> is <code>X</code>. <code>X</code> is calculated on the fly at each iteration. Maybe our coefficient <code>C</code> calculation is incorrect? As long as our <code>X</code> is low, there're no issues inside the drawing routine.

</p><p>

Let's verify this by clearing (<code>F9</code>) all the breakpoints and letting our program run until the crash. 
<div class='table'>
<table class="table"><tr><th style="text-align:left"> Name </th><th style="text-align:left"> Value </th></tr>
<tr><td style="text-align:left"> <code>X</code> </td><td style="text-align:left"> 11237601  </td></tr>
</table><center><div class="tablecaption"><a class="target" name="table_x">&nbsp;</a><b style="font-style:normal;">Table&nbsp;4:</b> Inspecting <code>X</code> value at the moment of crash.</div></center></div>

</p><p>

There's your problem! That's nowhere near from where a realistic value should be (between 0 and buffer width, i.e. 1280). Let's take a step back, out from <code>Win32DebugDrawVertical</code> and check what's happening inside <code>Win32DebugSyncDisplay</code>. But before we do that, let's split our computation a bit more: we'll highlight the <code>PlayCursor</code> value as well as the real computation of <code>X</code> (without the pad and as a \({\rm I\!R}\) number)

</p><pre class="listing tilde"><code><span class="line">f32 C = (f32)(Backbuffer-&gt;Width - <span class="hljs-number">2</span> * PadX) / (f32)SoundOutput-&gt;SecondaryBufferSize;</span>
<span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> PlayCursorIndex = <span class="hljs-number">0</span>;</span>
<span class="line">        PlayCursorIndex &lt; LastPlayCursorCount;</span>
<span class="line">        ++PlayCursorIndex)</span>
<span class="line">{</span><div class=" add"><span class="line">    DWORD ThisPlayCursor = LastPlayCursor[PlayCursorIndex];</span>
<span class="line">    f32 XReal = C * (f32)ThisPlayCursor;</span></div><div class=" edit"><span class="line">    <span class="hljs-keyword">int</span> X = PadX + (<span class="hljs-keyword">int</span>) XReal;</span></div><span class="line">    Win32DebugDrawVertical(Backbuffer, X, Top, Bottom, <span class="hljs-number">0xFFFFFFFF</span>);</span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;31:</b> <file>[win32_handmade.cpp > Win32DebugSyncDisplay]</file> Splitting computation for simpler debugging.</div></center>
<p>


This preparation is absolutely not necessary, but it's setting us up for debugging success. Remember to stop debugging before recompiling!

</p><p>

Let's set the breakpoint at <code>ThisPlayCursor</code> and step into (`F10) our program. 

</p><p>

On the first round (and after they've been initialized), the values seem reasonable:
<div class='table'>
<table class="table"><tr><th style="text-align:left"> Name </th><th style="text-align:left"> Value </th></tr>
<tr><td style="text-align:left"> <code>ThisPlayCursor</code> </td><td style="text-align:left"> 1136  </td></tr>
<tr><td style="text-align:left"> <code>XReal</code> </td><td style="text-align:left"> 3.6920002  </td></tr>
<tr><td style="text-align:left"> <code>X</code> </td><td style="text-align:left"> 19  </td></tr>
</table><center><div class="tablecaption"><a class="target" name="table_x">&nbsp;</a><b style="font-style:normal;">Table&nbsp;5:</b> X Calculation at the first round.</div></center></div>

</p><p>

However, if you run through the loop a few times (<code>F10</code> or <code>F5</code>), you'll eventually arrive to something like this:
<div class='table'>
<table class="table"><tr><th style="text-align:left"> Name </th><th style="text-align:left"> Value </th></tr>
<tr><td style="text-align:left"> <code>ThisPlayCursor</code> </td><td style="text-align:left"> 117702659  </td></tr>
<tr><td style="text-align:left"> <code>XReal</code> </td><td style="text-align:left"> 765067.250  </td></tr>
<tr><td style="text-align:left"> <code>X</code> </td><td style="text-align:left"> 765083  </td></tr>
</table><center><div class="tablecaption"><a class="target" name="table_x">&nbsp;</a><b style="font-style:normal;">Table&nbsp;6:</b> X Calculation before the crash.</div></center></div>

</p><p>

That's... bizarre. It seems like the issue isn't even coming from <code>C</code> calculation, but from the <code>PlayCursor</code> itself! 

</p><p>

Similarly to the <code>Pixel</code>, value, <code>PlayCursor</code> is always bound between a specific range: between 0 and <code>SecondaryBufferSize</code>. If you inspect the latter, it gives you <code>384000</code>, and the <code>PlayCursor</code> here is way outside of that range. 

</p><p>

Actually, this is something that we always expect to be true, so let's drop an assertion which would check just that.

</p><pre class="listing tilde"><code><span class="line">DWORD ThisPlayCursor = LastPlayCursor[PlayCursorIndex];</span><div class=" add"><span class="line">Assert(ThisPlayCursor &lt; SoundOutput-&gt;SecondaryBufferSize);</span></div><span class="line">f32 XReal = C * (f32)ThisPlayCursor;</span>
<span class="line"><span class="hljs-keyword">int</span> X = PadX + (<span class="hljs-keyword">int</span>) XReal;</span>
<span class="line">Win32DebugDrawVertical(Backbuffer, X, Top, Bottom, <span class="hljs-number">0xFFFFFFFF</span>);</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;32:</b> <file>[win32_handmade.cpp > Win32DebugSyncDisplay]</file> Asserting the <code>PlayCursor</code> never goes outside the bounds.</div></center>
<p>


As an aside, this in turn will lead to a compilation warning (signed/unsigned mismatch) which you can fix by changing the type of <code>SecondaryBufferSize</code> from <code>int</code> to <code>DWORD</code>. 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">win32_sound_output</span></span>
<span class="line">{</span></span>
<span class="line">    <span class="hljs-keyword">int</span> SamplesPerSecond;</span>
<span class="line">    <span class="hljs-keyword">int</span> BytesPerSample;</span><div class=" edit"><span class="line">    DWORD SecondaryBufferSize;</span></div><span class="line">    u32 RunningSampleIndex;</span>
<span class="line">    <span class="hljs-keyword">int</span> LatencySampleCount;</span>
<span class="line">};</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;33:</b> <file>[win32_handmade.h]</file> Setting up correct type for <code>SecondaryBufferSize</code>.</div></center>
<p>


Anyway, once we run the program now, the assertion will just go off, notifying us of what we've suspected already: the array of <code>PlayCursors</code> was set up incorrectly, and some values are garbage. In fact, if you check where we (don't) initialize the <code>DebugLastPlayCursor</code>, we currently leave our variable at whatever values that memory segment had: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-comment">// Just before the main loop</span></span>
<span class="line">game_input Input[<span class="hljs-number">2</span>] = {};</span>
<span class="line">game_input* OldInput = &amp;Input[<span class="hljs-number">0</span>];</span>
<span class="line">game_input* NewInput = &amp;Input[<span class="hljs-number">1</span>];</span>
<span class="line"></span>
<span class="line"><span class="hljs-keyword">int</span> DebugLastPlayCursorIndex = <span class="hljs-number">0</span>;</span>
<span class="line">DWORD DebugLastPlayCursor[GameUpdateHz]; <span class="hljs-comment">// &lt;- Here's your problem!</span></span></code></pre><p>

So in order to fix the bug, we simply need to initialize the array to <code>0</code>: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">int</span> DebugLastPlayCursorIndex = <span class="hljs-number">0</span>;</span><div class=" edit"><span class="line">DWORD DebugLastPlayCursor[GameUpdateHz] = {};</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;34:</b> <file>[win32_handmade.cpp > WinMain]</file> Properly initializing DebugLastPlayCursor.</div></center>

<a class="target" name="debugconclusion">&nbsp;</a><a class="target" name="sidedebugging/accessviolationinwin32debugdrawvertical/debugconclusion">&nbsp;</a><a class="target" name="toc4.1.4">&nbsp;</a><h3>Debug Conclusion</h3>
<p>


We successfully found and fixed the issue of the uninitialized array. We stepped through the memory, compared the numbers to verify that the Y was computed properly, therefore we identified X as the culprit.

</p><p>

<em class="underscore">(Continue to subsection  <a href="#toc2.1">2.1</a>)</em>

</p>
<a class="target" name="sideconsiderations">&nbsp;</a><a class="target" name="sideconsiderations">&nbsp;</a><a class="target" name="toc5">&nbsp;</a><h1>Side Considerations</h1>

<a class="target" name="windowscoreaudio">&nbsp;</a><a class="target" name="sideconsiderations/windowscoreaudio">&nbsp;</a><a class="target" name="toc5.1">&nbsp;</a><h2>Windows Core Audio</h2>
<p>


The Windows <a href="https://docs.microsoft.com/en-us/windows/win32/coreaudio/core-audio-apis-in-windows-vista">Core Audio API</a> and its sub-API <a href="https://docs.microsoft.com/en-us/windows/win32/coreaudio/wasapi">Windows Audio Session API (WASAPI)</a> are relatively recent audio APIs which were introduced in Windows Vista. DirectSound and other older APIs are all emulated on Core Audio, so eliminating the middle man does have an immediate positive effect on audio latency. 

</p><p>

To learn more about the API and how to implement it in Handmade Hero, check out <a href="https://hero.handmade.network/forums/code-discussion/t/102-day_19_-_audio_latency">this discussion on Handmade Network</a>.

</p>
<a class="target" name="navigation">&nbsp;</a><a class="target" name="navigation">&nbsp;</a><a class="target" name="toc6">&nbsp;</a><h1>Navigation</h1>
<p>


Previous: <a href="../html/day18.html">Day 18. Enforcing a Video Frame Rate</a>

</p><p>

Up Next: <a href="../html/day20.html">Day 20. Debugging the Audio Sync</a>

</p><p>

<a href="../index.md.html">Back to Index</a>

</p>
<div class="nonumberh1">Glossary </div>
<p>


<ul>
<li class="asterisk">Sound Sample</li></ul>

</p>
<div class="nonumberh1">MSDN</div>
<p>


<a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416818(v=vs.85)">DSBCAPS</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mt708925(v%3dvs.85)">GetCurrentPosition</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/coreaudio/core-audio-apis-in-windows-vista">Core Audio API</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/coreaudio/wasapi">WASAPI</a>

</p><p>

<style class="fallback">
  body {
    visibility: hidden;
    font-family: sans-serif;
  }
</style>

</p><p>

<script>
  markdeepOptions = { tocStyle: 'long' };
  window.alreadyProcessedMarkdeep ||
    (document.body.style.visibility = 'visible');
</script>

</p><p>

</p></span><div id="mdContextMenu" style="visibility:hidden"></div><div class="markdeepFooter"><i>formatted by <a href="https://casual-effects.com/markdeep" style="color:#999">Markdeep&nbsp;1.10&nbsp;&nbsp;</a></i><div style="display:inline-block;font-size:13px;font-family:'Times New Roman',serif;vertical-align:middle;transform:translate(-3px,-1px)rotate(135deg);">&#x2712;</div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>