<meta charset="utf-8" />
<link rel="stylesheet" href="../css/style.css" />

**Day 24. Win32 Platform Layer Cleanup** 
_Video Length (including Q&A): [1h39](https://hero.handmade.network/episode/code/day024/)_ 

(insert intro.md.html here) 

Today is the cleanup day. 

# Set Controller Type

~~~~~~~ C++
DWORD OurControllerIndex = ControllerIndex + 1;
game_controller_input *OldController = GetController(OldInput, OurControllerIndex);
game_controller_input *NewController = GetController(NewInput, OurControllerIndex);

XINPUT_STATE ControllerState;
if (XInputGetState(ControllerIndex, &ControllerState) == ERROR_SUCCESS)
{
    NewController->IsConnected = true;
~~~~~~~ C++ add
    NewController->IsAnalog = OldController->IsAnalog;
~~~~~~~ C++
    
    // NOTE(casey): This controller is plugged in
    // TODO(casey): See if ControllerState.dwPacketNumber increments too rapidly
    XINPUT_GAMEPAD *Pad = &ControllerState.Gamepad;

    NewController->StickAverageX = Win32ProcessXInputStickValue
        (Pad->sThumbLX,XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE);
    NewController->StickAverageY = Win32ProcessXInputStickValue
        (Pad->sThumbLY,XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE);
    
    if ((NewController->StickAverageX != 0.0f) ||
        (NewController->StickAverageY != 0.0f))
    {
        NewController->IsAnalog = true;
    }
    
    if (Pad->wButtons & XINPUT_GAMEPAD_DPAD_UP)
    {
        NewController->StickAverageY = 1.0f;
        NewController->IsAnalog = false;
    }
    
    if (Pad->wButtons & XINPUT_GAMEPAD_DPAD_DOWN)
    {
        NewController->StickAverageY = -1.0f;
        NewController->IsAnalog = false;
    }
    
    if (Pad->wButtons & XINPUT_GAMEPAD_DPAD_LEFT)
    {
        NewController->StickAverageX = -1.0f;
        NewController->IsAnalog = false;
    }
    
    if (Pad->wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)
    {
        NewController->StickAverageX = 1.0f;
        NewController->IsAnalog = false;
    }
    // ...
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> .]

Would not setting `IsAnalog` create issues in the future? We don't know. But it is cleaner to do so, and it's cleanup day. 

# Set Fixed Output Size

~~~~~~~ C++
internal void
Win32DisplayBufferInWindow(...)
{
~~~~~~~ C++ edit
    // NOTE(casey): For prototyping purposes, we're going to always blit
    // 1-to-1 pixels to make sure we don't introduce artifacts with
    // stretching while we are learning to code the renderer!
~~~~~~~ C++
    StretchDIBits(DeviceContext,
~~~~~~~ C++ edit
                  0, 0, Buffer->Width, Buffer->Height,
~~~~~~~ C++
                  0, 0, Buffer->Width, Buffer->Height,
                  Buffer->Memory,
                  &Buffer->Info,
                  DIB_RGB_COLORS, SRCCOPY);
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp]</file> .]

# Improve `build.bat`

~~~~~~~ batch
set compiler=%compiler%     -Oi                    &:: Use assembly intrinsics where possible
~~~~~~~ batch edit
set compiler=%compiler%     -MTd                   &:: Include CRT library in the executable (static link)
~~~~~~~ batch
set compiler=%compiler%     -Gm-                   &:: Disable minimal rebuild
~~~~~~~
[Listing [x]: <file>[build.bat]</file> .]


~~~~~~~ C++
char SourceGameCodeDLLFilename[] = "handmade.dll";
char SourceGameCodeDLLFullPath[MAX_PATH];

CatStrings(OnePastLastSlash - EXEFilename, EXEFilename, 
            sizeof(SourceGameCodeDLLFilename) - 1, SourceGameCodeDLLFilename, 
            sizeof(SourceGameCodeDLLFullPath), SourceGameCodeDLLFullPath);

char TempGameCodeDLLFilename[] = "handmade_temp.dll";
char TempGameCodeDLLFullPath[MAX_PATH];

CatStrings(OnePastLastSlash - EXEFilename, EXEFilename, 
            sizeof(TempGameCodeDLLFilename) - 1, TempGameCodeDLLFilename, 
            sizeof(TempGameCodeDLLFullPath), TempGameCodeDLLFullPath);
~~~~~~~

We want to pull this out in a separate function that we can recycle. But first, we want to expand our `win32_state` to keep track of things like the EXE path and `OnePastLastSlash` pointer.

~~~~~~~ C++
struct win32_state
{
    u64 TotalSize;
    void *GameMemoryBlock;
    
    HANDLE RecordingHandle;
    int InputRecordingIndex;
    
    HANDLE PlaybackHandle;
    int InputPlayingIndex;
    
~~~~~~~ C++ add
    char EXEFilename[MAX_PATH];
    char *OnePastLastEXEFilenameSlash;
~~~~~~~ C++
};
~~~~~~~
[Listing [x]: <file>[win32_handmade.h]</file> .]

We aren't 100% comfortable with using `MAX_PATH`. This is an obsolete structure which is sometimes ignored by modern API, so let's use an intermediary `define` so that we can eventually revisit it. 

~~~~~~~ C++ add
#define WIN32_STATE_FILENAME_COUNT MAX_PATH
~~~~~~~ C++
struct win32_state
{
    u64 TotalSize;
    void *GameMemoryBlock;
    
    HANDLE RecordingHandle;
    int InputRecordingIndex;
    
    HANDLE PlaybackHandle;
    int InputPlayingIndex;
    
~~~~~~~ C++ add
    char EXEFilename[WIN32_STATE_FILENAME_COUNT];
    char *OnePastLastEXEFilenameSlash;
~~~~~~~ C++
};
~~~~~~~ 
[Listing [x]: <file>[win32_handmade.h]</file> .]



~~~~~~~ C++
// NOTE(casey): Never use MAX_PATH in code that is user-facing, because it
// can be dangerous and lead to bad results.
char EXEFilename[MAX_PATH];
DWORD SizeOfFilename = GetModuleFileNameA(0, EXEFilename, sizeof(EXEFilename));
char *OnePastLastSlash = EXEFilename;
for (char *Scan = EXEFilename;
        *Scan;
        ++Scan)
{
    if (*Scan == '\\')
    {
        OnePastLastSlash = Scan + 1;
    }
}

char SourceGameCodeDLLFilename[] = "handmade.dll";
~~~~~~~ C++ edit
char SourceGameCodeDLLFullPath[WIN32_STATE_FILENAME_COUNT];
~~~~~~~ C++

CatStrings(OnePastLastSlash - EXEFilename, EXEFilename, 
            sizeof(SourceGameCodeDLLFilename) - 1, SourceGameCodeDLLFilename, 
            sizeof(SourceGameCodeDLLFullPath), SourceGameCodeDLLFullPath);

char TempGameCodeDLLFilename[] = "handmade_temp.dll";
~~~~~~~ C++ edit
char TempGameCodeDLLFullPath[WIN32_STATE_FILENAME_COUNT];
~~~~~~~ C++
CatStrings(OnePastLastSlash - EXEFilename, EXEFilename, 
            sizeof(TempGameCodeDLLFilename) - 1, TempGameCodeDLLFilename, 
            sizeof(TempGameCodeDLLFullPath), TempGameCodeDLLFullPath);
   
~~~~~~~ 
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> .]



~~~~~~~ C++ add
internal void
Win32GetEXEFilename(win32_state *State)
{
    // NOTE(casey): Never use MAX_PATH in code that is user-facing, because it
    // can be dangerous and lead to bad results.
    char EXEFilename[MAX_PATH];
    DWORD SizeOfFilename = GetModuleFileNameA(0, EXEFilename, sizeof(EXEFilename));
    char *OnePastLastSlash = EXEFilename;
    for (char *Scan = EXEFilename;
         *Scan;
         ++Scan)
    {
        if (*Scan == '\\')
        {
            OnePastLastSlash = Scan + 1;
        }
    }
}
~~~~~~~ C++

int CALLBACK
WinMain(...)
{
~~~~~~~ C++ add
    win32_state Win32State = {};

    Win32GetEXEFilename(Win32State);


~~~~~~~ C++ delete
    // NOTE(casey): Never use MAX_PATH in code that is user-facing, because it
    // can be dangerous and lead to bad results.
    char EXEFilename[MAX_PATH];
    DWORD SizeOfFilename = GetModuleFileNameA(0, EXEFilename, sizeof(EXEFilename));
    char *OnePastLastSlash = EXEFilename;
    for (char *Scan = EXEFilename;
         *Scan;
         ++Scan)
    {
        if (*Scan == '\\')
        {
            OnePastLastSlash = Scan + 1;
        }
    }
~~~~~~~ C++
    
    char SourceGameCodeDLLFilename[] = "handmade.dll";
    char SourceGameCodeDLLFullPath[WIN32_STATE_FILENAME_COUNT];
    
    CatStrings(OnePastLastSlash - EXEFilename, EXEFilename, 
               sizeof(SourceGameCodeDLLFilename) - 1, SourceGameCodeDLLFilename, 
               sizeof(SourceGameCodeDLLFullPath), SourceGameCodeDLLFullPath);
    
    char TempGameCodeDLLFilename[] = "handmade_temp.dll";
    char TempGameCodeDLLFullPath[WIN32_STATE_FILENAME_COUNT];
    
    CatStrings(OnePastLastSlash - EXEFilename, EXEFilename, 
               sizeof(TempGameCodeDLLFilename) - 1, TempGameCodeDLLFilename, 
               sizeof(TempGameCodeDLLFullPath), TempGameCodeDLLFullPath);
    
    LARGE_INTEGER PerfCountFrequencyResult;

    // ...    
    if (Window)
    {
~~~~~~~ C++ delete
        win32_state Win32State = {};
        Win32State.InputRecordingIndex = 0;
        Win32State.InputPlayingIndex = 0;
~~~~~~~ C++
        // ...
    }
    // ...
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp]</file> .]


~~~~~~~ C++ delete
// NOTE(casey): Never use MAX_PATH in code that is user-facing, because it
// can be dangerous and lead to bad results.
char EXEFilename[MAX_PATH];
~~~~~~~ C++ edit
DWORD SizeOfFilename = GetModuleFileNameA(0, State->EXEFilename, sizeof(State->EXEFilename));
State->OnePastLastEXEFilenameSlash = State->EXEFilename;
for (char *Scan = State->EXEFilename;
~~~~~~~ C++
        *Scan;
        ++Scan)
{
    if (*Scan == '\\')
    {
~~~~~~~ C++ edit
        State->OnePastLastEXEFilenameSlash = Scan + 1;
~~~~~~~ C++
    }
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > Win32GetEXEFilename]</file> .]



~~~~~~~ C++ add
internal void 
Win32BuildEXEPathFilename(win32_state *State, char *Filename,
                                        int DestCount, char *Dest)
{
    char SourceGameCodeDLLFilename[] = "handmade.dll";
    char SourceGameCodeDLLFullPath[WIN32_STATE_FILENAME_COUNT];
    
    CatStrings(OnePastLastSlash - EXEFilename, EXEFilename, 
               sizeof(SourceGameCodeDLLFilename) - 1, SourceGameCodeDLLFilename, 
               sizeof(SourceGameCodeDLLFullPath), SourceGameCodeDLLFullPath);
}
~~~~~~~ C++

int CALLBACK
WinMain(...)
{
    win32_state Win32State = {};

    Win32GetEXEFilename(Win32State);

~~~~~~~ C++ add
    char SourceGameCodeDLLFullPath[WIN32_STATE_FILENAME_COUNT];
    Win32BuildEXEPathFilename(&Win32State, "handmade.dll", 
                              sizeof(SourceGameCodeDLLFullPath), SourceGameCodeDLLFullPath);
    char TempGameCodeDLLFullPath[WIN32_STATE_FILENAME_COUNT];
    Win32BuildEXEPathFilename(&Win32State, "handmade_temp.dll", 
                              sizeof(TempGameCodeDLLFullPath), TempGameCodeDLLFullPath);
    
~~~~~~~ C++ delete
    char SourceGameCodeDLLFilename[] = "handmade.dll";
    char SourceGameCodeDLLFullPath[WIN32_STATE_FILENAME_COUNT];
    
    CatStrings(OnePastLastSlash - EXEFilename, EXEFilename, 
               sizeof(SourceGameCodeDLLFilename) - 1, SourceGameCodeDLLFilename, 
               sizeof(SourceGameCodeDLLFullPath), SourceGameCodeDLLFullPath);
    
    char TempGameCodeDLLFilename[] = "handmade_temp.dll";
    char TempGameCodeDLLFullPath[WIN32_STATE_FILENAME_COUNT];
    
    CatStrings(OnePastLastSlash - EXEFilename, EXEFilename, 
               sizeof(TempGameCodeDLLFilename) - 1, TempGameCodeDLLFilename, 
               sizeof(TempGameCodeDLLFullPath), TempGameCodeDLLFullPath);
~~~~~~~ C++
    
    LARGE_INTEGER PerfCountFrequencyResult;
    // ... 
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp]</file> .]

We don't need that `- 1` since we expect to get exactly the length we need.

~~~~~~~ C++ delete
char SourceGameCodeDLLFilename[] = "handmade.dll";
char SourceGameCodeDLLFullPath[WIN32_STATE_FILENAME_COUNT];
~~~~~~~ C++ edit
    
CatStrings(State->OnePastLastEXEFilenameSlash - State->EXEFilename, State->EXEFilename, 
           StringLength(Filename), Filename, 
           DestCount, Dest);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > Win32BuildEXEPathFilename]</file> .]

The way the C strings are stored, they are just bytes of data with the last byte being 0. So we'll count all the bytes until we reach 0 (at least for the ASCII strings, Unicode is a little bit more involved but we won't mess around that for now). 

~~~~~~~ C++ add
internal int
StringLength(char *String)
{
    int Count = 0;
    while (*String++)
    {
        ++Count;
    }
    return (Count);
}
~~~~~~~ C++

internal void 
Win32BuildEXEPathFilename(...)
{
    //...
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp]</file> .]

Now we have a convenient function that we can use whenever we want to.

Before we move on, let's do some reorganization. We'll move the functions `CatStrings`, `StringLength`, `Win32GetEXEFilename` and `Win32BuildEXEPathFilename` to the top of `win32_handmade.cpp`, just before our utility functions: 

~~~~~~~ C++ 
typedef DIRECT_SOUND_CREATE(direct_sound_create);

~~~~~~~ C++ add
internal void
CatStrings(size_t SourceACount, char *SourceA, 
           size_t SourceBCount, char *SourceB,
           size_t DestCount, char *Dest)
{
    // + contents 
}

internal int
StringLength(char *String)
{
    // + contents
}

internal void
Win32GetEXEFilename(win32_state *State)
{
    // + contents
}

internal void 
Win32BuildEXEPathFilename(win32_state *State, char *Filename,
                          int DestCount, char *Dest)
{
    // + contents
}

~~~~~~~ C++
DEBUG_PLATFORM_FREE_FILE_MEMORY(DEBUGPlatformFreeFileMemory)
{
    // ... 
}

// ... 
~~~~~~~ C++ delete
internal void
CatStrings(size_t SourceACount, char *SourceA, 
           size_t SourceBCount, char *SourceB,
           size_t DestCount, char *Dest)
{
    // ... 
}

internal int
StringLength(char *String)
{
    // ... 
}

internal void
Win32GetEXEFilename(win32_state *State)
{
    // ...
}

internal void 
Win32BuildEXEPathFilename(win32_state *State, char *Filename,
                          int DestCount, char *Dest)
{
    // ... 
}
~~~~~~~ C++
int CALLBACK
WinMain(...)
{
    // ... 
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp]</file> Remember to actually copy-paste the contents of these functions!!]

This allows us to use these path-assembling functions on our Input Recording/Playback functions! We don't want them to live inside our `data` folder, this is the folder for _good_ data.

~~~~~~~ C++ add
internal void
Win32GetInputFileLocation(win32_state *State, int SlotIndex, int DestCount, char *Dest)
{
    Assert(SlotIndex == 1);
    Win32BuildEXEPathFilename(State, "loop_edit.hmi", DestCount, Dest);
}
~~~~~~~ C++

internal void
Win32BeginRecordingInput(win32_state *State, int InputRecordingIndex)
{
    State->InputRecordingIndex = InputRecordingIndex;
    
~~~~~~~ C++ add
    char Filename[WIN32_STATE_FILENAME_COUNT];
    Win32GetInputFileLocation(State, InputRecordingIndex, WIN32_STATE_FILENAME_COUNT, Filename);
~~~~~~~ C++ delete
    char *Filename = "foo.hmi";
~~~~~~~ C++
    State->RecordingHandle = CreateFileA(Filename, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0);
    
    // ...
}

// ...

internal void
Win32BeginInputPlayback(win32_state *State, int InputPlayingIndex)
{
    State->InputPlayingIndex = InputPlayingIndex;
    
~~~~~~~ C++ add
    char Filename[WIN32_STATE_FILENAME_COUNT];
    Win32GetInputFileLocation(State, InputPlayingIndex, WIN32_STATE_FILENAME_COUNT, Filename);
~~~~~~~ C++ delete
    char *Filename = "foo.hmi";
~~~~~~~ C++
    
    State->PlaybackHandle = CreateFileA(Filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
    
    // ...
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp]</file> ]

# Get rid of topmost layered window for now

~~~~~~~ C++ edit
HWND Window = CreateWindowEx(0, // WS_EX_TOPMOST | WS_EX_LAYERED, 
                             WindowClass.lpszClassName, "Handmade Hero",
                             WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                             CW_USEDEFAULT, CW_USEDEFAULT,
                             CW_USEDEFAULT, CW_USEDEFAULT,
                             0, 0, Instance, 0);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> ]

~~~~~~~ C++
case WM_CLOSE:
{
    GlobalRunning = false;
} break;

case WM_ACTIVATEAPP:
{
~~~~~~~ C++ add
#if 0
~~~~~~~ C++
    if (WParam == TRUE)
    {
        SetLayeredWindowAttributes(Window, RGB(0, 0, 0), 255, LWA_ALPHA);
    }
    else
    {
        SetLayeredWindowAttributes(Window, RGB(0, 0, 0), 64, LWA_ALPHA);
    }
~~~~~~~ C++ add
#endif
~~~~~~~ C++
} break;

case WM_DESTROY:
{
    GlobalRunning = false;
} break;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > Win32MainWindowCallback]</file> ]

# Get the date without opening files

Let's review our `Win32GetLastWriteTime` function: 

~~~~~~~ C++
inline FILETIME
Win32GetLastWriteTime(char *Filename)
{
    FILETIME LastWriteTime = {};
    
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle = FindFirstFileA(Filename, &FindData);
    if (FindHandle != INVALID_HANDLE_VALUE)
    {
        LastWriteTime = FindData.ftLastWriteTime;
        FindClose(FindHandle);
    }
    
    return (LastWriteTime);
}
~~~~~~~

We can optimize this function by preventing us from opening the file, by using the [GetFileAttributesEx][] function.

~~~~~~~ C++ delete
WIN32_FIND_DATA FindData;
HANDLE FindHandle = FindFirstFileA(Filename, &FindData);
if (FindHandle != INVALID_HANDLE_VALUE)
{
    LastWriteTime = FindData.ftLastWriteTime;
    FindClose(FindHandle);
}
~~~~~~~ C++ add
WIN32_FILE_ATTRIBUTE_DATA Data;
if(GetFileAttributesExA(Filename, GetFileExInfoStandard, &Data))
{
    LastWriteTime = Data.ftLastWriteTime;
}
~~~~~~~ C++
return (LastWriteTime);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > Win32GetLastWriteTime]</file> ]

# Remove Stub Functions for Platform Calls

~~~~~~~ C++
#define GAME_UPDATE_AND_RENDER(name) void name(game_memory *Memory, game_input *Input, game_offscreen_buffer* Buffer)
typedef GAME_UPDATE_AND_RENDER(game_update_and_render);
~~~~~~~ C++ delete
GAME_UPDATE_AND_RENDER(GameUpdateAndRenderStub) { }
~~~~~~~ C++

// ...

#define GAME_GET_SOUND_SAMPLES(name) void name(game_memory *Memory, game_sound_output_buffer *SoundBuffer)
typedef GAME_GET_SOUND_SAMPLES(game_get_sound_samples);
~~~~~~~ C++ delete
GAME_GET_SOUND_SAMPLES(GameGetSoundSamplesStub) { }
~~~~~~~
[Listing [x]: <file>[handmade.h]</file> ]

~~~~~~~ C++
internal win32_game_code
Win32LoadGameCode(char *SourceDLLName, char *TempDLLName)
{
    win32_game_code Result = {};
    
    // ...       
    if (!Result.IsValid)
    {
~~~~~~~ C++ edit
        Result.UpdateAndRender = 0;
        Result.GetSoundSamples = 0;
~~~~~~~ C++
    }
    
    return(Result);
}

internal void
Win32UnloadGameCode(win32_game_code *GameCode)
{
    if (GameCode->GameCodeDLL)
    {
        FreeLibrary(GameCode->GameCodeDLL);
        GameCode->GameCodeDLL = 0;
    }
    
    GameCode->IsValid = false;
~~~~~~~ C++ edit
    GameCode->UpdateAndRender = 0;
    GameCode->GetSoundSamples = 0;
~~~~~~~ C++
}

// ...

int CALLBACK
WinMain(...)
{
~~~~~~~ C++ add
    if (Game.UpdateAndRender)
    {
~~~~~~~ C++
        Game.UpdateAndRender(&GameMemory, NewInput, &Buffer);
~~~~~~~ C++ add
    }
~~~~~~~ C++
    
    // ...

~~~~~~~ C++ add
    if (Game.GetSoundSamples)
    {
    ~~~~~~~ C++
        Game.GetSoundSamples(&GameMemory, &SoundBuffer);
    ~~~~~~~ C++ add
    }
~~~~~~~ C++
// ... 
}
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp]</file> ]

~~~~~~~ C++
struct win32_game_code
{
    HMODULE GameCodeDLL;
    FILETIME DLLLastWriteTime;
    
~~~~~~~ C++ add
    // IMPORTANT(casey): Either of the callbacks can be 0!
    // You must check before calling.
~~~~~~~ C++
    game_update_and_render *UpdateAndRender;
    game_get_sound_samples *GetSoundSamples;
    
    b32 IsValid;
};
~~~~~~~
[Listing [x]: <file>[win32_handmade.h]</file> ]

# Enable Large-Page Support

[Large-Page Support][]

~~~~~~~ C++
Win32State.TotalSize = (GameMemory.PermanentStorageSize + GameMemory.TransientStorageSize);
Win32State.GameMemoryBlock = VirtualAlloc(BaseAddress, (size_t)Win32State.TotalSize,
~~~~~~~ C++ edit
                                          MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES, 
~~~~~~~ C++
                                          PAGE_READWRITE);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> Enabling Large-page support for the game memory block.]

------------------------
<!-- 
[Listing [x]: <file>[]</file> .]
![Figure [x]: .](../media/day16/.jpg) 
[Figure [x]: .]
-->
------------------------






















# Recap 

# Exercises 

# Programming Notions 

# Side Considerations 

# Navigation 

Previous: [Day 23. Looped Live Code Editing][day 23]

Up Next: [Day 25. Finishing the Win32 Prototyping Layer][day 25]

[Back to Index](../index.md.html)

(#) Glossary 

(insert glossary/glossary_day24.md.html here)

(insert references/refs_day24.md.html here) 

(insert links.md.html here)

<style class="fallback">
  body {
    visibility: hidden;
    font-family: sans-serif;
  }
</style>
<!-- Markdeep: https://casual-effects.com/markdeep/ -->
<script>
  markdeepOptions = { tocStyle: 'long' };
  window.alreadyProcessedMarkdeep ||
    (document.body.style.visibility = 'visible');
</script>
<script src="../js/markdeep.min.js" charset="utf-8"></script>
