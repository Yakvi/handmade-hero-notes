<meta charset="utf-8" />
<link rel="stylesheet" href="../css/style.css" />

**Day 20. Debugging the Audio Sync** 
_Video Length (including Q&A): [2h46](https://hero.handmade.network/episode/code/day020/)_ 

(insert intro.md.html here) 

If you got this far, congratulations! Debugging sound issues may well be among the most tedious tasks one would face (unless that's exactly your cup of tea). However, we aren't out of the woods yet; the system we have in our hands is still quite latent, and there's room for improvement even at this early stage. The root of our concern is the following: sure, with the default sound API and the integrated sound module, audio is laggy. But what if someone is an audio junkie and has a powerful sound card with zero latency? We want to support them as well! And today we need to think real hard to make it happen.

You might have noticed a trend throughout this series: we think first, and type after. If you understand at least on assumption level the code that you're writing, it will be much easier for you to, first, translate your thoughts into good code and, later, actually be able to read and edit it. That said, you never want to go too deep down the rabbit hole and define every single scrupulous detail: at that point, you might as well write the code directly! Leave yourself some space for a good surprise.

# Deep Dive into the Issue

## Define the Problem

Let's go back into our favorite timeline. 

***************************************************************
*                     Next Frame Preparation                  *
*                (User Input processing, World update,        *
*                Graphics rendering and writing Audio)        *
*                      /     |      |     \                   *
*                   .-+.   .-+.   .-+.   .-+.                 *
*                  |    | |    | |    | |    |                *
* |               |      |      |      |      |          time *
* +---------------+------+------+------+-....-+------+---->   *
* |               |      |      |      |      |      |        *
*                 0      1      2     ...     N               *
* ^               ^      ^      ^      ^      ^      ^        *
* |               |       \      \     |     /       |        *
* |               |        \      \    |    /        |        *
* game           first    Next frame is displayed    game     *
* starts         frame          "frame flip"         exits    *
* running        is displayed                                 *
*                                                             *
***************************************************************
[Figure [x]: Game lifetime. Everything on it should be familiar to you by now.]

We have decided to aim at 30 frames per second for the time being. This means that every second (or every 1000 milliseconds) we aim to output 30 frames. Thus, each frame only has $\frac{1000}{30} \approx 33.3$ milliseconds to do all the work. 

Each frame we do the work to display the image and the sound of our next frame. In an ideal world, both would go out at the same time: at the magical moment in time that we call "frame flip". 

***************************************************************
*               .---. image is                                *
*               | ðŸ•º | displayed                               *
*               '---'                                         *
*                audio is played                              *
*               +~~~~~~~~~~~~~                                *
* |   frame 0   |   frame 1   |   frame 2   |   ...      time *
* +---+---------+-------------+-------------+------------->   *
* |   ^         ^                                             *
*     |         |                                             *
*     +--------'                                              *
*     |         Frame                                         *
*    Work       Flip                                          *
*   starts                                                    *
*                                                             *
*                                                             *
***************************************************************
[Figure [x]: Frame flip workflow in an ideal world.]

This work happens some time after the frame begins: before we get started on rendering, we need to collect the user input update our world state, and maybe do some additional preparations as necessary. Even further still, we're currently writing audio just before the frame flip, at the last possible moment in fact. The idea being that the moment we send something to the hardware, it will be reproduced to the user.

*******************************************************************
*                                                                 *
*        Update game world                                        *
*        Prepare for render                        wait           *
*              |                                    |             *
*           .--+---.                           .----+---.         *
*    |     |        |                         |          | repeat *
* ---+-----+--------+-------------------------+----------+-->     *
*    |     |        |                         |          ^        *
*     '-+-'          '-----------+-----------'           |        *
*       |                        |                   frame flip   *
*   gather input               Render                             *
* (keyboard, mouse,                                               *
*     gamepad)                                                    *
*                                                                 *
*******************************************************************
[Figure [x]: Breakdown of the work within a single frame. Proportions of game update/render times will differ. Of course, some of these tasks may run in parallel in the future.]

Unfortunately for us, hardware lag exists. Furthermore, DirectSound (on our specific machine) is not cooperating with us. The API has a delay on the order of 30-33ms! That's in fact a full frame of ours! So this is what happens with our frames in practice: 

***************************************************************
*               .---. image is                                *
*               | ðŸ•º | displayed                               *
*               '---'                                         *
*               |            audio is played                  *
*               |           +~~~~~~~~~~~~~                    *
* |   frame 0   |  frame 1  | |   frame 2   |   ...      time *
* +---+---------+-----------+-+-------------+------------->   *
* |   ^       ^ |             |             |                 *
*     |       | ^                                             *
*     |       |  \                                            *
*    Work     |   '----expected                               *
*   starts    |       frame flip                              *
*             |                                               *
*           Send work to                                      *
*           the hardware                                      *
*                                                             *
***************************************************************
[Figure [x]: Frame flip workflow in our reality.]

As you can see, by the time audio starts playing, it's almost time for the next frame to flip! And, when we blindly assumed low latency scenario, this is what created the audible clicks for us: information kept getting overwritten from under the Play Cursor.

If we want to avoid latency, we'd ideally have to send audio data before our rendering work on a frame even starts! This isn't necessarily impossible but would introduce frame lag anyway, since the new user input and world state wouldn't be accounted in the old sound... On surface this seems like an exercise in chasing one's own tail.

## Evaluate the Options

At the end of the day, under the current system there's no way to compute sound for a frame and have it reproduced together with its image. This leaves us with the following options: 

* Accept the reality that our audio will always be a couple frames behind the image. After all, so many games already do this! This would simply regress our audio to be latent by design.
* Have a "low latency mode" which would take over on a machine with a great sound card and low latency; do things the slow way otherwise. 
* Continue tinkering on the inner workings of our platform layer.
* Fix latency issues by essentially getting input and world state a frame before. This would introduce input lag, which seems like a worse tradeoff in an action game like ours. 

The input lag option in our particular case seems like the worst of all, so we can rule it out right away. In fact, we want to push the input capture as close to the frame flip as possible, so that the user doesn't get a feeling of an unresponsive game.

## Draft an Action Plan

Let's start with the simplest solution we might imagine. We write our sound to the hardware as soon as we have it, without waiting for frame flip. So if, for instance, audio is sent out 15ms after the frame starts, it will be reproduced ~15ms after the frame flip happened. 

The game won't know of this happening: platform will lie to the game saying that the audio will be reproduced at the frame flip. 

***************************************************************
*               .---. image is                                *
*               | ðŸ•º | displayed                               *
*               '---'                                         *
*               |       audio is played                       *
*               |      +~~~~~~~~~~~~~                         *
* |             |      |      |             |   ...      time *
* +------+------+------+------+-------------+------------->   *
* |      ^      |             |             |                 *
*        |      ^                                             *
*        |      |                                             *
* Calculate and |                                             *
* send audio    |                                             *
*               |                                             *
*           frame flip                                        *
*                                                             *
***************************************************************
[Figure [x]: Sending the audio out as soon as it's ready.]

!!! Trivia 
    Unfortunately, this kind of unsynchronized audio loop is common in the industry. It's a bit sloppy but better than the alternative of pushing audio to the next frame and have a whole frame of buffering instead of roughly a half. 

This solution also opens the road for the "low latency mode" we proposed above. If we determine that we're playing on the extremely performant hardware, the sound will be target the frame flip instead of whenever it's ready.

// FIXME: Undocumented code edits start

~~~~~~~ C++ delete
#define FramesOfAudioLatency 3
~~~~~~~ C++
    // TODO(casey): How do we reliably query on monitor refresh rate on Windows?
#define MonitorRefreshHz 60
#define GameUpdateHz (MonitorRefreshHz / 2)

// ... 

// NOTE(casey): Sound test
win32_sound_output SoundOutput = {};
SoundOutput.SamplesPerSecond = 48000;
SoundOutput.BytesPerSample = sizeof(s16) * 2;
SoundOutput.SecondaryBufferSize = 2 * SoundOutput.SamplesPerSecond * SoundOutput.BytesPerSample;
SoundOutput.RunningSampleIndex = 0;
~~~~~~~ C++ add
// TODO(casey): Get rid of LatencySampleCount
~~~~~~~ C++ edit
SoundOutput.LatencySampleCount = 3 *(SoundOutput.SamplesPerSecond / GameUpdateHz);           
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> .]

This is a circular buffer so we need to account for when the write cursor is in front.

~~~~~~~ C++
#if HANDMADE_INTERNAL
DWORD PlayCursor;
DWORD WriteCursor;
GlobalSecondaryBuffer->GetCurrentPosition(&PlayCursor, &WriteCursor);

~~~~~~~ C++ add
DWORD UnwrappedWriteCursor = WriteCursor;
if (UnwrappedWriteCursor < PlayCursor)
{
    UnwrappedWriteCursor += SoundOutput.SecondaryBufferSize;
}
DWORD AudioLatencyBytes = UnwrappedWriteCursor - PlayCursor;
~~~~~~~ C++

char TextBuffer[256];
~~~~~~~ C++ edit
sprintf_s(TextBuffer, sizeof(TextBuffer), "LPC:%u BTL:%u TC:%u BTW:%u - PC:%u WC:%u DELTA:%u\n",
            LastPlayCursor, ByteToLock, TargetCursor, BytesToWrite,
            PlayCursor, WriteCursor, AudioLatencyBytes);
~~~~~~~ C++
OutputDebugStringA(TextBuffer);
#endif
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> .]

DELTA is nice and stable at 5760, and circular buffer hack works well. 

~~~~~~~ C++
DWORD UnwrappedWriteCursor = WriteCursor;
if (UnwrappedWriteCursor < PlayCursor)
{
    UnwrappedWriteCursor += SoundOutput.SecondaryBufferSize;
}
DWORD AudioLatencyBytes = UnwrappedWriteCursor - PlayCursor;
~~~~~~~ C++ add
f32 AudioLatencySeconds = ((f32)AudioLatencyBytes / (f32)SoundOutput.BytesPerSample) / 
                           (f32)SoundOutput.SamplesPerSecond;
~~~~~~~ C++
char TextBuffer[256];
~~~~~~~ C++ edit
sprintf_s(TextBuffer, sizeof(TextBuffer), "LPC:%u BTL:%u TC:%u BTW:%u - PC:%u WC:%u DELTA:%u (%fs)\n",
            LastPlayCursor, ByteToLock, TargetCursor, BytesToWrite,
            PlayCursor, WriteCursor, AudioLatencyBytes, AudioLatencySeconds);
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> .]

Note about printf values. `%.2f` makes it so it's only 2 decimal points.

Dimensional analysis aside: Bytes * (Sample / Bytes) * (Seconds / Samples). Simple to work out in the head but also can use the trick on paper if necessary. In fact, let's place a todo to simplify similar calculations in the future.

~~~~~~~ C++
struct win32_sound_output
{
    int SamplesPerSecond;
    int BytesPerSample;
    DWORD SecondaryBufferSize;
    u32 RunningSampleIndex;
    int LatencySampleCount;
~~~~~~~ C++ add
    // TODO(casey): Math get simpler if we add a "bytes per second" field? 
~~~~~~~ C++
};
~~~~~~~
[Listing [x]: <file>[win32_handmade.h]</file> .]

Now, pull them out from the game loop, these are useful values that we want to keep track of between frames.

~~~~~~~ C++
// ... 
// Just before the main loop
// ... 

int DebugTimeMarkerIndex = 0;
win32_debug_time_marker DebugTimeMarkers[GameUpdateHz / 2] = {};

DWORD LastPlayCursor = 0;
b32 SoundIsValid = false;
~~~~~~~ C++ add
DWORD AudioLatencyBytes = 0;
f32 AudioLatencySeconds = 0;
~~~~~~~ C++

LARGE_INTEGER LastCounter = Win32GetWallClock();
u64 LastCycleCount = __rdtsc();
GlobalRunning = true;

// ... 
// Most of the main loop
// ... 

DWORD UnwrappedWriteCursor = WriteCursor;
if (UnwrappedWriteCursor < PlayCursor)
{
    UnwrappedWriteCursor += SoundOutput.SecondaryBufferSize;
}
~~~~~~~ C++ edit
AudioLatencyBytes = UnwrappedWriteCursor - PlayCursor;
AudioLatencySeconds = ((f32)AudioLatencyBytes / (f32)SoundOutput.BytesPerSample) / 
                           (f32)SoundOutput.SamplesPerSecond;
~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> .]

Having values gather around like this is a good indication that we're going to start gathering them together and we might do that soon, just not yet. It's better to wait until you're completely happy with how something works until you start gathering things together and pulling them out, otherwise you will fall in a lot of additional typing. Don't be too horrible! 

## Review target bytes calculation

We set our `ByteToLock` to be whatever our `RunningSampleIndex` was. We then calculate target cursor which takes into account latency. Now we want to finally start tracking the DirectSound's write cursor. up until now we were ignoring it.

~~~~~~~ C++
DWORD LastPlayCursor = 0;
~~~~~~~ C++ add
DWORD LastWriteCursor = 0;
~~~~~~~ C++
b32 SoundIsValid = false;
DWORD AudioLatencyBytes = 0;
f32 AudioLatencySeconds = 0;

// ... 
// Towards the end of the main loop
// ... 

DWORD PlayCursor = 0;
DWORD WriteCursor= 0;
if (SUCCEEDED(GlobalSecondaryBuffer->GetCurrentPosition(&PlayCursor, &WriteCursor)))
{
    LastPlayCursor = PlayCursor;
~~~~~~~ C++ add
    LastWriteCursor = WriteCursor;
~~~~~~~ C++
    if (!SoundIsValid)
    {
        SoundOutput.RunningSampleIndex = WriteCursor / SoundOutput.BytesPerSample;
        SoundIsValid = true;
    }
}
else
{
    SoundIsValid = false;
}

~~~~~~~
[Listing [x]: <file>[win32_handmade.cpp > WinMain]</file> .]

*****************************************************************************
*                                                                           *
*              Set TargetCursor                                             *
*             to the end of frame         Set TargetCursor                  *
*                    .-----.                 .-----.                        *
*                   |       |               |       |                       *
*    |              |       v|              |       v|                      *
*    +------+-------+--------+------+-------+--------+------------->        *
*    |      ^       ^        |      ^       ^        |                      *
*    .---.  |       |        .---.  |       |        .---.                  *
*    | ðŸ•º |  |       |        | ðŸ•º |  |       |        | ðŸ•º |                  *
*    '---'  |       |        '---'  |       |        '---'                  *
*     Ask where the |        |      |       |        |                      *
*      DirectSound  |        |   Wake up    |        |      ...             *
*      cursors are  |        |   and ask    |        |                      *
*        |          |        |    |         |        |                      *
*        +-->  WriteCursor   |    +-->  WriteCursor  |                      *
*      PlayCursor            |  PlayCursor           |                      *
*                            +~~~~~~~~~~~~~~~~~~~~~~~+~~~~~~~~~~~~~~~~~~~   *
*                            audio is playing for exactly one frame         *
*                            rinse and repeat for infinite sound            *
*                                                                           *
*****************************************************************************
[Figure [x]: Low latency path idea. ðŸ•º represents frame flips.]

Need to adjust by however much the clock consumes, so need to calculate _average_ wc movement instead of going straight to the end of frame.

If inside frame WC then always write average WC motion amount

I HATE PROGRAMMING 
I HATE PROGRAMMING 
    IT WORKS!
I LOVE PROGRAMMING 

*****************************************************************************
*                                                                           *
*                     Set TargetCursor to be slightly further ahead         *
*                                from the WriteCursor                       *
*                     (just a safety margin, don't wait until flip)         *
*                                      .-----.                              *
*                                     |       |                             *
*    |                                |       v      |                      *
*    +------+----------------+--------+--------------+------------->        *
*    |      ^                |        ^       |      |                      *
*    .---.  |                .---.    |       |      .---.                  *
*    | ðŸ•º |  |                | ðŸ•º |    |       |      | ðŸ•º |                  *
*    '---'  |                '---'    |       |      '---'                  *
*     Ask where the                   |       |                             *
*      DirectSound                    |       |                             *
*      cursors are                    |       |                             *
*        |                            |       |                             *
*        +-------------------->  WriteCursor  |                             *
*     PlayCursor                              |                             *
*                                             +~~~~~~~~~~~~~~~~~~~          *
*                            audio is still playing for exactly one frame   *
*                             but it's scheduled one frame in advance       *
*                                                                           *
*****************************************************************************
[Figure [x]: High latency path.]

// FIXME: 01:07

------------------------
<!-- 
[Listing [x]: <file>[]</file> .]
![Figure [x]: .](../media/day16/.jpg) 
[Figure [x]: .]
-->
------------------------






















# Recap 

# Exercises 

# Programming Notions 

# Side Considerations 

# Navigation 

Previous: [Day 19. Improving Audio Synchronization][day 19]

Up Next: [Day 21. Loading Game Code Dynamically][day 21]

[Back to Index](../index.md.html)

(#) Glossary 

(insert glossary/glossary_day20.md.html here)

(insert references/refs_day20.md.html here) 

(insert links.md.html here)

<style class="fallback">
  body {
    visibility: hidden;
    font-family: sans-serif;
  }
</style>
<!-- Markdeep: https://casual-effects.com/markdeep/ -->
<script>
  markdeepOptions = { tocStyle: 'long' };
  window.alreadyProcessedMarkdeep ||
    (document.body.style.visibility = 'visible');
</script>
<script src="../js/markdeep.min.js" charset="utf-8"></script>
