<meta charset="UTF-8"><meta http-equiv="content-type" content="text/html;charset=UTF-8"><meta name="viewport" content="width=600, initial-scale=1"><style>body{max-width:680px;margin:auto;padding:20px;text-align:justify;line-height:140%; -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;font-smoothing:antialiased;color:#222;font-family:Palatino,Georgia,"Times New Roman",serif}</style><style>@media print{*{-webkit-print-color-adjust:exact;text-shadow:none !important}}body{counter-reset: h1 h2 h3 h4 h5 h6 paragraph}@page{margin:0;size:auto}#mdContextMenu{position:absolute;background:#383838;cursor:default;border:1px solid #999;color:#fff;padding:4px 0px;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,"Helvetica Neue",sans-serif;font-size:85%;font-weight:600;border-radius:4px;box-shadow:0px 3px 10px rgba(0,0,0,35%)}#mdContextMenu div{padding:0px 20px}#mdContextMenu div:hover{background:#1659d1}.md code,.md pre{font-family:Menlo,Consolas,monospace;font-size:98%;text-align:left;line-height:140%}.md .mediumToc code,.md longToc code,.md .shortToc code,.md h1 code,.md h2 code,.md h3 code,.md h4 code,.md h5 code,.md h6 code{font-size:unset}.md div.title{font-size:26px;font-weight:800;line-height:120%;text-align:center}.md div.afterTitles{height:10px}.md div.subtitle{text-align:center}.md iframe.textinsert, .md object.textinsert,.md iframe:not(.markdeep){display:block;margin-top:10px;margin-bottom:10px;width:100%;height:75vh;border:1px solid #000;border-radius:4px;background:#f5f5f4}.md .image{display:inline-block}.md img{max-width:100%;page-break-inside:avoid}.md li{text-align:left;text-indent:0}.md pre.listing {width:100%;tab-size:4;-moz-tab-size:4;-o-tab-size:4;counter-reset:line;overflow-x:auto;resize:horizontal}.md pre.listing .linenumbers span.line:before{width:30px;margin-left:-28px;font-size:80%;text-align:right;counter-increment:line;content:counter(line);display:inline-block;padding-right:13px;margin-right:8px;color:#ccc}.md div.tilde{margin:20px 0 -10px;text-align:center}.md .imagecaption,.md .tablecaption,.md .listingcaption{display:inline-block;margin:7px 5px 12px;text-align:justify;font-style:italic}.md img.pixel{image-rendering:-moz-crisp-edges;image-rendering:pixelated}.md blockquote.fancyquote{margin:25px 0 25px;text-align:left;line-height:160%}.md blockquote.fancyquote::before{content:"“";color:#DDD;font-family:Times New Roman;font-size:45px;line-height:0;margin-right:6px;vertical-align:-0.3em}.md span.fancyquote{font-size:118%;color:#777;font-style:italic}.md span.fancyquote::after{content:"”";font-style:normal;color:#DDD;font-family:Times New Roman;font-size:45px;line-height:0;margin-left:6px;vertical-align:-0.3em}.md blockquote.fancyquote .author{width:100%;margin-top:10px;display:inline-block;text-align:right}.md small{font-size:60%}.md big{font-size:150%}.md div.title,contents,.md .tocHeader,.md h1,.md h2,.md h3,.md h4,.md h5,.md h6,.md .shortTOC,.md .mediumTOC,.nonumberh1,.nonumberh2,.nonumberh3,.nonumberh4,.nonumberh5,.nonumberh6{font-family:Verdana,Helvetica,Arial,sans-serif;margin:13.4px 0 13.4px;padding:15px 0 3px;border-top:none;clear:both}.md .tocTop {display:none}.md h1,.md h2,.md h3,.md h4,.md h5,.md h6,.md .nonumberh1,.md .nonumberh2,.md .nonumberh3,.md .nonumberh4,.md .nonumberh5,.md .nonumberh6{page-break-after:avoid;break-after:avoid}.md svg.diagram{display:block;font-family:Menlo,Consolas,monospace;font-size:98%;text-align:center;stroke-linecap:round;stroke-width:2px;page-break-inside:avoid;stroke:#000;fill:#000}.md svg.diagram .opendot{fill:#fff}.md svg.diagram .shadeddot{fill:#CCC}.md svg.diagram .dotteddot{stroke:#000;stroke-dasharray:4;fill:none}.md svg.diagram text{stroke:none}@media print{@page{margin:1in 5mm;transform: scale(150%)}}@media print{.md .pagebreak{page-break-after:always;visibility:hidden}}.md a{font-family:Georgia,Palatino,'Times New Roman'}.md h1,.md .tocHeader,.md .nonumberh1{border-bottom:3px solid;font-size:20px;font-weight:bold;}.md h1,.md .nonumberh1{counter-reset: h2 h3 h4 h5 h6}.md h2,.md .nonumberh2{counter-reset: h3 h4 h5 h6;border-bottom:2px solid #999;color:#555;font-weight:bold;font-size:18px;}.md h3,.md h4,.md h5,.md h6,.md .nonumberh3,.md .nonumberh4,.md .nonumberh5,.md .nonumberh6{font-family:Verdana,Helvetica,Arial,sans-serif;color:#555;font-size:16px;}.md h3{counter-reset:h4 h5 h6}.md h4{counter-reset:h5 h6}.md h5{counter-reset:h6}.md div.table{margin:16px 0 16px 0}.md table{border-collapse:collapse;line-height:140%;page-break-inside:avoid}.md table.table{margin:auto}.md table.calendar{width:100%;margin:auto;font-size:11px;font-family:Verdana,Helvetica,Arial,sans-serif}.md table.calendar th{font-size:16px}.md .today{background:#ECF8FA}.md .calendar .parenthesized{color:#999;font-style:italic}.md table.table th{color:#FFF;background-color:#AAA;border:1px solid #888;padding:8px 15px 8px 15px}.md table.table td{padding:5px 15px 5px 15px;border:1px solid #888}.md table.table tr:nth-child(even){background:#EEE}.md pre.tilde{border-top: 1px solid #CCC;border-bottom: 1px solid #CCC;padding: 5px 0 5px 20px;margin:0 0 0 0;background:#FCFCFC;page-break-inside:avoid}.md a.target{width:0px;height:0px;visibility:hidden;font-size:0px;display:inline-block}.md a:link, .md a:visited{color:#38A;text-decoration:none}.md a:link:hover{text-decoration:underline}.md dt{font-weight:700}.md dl>dd{margin-top:-8px; margin-bottom:8px}.md dl>table{margin:35px 0 30px}.md code{page-break-inside:avoid;} @media print{.md .listing code{white-space:pre-wrap}}.md .endnote{font-size:13px;line-height:15px;padding-left:10px;text-indent:-10px}.md .bib{padding-left:80px;text-indent:-80px;text-align:left}.markdeepFooter{font-size:9px;text-align:right;padding-top:80px;color:#999}.md .mediumTOC{float:right;font-size:12px;line-height:15px;border-left:1px solid #CCC;padding-left:15px;margin:15px 0px 15px 25px}.md .mediumTOC .level1{font-weight:600}.md .longTOC .level1{font-weight:600;display:block;padding-top:12px;margin:0 0 -20px}.md .shortTOC{text-align:center;font-weight:bold;margin-top:15px;font-size:14px}.md .admonition{position:relative;margin:1em 0;padding:.4rem 1rem;border-radius:.2rem;border-left:2.5rem solid rgba(68,138,255,.4);background-color:rgba(68,138,255,.15);}.md .admonition-title{font-weight:bold;border-bottom:solid 1px rgba(68,138,255,.4);padding-bottom:4px;margin-bottom:4px;margin-left: -1rem;padding-left:1rem;margin-right:-1rem;border-color:rgba(68,138,255,.4)}.md .admonition.tip{border-left:2.5rem solid rgba(50,255,90,.4);background-color:rgba(50,255,90,.15)}.md .admonition.tip::before{content:"\24d8";font-weight:bold;font-size:150%;position:relative;top:3px;color:rgba(26,128,46,.8);left:-2.95rem;display:block;width:0;height:0}.md .admonition.tip>.admonition-title{border-color:rgba(50,255,90,.4)}.md .admonition.warn,.md .admonition.warning{border-left:2.5rem solid rgba(255,145,0,.4);background-color:rgba(255,145,0,.15)}.md .admonition.warn::before,.md .admonition.warning::before{content:"\26A0";font-weight:bold;font-size:150%;position:relative;top:2px;color:rgba(128,73,0,.8);left:-2.95rem;display:block;width:0;height:0}.md .admonition.warn>.admonition-title,.md .admonition.warning>.admonition-title{border-color:rgba(255,145,0,.4)}.md .admonition.error{border-left: 2.5rem solid rgba(255,23,68,.4);background-color:rgba(255,23,68,.15)}.md .admonition.error>.admonition-title{border-color:rgba(255,23,68,.4)}.md .admonition.error::before{content: "\2612";font-family:"Arial";font-size:200%;position:relative;color:rgba(128,12,34,.8);top:-2px;left:-3rem;display:block;width:0;height:0}.md .admonition p:last-child{margin-bottom:0}.md li.checked,.md li.unchecked{list-style:none;overflow:visible;text-indent:-1.2em}.md li.checked:before,.md li.unchecked:before{content:"\2611";display:block;float:left;width:1em;font-size:120%}.md li.unchecked:before{content:"\2610"}</style><style>.md h1::before {
content:counter(h1) " ";
counter-increment: h1;margin-right:10px}.md h2::before {
content:counter(h1) "."counter(h2) " ";
counter-increment: h2;margin-right:10px}.md h3::before {
content:counter(h1) "."counter(h2) "."counter(h3) " ";
counter-increment: h3;margin-right:10px}.md h4::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) " ";
counter-increment: h4;margin-right:10px}.md h5::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) "."counter(h5) " ";
counter-increment: h5;margin-right:10px}.md h6::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) "."counter(h5) "."counter(h6) " ";
counter-increment: h6;margin-right:10px}</style><style>.hljs{display:block;overflow-x:auto;padding:0.5em;background:#fff;color:#000;-webkit-text-size-adjust:none}.hljs-comment{color:#006a00}.hljs-keyword{color:#02E}.hljs-literal,.nginx .hljs-title{color:#aa0d91}.method,.hljs-list .hljs-title,.hljs-tag .hljs-title,.setting .hljs-value,.hljs-winutils,.tex .hljs-command,.http .hljs-title,.hljs-request,.hljs-status,.hljs-name{color:#008}.hljs-envvar,.tex .hljs-special{color:#660}.hljs-string{color:#c41a16}.hljs-tag .hljs-value,.hljs-cdata,.hljs-filter .hljs-argument,.hljs-attr_selector,.apache .hljs-cbracket,.hljs-date,.hljs-regexp{color:#080}.hljs-sub .hljs-identifier,.hljs-pi,.hljs-tag,.hljs-tag .hljs-keyword,.hljs-decorator,.ini .hljs-title,.hljs-shebang,.hljs-prompt,.hljs-hexcolor,.hljs-rule .hljs-value,.hljs-symbol,.hljs-symbol .hljs-string,.hljs-number,.css .hljs-function,.hljs-function .hljs-title,.coffeescript .hljs-attribute{color:#A0C}.hljs-function .hljs-title{font-weight:bold;color:#000}.hljs-class .hljs-title,.smalltalk .hljs-class,.hljs-type,.hljs-typename,.hljs-tag .hljs-attribute,.hljs-doctype,.hljs-class .hljs-id,.hljs-built_in,.setting,.hljs-params,.clojure .hljs-attribute{color:#5c2699}.hljs-variable{color:#3f6e74}.css .hljs-tag,.hljs-rule .hljs-property,.hljs-pseudo,.hljs-subst{color:#000}.css .hljs-class,.css .hljs-id{color:#9b703f}.hljs-value .hljs-important{color:#ff7700;font-weight:bold}.hljs-rule .hljs-keyword{color:#c5af75}.hljs-annotation,.apache .hljs-sqbracket,.nginx .hljs-built_in{color:#9b859d}.hljs-preprocessor,.hljs-preprocessor *,.hljs-pragma{color:#643820}.tex .hljs-formula{background-color:#eee;font-style:italic}.diff .hljs-header,.hljs-chunk{color:#808080;font-weight:bold}.diff .hljs-change{background-color:#bccff9}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-comment .hljs-doctag{font-weight:bold}.method .hljs-id{color:#000}</style><style>div.title { padding-top: 40px; } div.afterTitles { height: 15px; }</style><meta charset="utf-8">
<link rel="stylesheet" href="../css/style.css">

<span class="md"><p><title>Day 5. Windows Graphics Review</title><div class="title"> Day 5. Windows Graphics Review </div>

<div class="afterTitles"></div>
<em class="underscore">Video Length (includig Q&A): <a href="https://hero.handmade.network/episode/code/day005/">2h07</a></em>

</p><p>

Welcome to &ldquo;Handmade Hero Notes&rdquo;, the book where we follow the footsteps of <a href="https://handmadehero.org/">Handmade Hero</a> in making the complete game from scratch, with no external libraries. If you'd like to follow along, preorder the game on <a href="https://handmadehero.org/">handmadehero.org</a>, and you will receive access to the GitHub repository, containing complete source code (tagged day-by-day) as well as a variety of other useful resources.

</p><p>

In the past four chapters, a tremendous amount of work was done. If you have followed along, you will have you very own animated graphics on the screen in Windows that you wrote entirely yourself. So today we'll be focusing on cleaning up, explaining some things we've left behind, and going to some related tangents. Also we'll walk through our whole program, reviewing what's going on, and fixing and commenting where necessary.

</p><p>

If you review your code file, <code>win32_handmade.cpp</code>, you will notice that there's not a lot of code here, and what's in there is already pretty straightforward. You might have been intimidated by the prospect of writing everything from scratch, that it would be a huge, huge <em class="underscore">huge</em> amount of work. But it's not, there's very little code here. 

</p><p>

One thing that really needs to be addressed today are all those global variables that are sitting on top of our code. But we'll get to there in due time.

</p>
<div class="longTOC">
    <p align="center">
        <span align="left"><a href="day4.html">Day 4</a></span>
        <a href="../index.html"><img src = "../media/logo.png"></a>
        <span align="right"><a href="day6.html">Day 6</a></span>
    </p><p><a href="#" class="tocTop">(Top)</a><br/>
<a href="#revisitwndclassstyle" class="level1"><span class="tocNumber">1&nbsp; </span>Revisit <code>WNDCLASS</code> style</a><br/>
&nbsp;&nbsp;<a href="#revisitwndclassstyle/cs_owndc" class="level2"><span class="tocNumber">1.1&nbsp; </span>CS_OWNDC</a><br/>
&nbsp;&nbsp;<a href="#revisitwndclassstyle/cs_hrderaw/cs_vredraw" class="level2"><span class="tocNumber">1.2&nbsp; </span>CS_HRDERAW / CS_VREDRAW</a><br/>
<a href="#revisitwin32updatewindowparameters" class="level1"><span class="tocNumber">2&nbsp; </span>Revisit <code>Win32UpdateWindow</code> Parameters</a><br/>
<a href="#revisittheglobalvariables" class="level1"><span class="tocNumber">3&nbsp; </span>Revisit the Global Variables</a><br/>
&nbsp;&nbsp;<a href="#revisittheglobalvariables/bundlebitmapglobalstogether" class="level2"><span class="tocNumber">3.1&nbsp; </span>Bundle Bitmap Globals Together</a><br/>
&nbsp;&nbsp;<a href="#revisittheglobalvariables/updatebufferfunctiondefinitions" class="level2"><span class="tocNumber">3.2&nbsp; </span>Update Buffer Function Definitions</a><br/>
&nbsp;&nbsp;<a href="#revisittheglobalvariables/updatebufferfunctioncalls" class="level2"><span class="tocNumber">3.3&nbsp; </span>Update Buffer Function Calls</a><br/>
<a href="#stack" class="level1"><span class="tocNumber">4&nbsp; </span>Stack</a><br/>
&nbsp;&nbsp;<a href="#stack/deepdiveintothestack" class="level2"><span class="tocNumber">4.1&nbsp; </span>Deep Dive Into the Stack</a><br/>
&nbsp;&nbsp;<a href="#stack/overflowingthestack" class="level2"><span class="tocNumber">4.2&nbsp; </span>Overflowing the Stack</a><br/>
<a href="#extractclientrectcalculations" class="level1"><span class="tocNumber">5&nbsp; </span>Extract <code>ClientRect</code> Calculations</a><br/>
&nbsp;&nbsp;<a href="#extractclientrectcalculations/createwindowdimension" class="level2"><span class="tocNumber">5.1&nbsp; </span>Create Window Dimension</a><br/>
&nbsp;&nbsp;<a href="#extractclientrectcalculations/makeuseofwin32getwindowdimension" class="level2"><span class="tocNumber">5.2&nbsp; </span>Make Use of <code>Win32GetWindowDimension</code></a><br/>
<a href="#settingafixedsizeforbackbuffer" class="level1"><span class="tocNumber">6&nbsp; </span>Setting a Fixed Size for Backbuffer</a><br/>
<a href="#fullprogramstep-through" class="level1"><span class="tocNumber">7&nbsp; </span>Full Program Step-through</a><br/>
<a href="#recap" class="level1"><span class="tocNumber">8&nbsp; </span>Recap</a><br/>
<a href="#exercises" class="level1"><span class="tocNumber">9&nbsp; </span>Exercises</a><br/>
&nbsp;&nbsp;<a href="#exercises/learnmoreaboutrefactoring" class="level2"><span class="tocNumber">9.1&nbsp; </span>Learn More About Refactoring</a><br/>
&nbsp;&nbsp;<a href="#exercises/rewriteyourprogram" class="level2"><span class="tocNumber">9.2&nbsp; </span>Rewrite your Program</a><br/>
<a href="#programmingbasics" class="level1"><span class="tocNumber">10&nbsp; </span>Programming Basics</a><br/>
&nbsp;&nbsp;<a href="#programmingbasics/pointeraliasing" class="level2"><span class="tocNumber">10.1&nbsp; </span>Pointer Aliasing</a><br/>
&nbsp;&nbsp;<a href="#programmingbasics/accessviolations" class="level2"><span class="tocNumber">10.2&nbsp; </span>Access Violations</a><br/>
<a href="#sideconsiderations" class="level1"><span class="tocNumber">11&nbsp; </span>Side Considerations</a><br/>
&nbsp;&nbsp;<a href="#sideconsiderations/variableinitialization" class="level2"><span class="tocNumber">11.1&nbsp; </span>Variable Initialization</a><br/>
&nbsp;&nbsp;<a href="#sideconsiderations/passingparameterstothefunctions" class="level2"><span class="tocNumber">11.2&nbsp; </span>Passing Parameters to the Functions</a><br/>
&nbsp;&nbsp;<a href="#sideconsiderations/aboutconventions" class="level2"><span class="tocNumber">11.3&nbsp; </span>About Conventions</a><br/>
&nbsp;&nbsp;<a href="#sideconsiderations/aboutconstkeyword" class="level2"><span class="tocNumber">11.4&nbsp; </span>About <code>const</code> Keyword</a><br/>
<a href="#navigation" class="level1"><span class="tocNumber">12&nbsp; </span>Navigation</a><br/>
</p></div><a class="target" name="revisitwndclassstyle">&nbsp;</a><a class="target" name="revisitwndclassstyle">&nbsp;</a><a class="target" name="toc1">&nbsp;</a><h1>Revisit <code>WNDCLASS</code> style</h1>
<p>


The first thing we're going to look at is the <code>style</code> of our Window Class. If you remember, from <a href="day2.html">Day 2</a>, we have set three flags as our style: <code>CS_HREDRAW</code>, <code>CS_VREDRAW</code> and <code>CS_OWNDC</code>. You can find the description of all of the window class flags available in the <a href="https://docs.microsoft.com/en-us/windows/win32/winmsg/window-class-styles">Window Class Styles</a> guide. 

</p>
<a class="target" name="cs_owndc">&nbsp;</a><a class="target" name="revisitwndclassstyle/cs_owndc">&nbsp;</a><a class="target" name="toc1.1">&nbsp;</a><h2>CS_OWNDC</h2>
<p>


<code>CS_OWNDC</code> allocates a device contest for every window. As of right now, we make use of a device context at every frame update, and a of a special one when <code>WM_PAINT</code> message is processed. However, as we use it now, we can simply grab and use any available DC Windows would give us. We don't really need it to keep track of the various handles, brushes, etc.

</p><p>

So we have two options: either to remove this flag completely or to get a handle exclusively for our usage. The second option would allow only asking for it once, once we get our window, which in turn would allow us to stop asking and releasing a device context every loop. 

</p><p>

Getting and releasing dc every frame will work fine in both cases, so you don't <em class="underscore">need</em> this flag. The difference is that, without <code>CS_OWNDC</code>, the device context will be created/initialized on every <code>GetDC</code> call. With the flag it will be kept around after <code>ReleaseDC</code> for next <code>GetDC</code> call, in a kind of pool reserved for our window. As a result, you will actually get the exact same HDC value on every <code>GetDC</code> call.

</p><p>

Let's go with the second option and leave <code>CS_OWNDC</code>; we can always change in case. We'll also leave a comment for posterity.

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">if</span> (Window)</span>
<span class="line">{</span><div class=" add"><span class="line">    <span class="hljs-comment">// NOTE(casey): Since we specified CS_OWNDC, we can just</span></span>
<span class="line">    <span class="hljs-comment">// get one device context and use it forever because we</span></span>
<span class="line">    <span class="hljs-comment">// are not sharing it with anyone.</span></span>
<span class="line">    HDC DeviceContext = GetDC(Window);</span></div><span class="line">    <span class="hljs-comment">// ...     </span></span>
<span class="line">    <span class="hljs-keyword">while</span> (Running)</span>
<span class="line">    {</span><div class=" delete"><span class="line">        HDC DeviceContext = GetDC(Window);</span></div><span class="line">        <span class="hljs-comment">// ... </span></span><div class=" delete"><span class="line">        ReleaseDC(Window, DeviceContext);</span></div><div class=" C++ "><span class="line">    }</span>
<span class="line">}</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;1:</b> <file>[win32_handmade.cpp > WinMain]</file> Getting a hold off a single device context</div></center>
<p>




<div class="admonition ">If you implemented a RAII approach in the previous chapter, this would mean either dismantling your solution or removing the destructor. As we said before, we don't need to do the clean up after we exit our program since Windows will do it for us.</div>

</p>
<a class="target" name="cs_hrderaw/cs_vredraw">&nbsp;</a><a class="target" name="revisitwndclassstyle/cs_hrderaw/cs_vredraw">&nbsp;</a><a class="target" name="toc1.2">&nbsp;</a><h2>CS_HREDRAW / CS_VREDRAW</h2>
<p>


For what it might concern <code>CS_HREDRAW</code> and <code>CS_VREDRAW</code>, we can confirm their usefulness. These options come into play when resizing the window (<b>H</b>orizontally or <b>V</b>ertically), and force the <em class="underscore">whole</em> window to be repainted right away, and not just the chunks we resize. You can easily test it if you disable it (comment out or delete the line altogether), recompile, run, and try to resize the window. If you re-enable these style options you'll notice that the whole window is being blacked out as soon as you start resizing it.

</p><p>

<center><div class="image" style=""><a href="../media/day5/redraw.png" target="_blank"><img class="markdeep" src="../media/day5/redraw.png" /></a><center><span class="imagecaption"><a class="target" name="figure_x">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;1:</b> <code>VREDRAW | HREDRAW</code> disabled vs. enabled, after some resizing from the lower right corner.</span></center></div></center>

</p>
<a class="target" name="revisitwin32updatewindowparameters">&nbsp;</a><a class="target" name="revisitwin32updatewindowparameters">&nbsp;</a><a class="target" name="toc2">&nbsp;</a><h1>Revisit <code>Win32UpdateWindow</code> Parameters</h1>
<p>


Let's fast forward a bit to <a href="day4.html">day 4</a> where we decided to pass our <code>ClientRect</code> as a pointer. Now, it's true that <code>RECT</code> is a structure, but it's a rather small one, and stack savings are minimal. But what's more, typically nowadays you want to avoid passing pointers to functions.

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32UpdateWindow</span><span class="hljs-params">(HDC DeviceContext, RECT *ClientRect)</span></span></span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;2:</b> <file>[win32_handmade.cpp]</file> <code>Win32UpdateWindow</code> function signature</div></center>
<p>


If you pass the structure to a function by value (i.e. <code>RECT ClientRect</code> instead of <code>RECT *ClientRect</code>), compiler can make several assumptions: 

</p><p>

<ul>
<li class="asterisk">No one else is going to touch (modify) it outside of the function.
</li>
<li class="asterisk">It's a private copy for the use of the function.
</li>
<li class="asterisk">There's no possibility for <em class="underscore">aliasing</em>.</li></ul>

</p><p>

<div class="admonition ">We will talk about the stack in section  <a href="#toc4">4</a>. Learn more about pointer aliasing in subsection  <a href="#toc10.1">10.1</a>.</div>

</p><p>

There are many ways of preventing pointer aliasing but the easiest way is to just not use any pointers. One of the things you notice about <code>Win32UpdateWindow</code> is that it is <em class="underscore">small</em>. It's a classic candidate to be <em class="underscore">inlined</em> (literally copied its code in the place from which it was called, instead of defining the function in a separate place), and if the compiler will know that the <code>ClientRect</code> stays the same it will have an easier time deciding to inline the function. 

</p><p>

Now why isn't the compiler &ldquo;smart enough&rdquo; to figure out that the <code>ClientRect</code> stays the same is a different story. Compiling process is complicated, and the compiler might not see the same thing we see. The code that goes through multiple transformations comes out from the other side quite different from when it came in. 

</p><p>

Of course, in this case it's not a performance-critical thing to do in this case, but let's go ahead and change the signature for <code>Win32UpdateWindow</code> to take <code>ClientRect</code> by value: 

</p><pre class="listing tilde"><code><span class="line">internal <span class="hljs-keyword">void</span></span><div class=" edit"><span class="line">Win32UpdateWindow(HDC DeviceContext, RECT ClientRect)</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;3:</b> <file>[win32_handmade.cpp]</file> Updating <code>Win32UpdateWindow</code> function signature</div></center>
<p>


Now, if you try to compile now you can use the compiler errors to guide you through the changes to do: 

</p><p>

<ol start=1>
<li class="number">Inside <code>Win32UpdateWindow</code> Replace the <code>-&gt;</code> operator accessing the <code>ClientRect</code> members with the <code>.</code> operator:</li></ol>

</p><pre class="listing tilde"><code><div class=" edit"><span class="line"><span class="hljs-keyword">int</span> WindowWidth = ClientRect.right - ClientRect.left;</span>
<span class="line"><span class="hljs-keyword">int</span> WindowHeight = ClientRect.bottom - ClientRect.top;</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;4:</b> <file>[win32_handmade.cpp > Win32UpdateWindow]</file></div></center>
<p>



<ol start=2>
<li class="number">Remove the <code>&amp;</code> operator in the <code>WinMain</code> and <code>Win32MainWindowCallback</code>.</li></ol>

</p><pre class="listing tilde"><code><div class=" edit"><span class="line">Win32UpdateWindow(DeviceContext, ClientRect);</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;5:</b> <file>[win32_handmade.cpp > WinMain; Win32MainWindowCallback]</file> Updating <code>Win32UpdateWindow</code> calls</div></center>

<a class="target" name="revisittheglobalvariables">&nbsp;</a><a class="target" name="revisittheglobalvariables">&nbsp;</a><a class="target" name="toc3">&nbsp;</a><h1>Revisit the Global Variables</h1>
<p>


Now, back to our global variables. 

</p><pre class="listing tilde"><code><span class="line">global_variable <span class="hljs-keyword">bool</span> Running;</span>
<span class="line">global_variable BITMAPINFO BitmapInfo;</span>
<span class="line">global_variable <span class="hljs-keyword">void</span> *BitmapMemory;</span>
<span class="line">global_variable <span class="hljs-keyword">int</span> BitmapWidth;</span>
<span class="line">global_variable <span class="hljs-keyword">int</span> BitmapHeight;</span>
<span class="line">global_variable <span class="hljs-keyword">int</span> BytesPerPixel;</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;6:</b> <file>[win32_handmade.cpp]</file> Our current globals</div></center>
<p>


As you can see, by now we have quite a few of them. As the globals grow, it might become confusing who can access each variable. A neat way to check would be to simply add a character at the end of the name and try to compile: you will quickly see the errors where these variables are used.

</p><p>

An edit
</p><pre class="listing tilde"><code><div class=" edit"><span class="line">global_variable <span class="hljs-keyword">int</span> BytesPerPixel_;</span></div></code></pre><p>
results in
</p><pre class="listing tilde"><code><span class="line">win32_handmade.cpp</span>
<span class="line">W:handmade\code\win32_handmade.cpp(29): error C2065: 'BytesPerPixel': undeclared identifier</span>
<span class="line">W:handmade\code\win32_handmade.cpp(73): error C2065: 'BytesPerPixel': undeclared identifier</span>
<span class="line">W:handmade\code\win32_handmade.cpp(74): error C2065: 'BytesPerPixel': undeclared identifier</span></code></pre><center><div class="listingcaption tilde"><file>[build output]</file> Detecting where <code>BytesPerPixel</code> is used.</div></center>
<p>


However, our program is small enough that we can go ahead directly and bundle most of these variables up into something that a bit more concise. It's not for performance: this way the things are organized in a cleaner and a more manageable way. This one anyone who is looking at the code can see exactly what has to happen for these bitmaps to be created. 

</p>
<a class="target" name="bundlebitmapglobalstogether">&nbsp;</a><a class="target" name="revisittheglobalvariables/bundlebitmapglobalstogether">&nbsp;</a><a class="target" name="toc3.1">&nbsp;</a><h2>Bundle Bitmap Globals Together</h2>
<p>


Now, <code>Running</code> aside all our globals refer to our bitmap. It's almost as if they were begging to be bundled together. So let's create a struct and do just that. Thus we'll be able to pass this structure to anyone who needs to do something with our <em class="underscore">offscreen buffer</em>.

</p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">win32_offscreen_buffer</span></span>
<span class="line">{</span></span></div><div class=" edit"><span class="line">    BITMAPINFO BitmapInfo;</span>
<span class="line">    <span class="hljs-keyword">void</span> *BitmapMemory;</span>
<span class="line">    <span class="hljs-keyword">int</span> BitmapWidth;</span>
<span class="line">    <span class="hljs-keyword">int</span> BitmapHeight;</span>
<span class="line">    <span class="hljs-keyword">int</span> BytesPerPixel;</span></div><div class=" add"><span class="line">};</span></div><span class="line">global_variable <span class="hljs-keyword">bool</span> Running;</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;7:</b> <file>[win32_handmade.cpp]</file> Defining a struct for our offscreen buffer.</div></center>
<p>


This way we know that we need: 

</p><p>

<ul>
<li class="asterisk">A <code>BITMAPINFO</code> to describe our bitmap
</li>
<li class="asterisk">A pointer to the bits of the bitmap
</li>
<li class="asterisk">We need a width and a height, as well as those bytes per pixel.</li></ul>

</p><p>

We can go ahead and shorten these variables' names since we know they will all belong to a bitmap:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">win32_offscreen_buffer</span></span>
<span class="line">{</span></span><div class=" edit"><span class="line">    BITMAPINFO Info;</span>
<span class="line">    <span class="hljs-keyword">void</span> *Memory;</span>
<span class="line">    <span class="hljs-keyword">int</span> Width;</span>
<span class="line">    <span class="hljs-keyword">int</span> Height;</span></div><span class="line">    <span class="hljs-keyword">int</span> BytesPerPixel;</span>
<span class="line">};</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;8:</b> <file>[win32_handmade.cpp]</file> Shortening the variables names.</div></center>
<p>

Now we don't need most of the globals any more. Instead, we can introduce a single one called, let's say, <code>GlobalBackbuffer</code>:

</p><pre class="listing tilde"><code><span class="line">global_variable <span class="hljs-keyword">bool</span> Running;</span><div class=" delete"><span class="line">global_variable BITMAPINFO BitmapInfo;</span>
<span class="line">global_variable <span class="hljs-keyword">void</span> *BitmapMemory;</span>
<span class="line">global_variable <span class="hljs-keyword">int</span> BitmapWidth;</span>
<span class="line">global_variable <span class="hljs-keyword">int</span> BitmapHeight;</span>
<span class="line">global_variable <span class="hljs-keyword">int</span> BytesPerPixel;</span></div><div class=" add"><span class="line">global_variable win32_offscreen_buffer GlobalBackbuffer;</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;9:</b> <file>[win32_handmade.cpp]</file> Replacing buffer-related globals.</div></center>
<p>

Last thing that we can do is to comment on the convention we're using for our buffer. This might come handy if you ever forget it: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">win32_offscreen_buffer</span></span>
<span class="line">{</span></span><div class=" edit"><span class="line">    <span class="hljs-comment">// NOTE(casey): Pixels are always 32-bits wide, </span></span>
<span class="line">    <span class="hljs-comment">// Memory Order  0x BB GG RR xx</span></span>
<span class="line">    <span class="hljs-comment">// Little Endian 0x xx RR GG BB</span></span></div><span class="line">    BITMAPINFO Info;</span>
<span class="line">    <span class="hljs-keyword">void</span> *Memory;</span>
<span class="line">    <span class="hljs-keyword">int</span> Width;</span>
<span class="line">    <span class="hljs-keyword">int</span> Height;</span>
<span class="line">    <span class="hljs-keyword">int</span> BytesPerPixel;</span>
<span class="line">};</span></code></pre>
<a class="target" name="updatebufferfunctiondefinitions">&nbsp;</a><a class="target" name="revisittheglobalvariables/updatebufferfunctiondefinitions">&nbsp;</a><a class="target" name="toc3.2">&nbsp;</a><h2>Update Buffer Function Definitions</h2>
<p>


If we try to compile now, we will be greeted with with a couple dozen errors. We'll go through each error one by one and implement the changes. 

</p><p>

We will put the &ldquo;main&rdquo; thing that the function has to take account of (in this case, the buffer) at the very beginning of the parameter list.

</p><p>

<ul>
<li class="asterisk"><code>RenderWeirdGradient</code>: needs the structure to read Width and Height, as well as to read the Memory pointer (to write to the pixels).
</li>
<li class="asterisk"><code>Win32ResizeDIBSection</code>: needs the structure to actually fill it out. Now here we have two options:
<ul>
    <li class="asterisk">We pass the structure to be filled out.
</li>
    <li class="asterisk">We can initialize the structure inside the function and <em class="underscore">return</em> it. 
</li>
    <li class="asterisk">Both methods have their advantages and disadvantages. Let's go with the first one because we still need the <code>win32_offscreen_buffer</code> to be passed by value for an eventual memory release. This results in the function being a bit error-prone, and it's not a performance-sensitive place of our code. 
</li></ul>
<li class="asterisk"><code>Win32UpdateWindow</code>: While we're at it, let's rename the function to something more concrete, i.e. <code>Win32DisplayBufferInWindow</code>.</li></ul>

</p><p>

With this chage, we're levelling up our capabilities, as well! Before we could only read/write from the globals, but now the functions can use whichever buffer they receive. So there you have another advantage to pull values from the globals: not only it makes things more clear but also more flexible.

</p><pre class="listing tilde"><code><span class="line">internal <span class="hljs-keyword">void</span></span><div class=" edit"><span class="line">RenderWeirdGradient(win32_offscreen_buffer *Buffer, <span class="hljs-keyword">int</span> XOffset, <span class="hljs-keyword">int</span> YOffset)</span></div><span class="line">{</span><div class=" edit"><span class="line">    <span class="hljs-keyword">int</span> Pitch = Buffer-&gt;Width * Buffer-&gt;BytesPerPixel;</span>
<span class="line">    u8 *Row = (u8 *)Buffer-&gt;Memory;</span></div><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> Y = <span class="hljs-number">0</span>;</span><div class=" edit"><span class="line">         Y &lt; Buffer-&gt;Height;</span></div><span class="line">         ++Y)</span>
<span class="line">    {</span>
<span class="line">        u8 *Pixel = (u8 *)Row;</span>
<span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> X = <span class="hljs-number">0</span>;</span><div class=" edit"><span class="line">            X &lt; Buffer-&gt;Width;</span></div><span class="line">            ++X)</span><span class="line">        {</span>
<span class="line">            <span class="hljs-comment">//...</span></span>
<span class="line">        }</span>
<span class="line">        Row += Pitch;</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">internal <span class="hljs-keyword">void</span></span><div class=" edit"><span class="line">Win32ResizeDIBSection(win32_offscreen_buffer *Buffer, <span class="hljs-keyword">int</span> Width, <span class="hljs-keyword">int</span> Height)</span></div><span class="line">{</span><div class=" edit"><span class="line">    <span class="hljs-keyword">if</span>(Buffer-&gt;Memory)</span></div><span class="line">    {</span><div class=" edit"><span class="line">        VirtualFree(Buffer-&gt;Memory, <span class="hljs-number">0</span>, MEM_RELEASE);</span></div><span class="line">    }</span><div class=" edit"><span class="line">    Buffer-&gt;Width = Width;</span>
<span class="line">    Buffer-&gt;Height = Height;</span>
<span class="line">    Buffer-&gt;BytesPerPixel = <span class="hljs-number">4</span>;</span>
<span class="line">    </span>
<span class="line">    Buffer-&gt;Info.bmiHeader.biSize = <span class="hljs-keyword">sizeof</span>(Buffer-&gt;Info.bmiHeader);</span>
<span class="line">    Buffer-&gt;Info.bmiHeader.biWidth = Buffer-&gt;Width;</span>
<span class="line">    Buffer-&gt;Info.bmiHeader.biHeight = -Buffer-&gt;Height; <span class="hljs-comment">// negative value: top-down</span></span>
<span class="line">    Buffer-&gt;Info.bmiHeader.biPlanes = <span class="hljs-number">1</span>;</span>
<span class="line">    Buffer-&gt;Info.bmiHeader.biBitCount = <span class="hljs-number">32</span>;</span>
<span class="line">    Buffer-&gt;Info.bmiHeader.biCompression = BI_RGB;</span>
<span class="line">    </span>
<span class="line">    <span class="hljs-keyword">int</span> BitmapMemorySize = Buffer-&gt;BytesPerPixel * Buffer-&gt;Width * Buffer-&gt;Height;</span>
<span class="line">    </span>
<span class="line">    Buffer-&gt;Memory = VirtualAlloc(<span class="hljs-number">0</span>, BitmapMemorySize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span></div><span class="line">}</span>
<span class="line"></span>
<span class="line">internal <span class="hljs-keyword">void</span></span><div class=" edit"><span class="line">Win32DisplayBufferInWindow(win32_offscreen_buffer *Buffer, </span>
<span class="line">                           HDC DeviceContext, RECT ClientRect)</span></div><span class="line">{</span>
<span class="line">    <span class="hljs-keyword">int</span> WindowWidth = ClientRect.right - ClientRect.left;</span>
<span class="line">    <span class="hljs-keyword">int</span> WindowHeight = ClientRect.bottom - ClientRect.top;</span>
<span class="line">    </span>
<span class="line">    StretchDIBits(DeviceContext,</span>
<span class="line">                  <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, WindowWidth, WindowHeight,</span><div class=" edit"><span class="line">                  <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, Buffer-&gt;Width, Buffer-&gt;Height,</span>
<span class="line">                  Buffer-&gt;Memory,</span>
<span class="line">                  &amp;Buffer-&gt;Info,</span></div><span class="line">                  DIB_RGB_COLORS, SRCCOPY);</span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;9:</b> <file>[win32_handmade.cpp]</file> Edits to the functions.</div></center>
<p>


Now, you'll notice that we use the <code>Pitch</code> every frame, so we might want to decide to also make it part of the buffer and initialize the pitch with everything else. Make sure to place the <code>Pitch</code> intialization after the <code>Width</code>, <code>Height</code> and <code>BytesPerPixel</code> since it uses these!

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">win32_offscreen_buffer</span></span>
<span class="line">{</span></span>
<span class="line">    BITMAPINFO Info;</span>
<span class="line">    <span class="hljs-keyword">void</span> *Memory;</span>
<span class="line">    <span class="hljs-keyword">int</span> Width;</span>
<span class="line">    <span class="hljs-keyword">int</span> Height;</span><div class=" add"><span class="line">    <span class="hljs-keyword">int</span> Pitch;</span></div><span class="line">    <span class="hljs-keyword">int</span> BytesPerPixel;</span>
<span class="line">};</span>
<span class="line"></span>
<span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">RenderWeirdGradient</span><span class="hljs-params">(win32_offscreen_buffer *Buffer, <span class="hljs-keyword">int</span> XOffset, <span class="hljs-keyword">int</span> YOffset)</span></span>
<span class="line"></span>{</span><div class=" delete"><span class="line">    <span class="hljs-keyword">int</span> Pitch = Buffer-&gt;Width * Buffer-&gt;BytesPerPixel;</span></div><span class="line">    u8 *Row = (u8 *)Buffer-&gt;Memory;</span>
<span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> Y = <span class="hljs-number">0</span>;</span>
<span class="line">         Y &lt; Buffer-&gt;Height;</span>
<span class="line">         ++Y)</span>
<span class="line">    {</span><div class=" edit"><span class="line">        Row += Buffer-&gt;Pitch;</span></div><span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32ResizeDIBSection</span><span class="hljs-params">(win32_offscreen_buffer *Buffer, <span class="hljs-keyword">int</span> Width, <span class="hljs-keyword">int</span> Height)</span></span>
<span class="line"></span>{</span>
<span class="line">    <span class="hljs-comment">//...</span></span>
<span class="line">    Buffer-&gt;Width = Width;</span>
<span class="line">    Buffer-&gt;Height = Height;</span>
<span class="line">    Buffer-&gt;BytesPerPixel = <span class="hljs-number">4</span>;</span>
<span class="line"></span><div class=" add"><span class="line">    Buffer-&gt;Pitch = Buffer-&gt;Width * Buffer-&gt;BytesPerPixel;</span></div><span class="line">    </span>
<span class="line">    <span class="hljs-comment">//...</span></span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;10:</b> <file>[win32_handmade.cpp]</file> Updating the changes.</div></center>

<a class="target" name="updatebufferfunctioncalls">&nbsp;</a><a class="target" name="revisittheglobalvariables/updatebufferfunctioncalls">&nbsp;</a><a class="target" name="toc3.3">&nbsp;</a><h2>Update Buffer Function Calls</h2>
<p>


Now let's also look at the calls to these functions. We call them from our <code>Win32MainWindowCallback</code> and <code>WinMain</code>. 

</p><p>

Now, because these functions are called by Windows independently, the simplest thing for now would be to return one global variable holding our back buffer. We will then use it to pass it where it's currently required: 

</p><p>

<ul>
<li class="asterisk"><code>Win32MainWindowCallback</code>: inside the cases <code>WM_SIZE</code> and <code>WM_PAINT</code>.
</li>
<li class="asterisk"><code>WinMain</code>: inside our loop.</li></ul>

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">LRESULT CALLBACK</span>
<span class="line"><span class="hljs-title">Win32MainWindowCallback</span><span class="hljs-params">(...)</span></span>
<span class="line"></span>{</span>
<span class="line">    <span class="hljs-comment">//...</span></span>
<span class="line">    <span class="hljs-keyword">case</span> WM_SIZE:</span>
<span class="line">    {</span>
<span class="line">        RECT ClientRect;</span>
<span class="line">        GetClientRect(Window, &amp;ClientRect);</span>
<span class="line">        <span class="hljs-keyword">int</span> Width = ClientRect.right - ClientRect.left;</span>
<span class="line">        <span class="hljs-keyword">int</span> Height = ClientRect.bottom - ClientRect.top;</span><div class=" edit"><span class="line">        Win32ResizeDIBSection(&amp;GlobalBackbuffer, Width, Height);</span></div><span class="line">    } <span class="hljs-keyword">break</span>;</span>
<span class="line">    <span class="hljs-comment">//...</span></span>
<span class="line">    <span class="hljs-keyword">case</span> WM_PAINT:</span>
<span class="line">    {</span>
<span class="line">        PAINTSTRUCT Paint;</span>
<span class="line">        HDC DeviceContext = BeginPaint(Window, &amp;Paint);</span>
<span class="line">        </span>
<span class="line">        RECT ClientRect;</span>
<span class="line">        GetClientRect(Window, &amp;ClientRect);</span>
<span class="line">        </span><div class=" edit"><span class="line">        Win32DisplayBufferInWindow(&amp;GlobalBackbuffer, DeviceContext, ClientRect);</span></div><span class="line">        </span>
<span class="line">        EndPaint(Window, &amp;Paint);</span>
<span class="line">    } <span class="hljs-keyword">break</span>;</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> CALLBACK</span>
<span class="line"><span class="hljs-title">WinMain</span><span class="hljs-params">(...)</span></span>
<span class="line"></span>{</span>
<span class="line">    <span class="hljs-comment">//... </span></span><div class=" edit"><span class="line">    RenderWeirdGradient(&amp;GlobalBackbuffer, XOffset, YOffset);</span></div><span class="line">    ++XOffset;</span>
<span class="line">                </span>
<span class="line">    RECT ClientRect;</span>
<span class="line">    GetClientRect(Window, &amp;ClientRect);</span>
<span class="line">    </span><div class=" edit"><span class="line">    Win32DisplayBufferInWindow(&amp;GlobalBackbuffer, DeviceContext, ClientRect);</span></div><div class=" C++ "><span class="line">    //...</span>
<span class="line">}</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;11:</b> <file>[win32_handmade.cpp]</file> Propagating the updates to the calls.</div></center>
<p>


We now should be compilable. If you build and run, you'll notice that no changes have been made on the output of the program. The refactorings serve other purposes: to make the code more efficient, cleaner and overall better. 

</p><p>

At this point we could as well remove our last global buffer-variable, <code>GlobalBackbuffer</code> but it would be a bit of overkill. You don't want to be doing things that you don't need to do, for the sake of doing them. You risk falling into dogma and making busywork.

</p><p>

<div class="admonition ">We explore a potential scenario where you might get an access violation in subsection  <a href="#toc10.2">10.2</a>. Check it out!</div>

</p>
<a class="target" name="stack">&nbsp;</a><a class="target" name="stack">&nbsp;</a><a class="target" name="toc4">&nbsp;</a><h1>Stack</h1>
<p>


The <em class="underscore">stack</em> is a block of memory that is allocated by the system for our program to run. It's different from the <em class="underscore">heap</em> in that it's used directly by the application as the local memory bank for local variables inside functions. The stack grows and shrinks from the &ldquo;top&rdquo; every time we call a new function: 

</p><p>

<ol start=1>
<li class="number">We call into a function. 
</li>
<li class="number">The function puts on the stack the values that are passed to it, as well as it reserves the space necessary for its local variables.
</li>
<li class="number">Once you're out of the function, this space is marked unused and the stack returns to its precedent value.</li></ol>

</p><p>

In other words, when we declare a local variable, like for example <code>WindowClass</code>, <code>offset</code> integers and the <code>Message</code> in <code>WinMain</code>, we're actually growing the stack to make room to store that. So instead of doing an allocation which will sit around for a while (like using <code>VirtualAlloc</code> to get a block of memory), the stack grows and shrinks allowing the memory to be reused. 

</p><p>

Think of it as a watermark: we have an empty pool when the program starts, then the water rises and falls depending on the functions called. In the same way, when you call into a function, it uses space on the stack, stores parameters and local variables. Then, after the function is done, the next functions reuse that space (the stack remains occupied if you call a function from the other).

</p><p>

One thing that makes a stack different from a swimming pool (except, you know, water and bytes) is that direction this stack is growing from. On the <code>x86</code> architecture, the stack grows <em class="underscore">downward</em>, meaning that it starts on a bigger address, and the new allocations receive progressively smaller addresses. 

</p><p>

<svg class="diagram" xmlns="http://www.w3.org/2000/svg" version="1.1" height="208" width="768" style="margin:0 auto 0 auto;"><g transform="translate(8,16 )">
<path d="M 32,0 L 32,144 " style="fill:none;"/>
<path d="M 72,0 L 72,144 " style="fill:none;"/>
<path d="M 168,0 L 168,144 " style="fill:none;"/>
<path d="M 208,0 L 208,144 " style="fill:none;"/>
<path d="M 296,0 L 296,144 " style="fill:none;"/>
<path d="M 336,0 L 336,144 " style="fill:none;"/>
<path d="M 424,0 L 424,144 " style="fill:none;"/>
<path d="M 464,0 L 464,144 " style="fill:none;"/>
<path d="M 552,0 L 552,144 " style="fill:none;"/>
<path d="M 592,0 L 592,144 " style="fill:none;"/>
<path d="M 680,0 L 680,144 " style="fill:none;"/>
<path d="M 720,0 L 720,144 " style="fill:none;"/>
<path d="M 32,0 L 72,0 " style="fill:none;"/>
<path d="M 168,0 L 208,0 " style="fill:none;"/>
<path d="M 296,0 L 336,0 " style="fill:none;"/>
<path d="M 424,0 L 464,0 " style="fill:none;"/>
<path d="M 552,0 L 592,0 " style="fill:none;"/>
<path d="M 680,0 L 720,0 " style="fill:none;"/>
<path d="M 32,144 L 72,144 " style="fill:none;"/>
<path d="M 168,144 L 208,144 " style="fill:none;"/>
<path d="M 296,144 L 336,144 " style="fill:none;"/>
<path d="M 424,144 L 464,144 " style="fill:none;"/>
<path d="M 552,144 L 592,144 " style="fill:none;"/>
<path d="M 680,144 L 720,144 " style="fill:none;"/>
<rect x="708" y="56" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="708" y="40" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="708" y="24" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="708" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="700" y="56" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="700" y="40" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="700" y="24" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="700" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="692" y="56" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="692" y="40" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="692" y="24" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="692" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="684" y="56" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="684" y="40" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="684" y="24" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="684" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="580" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="572" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="564" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="556" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="452" y="88" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="452" y="72" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="452" y="56" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="452" y="40" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="452" y="24" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="452" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="444" y="88" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="444" y="72" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="444" y="56" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="444" y="40" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="444" y="24" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="444" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="436" y="88" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="436" y="72" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="436" y="56" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="436" y="40" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="436" y="24" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="436" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="428" y="88" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="428" y="72" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="428" y="56" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="428" y="40" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="428" y="24" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="428" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="324" y="104" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="324" y="88" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="324" y="72" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="324" y="56" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="324" y="40" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="324" y="24" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="324" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="316" y="104" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="316" y="88" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="316" y="72" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="316" y="56" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="316" y="40" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="316" y="24" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="316" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="308" y="104" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="308" y="88" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="308" y="72" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="308" y="56" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="308" y="40" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="308" y="24" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="308" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="300" y="104" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="300" y="88" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="300" y="72" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="300" y="56" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="300" y="40" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="300" y="24" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="300" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="196" y="88" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="196" y="72" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="196" y="56" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="196" y="40" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="196" y="24" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="196" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="188" y="88" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="188" y="72" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="188" y="56" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="188" y="40" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="188" y="24" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="188" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="180" y="88" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="180" y="72" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="180" y="56" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="180" y="40" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="180" y="24" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="180" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="172" y="88" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="172" y="72" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="172" y="56" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="172" y="40" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="172" y="24" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="172" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="60" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="52" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="44" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><rect x="36" y="8" width="8" height="16" stroke=none fill="rgb(128,128,128)"/><g transform="translate(0,0)"><text text-anchor="middle" x="24" y="164">P</text><text text-anchor="middle" x="32" y="164">r</text><text text-anchor="middle" x="40" y="164">o</text><text text-anchor="middle" x="48" y="164">g</text><text text-anchor="middle" x="56" y="164">r</text><text text-anchor="middle" x="64" y="164">a</text><text text-anchor="middle" x="72" y="164">m</text><text text-anchor="middle" x="152" y="164">F</text><text text-anchor="middle" x="160" y="164">u</text><text text-anchor="middle" x="168" y="164">n</text><text text-anchor="middle" x="176" y="164">c</text><text text-anchor="middle" x="184" y="164">t</text><text text-anchor="middle" x="192" y="164">i</text><text text-anchor="middle" x="200" y="164">o</text><text text-anchor="middle" x="208" y="164">n</text><text text-anchor="middle" x="224" y="164">A</text><text text-anchor="middle" x="280" y="164">F</text><text text-anchor="middle" x="288" y="164">u</text><text text-anchor="middle" x="296" y="164">n</text><text text-anchor="middle" x="304" y="164">c</text><text text-anchor="middle" x="312" y="164">t</text><text text-anchor="middle" x="320" y="164">i</text><text text-anchor="middle" x="328" y="164">o</text><text text-anchor="middle" x="336" y="164">n</text><text text-anchor="middle" x="352" y="164">B</text><text text-anchor="middle" x="408" y="164">F</text><text text-anchor="middle" x="416" y="164">u</text><text text-anchor="middle" x="424" y="164">n</text><text text-anchor="middle" x="432" y="164">c</text><text text-anchor="middle" x="440" y="164">t</text><text text-anchor="middle" x="448" y="164">i</text><text text-anchor="middle" x="456" y="164">o</text><text text-anchor="middle" x="464" y="164">n</text><text text-anchor="middle" x="480" y="164">B</text><text text-anchor="middle" x="536" y="164">F</text><text text-anchor="middle" x="544" y="164">u</text><text text-anchor="middle" x="552" y="164">n</text><text text-anchor="middle" x="560" y="164">c</text><text text-anchor="middle" x="568" y="164">t</text><text text-anchor="middle" x="576" y="164">i</text><text text-anchor="middle" x="584" y="164">o</text><text text-anchor="middle" x="592" y="164">n</text><text text-anchor="middle" x="608" y="164">A</text><text text-anchor="middle" x="664" y="164">F</text><text text-anchor="middle" x="672" y="164">u</text><text text-anchor="middle" x="680" y="164">n</text><text text-anchor="middle" x="688" y="164">c</text><text text-anchor="middle" x="696" y="164">t</text><text text-anchor="middle" x="704" y="164">i</text><text text-anchor="middle" x="712" y="164">o</text><text text-anchor="middle" x="720" y="164">n</text><text text-anchor="middle" x="736" y="164">C</text><text text-anchor="middle" x="32" y="180">S</text><text text-anchor="middle" x="40" y="180">t</text><text text-anchor="middle" x="48" y="180">a</text><text text-anchor="middle" x="56" y="180">r</text><text text-anchor="middle" x="64" y="180">t</text><text text-anchor="middle" x="168" y="180">C</text><text text-anchor="middle" x="176" y="180">a</text><text text-anchor="middle" x="184" y="180">l</text><text text-anchor="middle" x="192" y="180">l</text><text text-anchor="middle" x="200" y="180">e</text><text text-anchor="middle" x="208" y="180">d</text><text text-anchor="middle" x="296" y="180">C</text><text text-anchor="middle" x="304" y="180">a</text><text text-anchor="middle" x="312" y="180">l</text><text text-anchor="middle" x="320" y="180">l</text><text text-anchor="middle" x="328" y="180">e</text><text text-anchor="middle" x="336" y="180">d</text><text text-anchor="middle" x="416" y="180">R</text><text text-anchor="middle" x="424" y="180">e</text><text text-anchor="middle" x="432" y="180">t</text><text text-anchor="middle" x="440" y="180">u</text><text text-anchor="middle" x="448" y="180">r</text><text text-anchor="middle" x="456" y="180">n</text><text text-anchor="middle" x="464" y="180">e</text><text text-anchor="middle" x="472" y="180">d</text><text text-anchor="middle" x="544" y="180">R</text><text text-anchor="middle" x="552" y="180">e</text><text text-anchor="middle" x="560" y="180">t</text><text text-anchor="middle" x="568" y="180">u</text><text text-anchor="middle" x="576" y="180">r</text><text text-anchor="middle" x="584" y="180">n</text><text text-anchor="middle" x="592" y="180">e</text><text text-anchor="middle" x="600" y="180">d</text><text text-anchor="middle" x="680" y="180">C</text><text text-anchor="middle" x="688" y="180">a</text><text text-anchor="middle" x="696" y="180">l</text><text text-anchor="middle" x="704" y="180">l</text><text text-anchor="middle" x="712" y="180">e</text><text text-anchor="middle" x="720" y="180">d</text></g></g></svg><center><div class="imagecaption"><a class="target" name="figure_diagram">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;2:</b> The Ebb and Flow of the Stack (downwards).</div></center>

</p><p>

<div class="admonition ">There's a third memory location, different from the stack and the heap, which is used to store <em class="underscore">permanent data</em>, such as functions, global variables, etc.</div>

</p>
<a class="target" name="deepdiveintothestack">&nbsp;</a><a class="target" name="stack/deepdiveintothestack">&nbsp;</a><a class="target" name="toc4.1">&nbsp;</a><h2>Deep Dive Into the Stack</h2>
<p>


To really drive the message home, let's start a debug session at the beginning of <code>WinMain</code> and open the <code>Memory</code> window of our debugger. As the address, you can type <code>&amp;WindowClass</code> or get the address of <code>WindowClass</code> in the watch window and type it directly.

</p><p>

<code>Memory</code> window is divided in three sections: The left column shows the address (in hexadecimal) of the first byte in the row, the middle one shows the bytes (in hexadecimal, each pair of numbers represents one byte), and the right one converts the bytes to ASCII characters.

</p><p>

<center><div class="image" style=""><a href="../media/day5/memory.png" target="_blank"><img class="markdeep" src="../media/day5/memory.png" /></a><center><span class="imagecaption"><a class="target" name="figure_x">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;3:</b> Inspecting <code>Memory</code> Window.</span></center></div></center>

</p><p>

<div class="admonition tip">If you click and drag any window title in your debugger, you can reposition the window at your convenience.</div>

</p><p>

You will notice that, even if we didn't allocate any memory for our <code>WindowClass</code>, it's still has an address and memory pages associated with it. These pages are exactly the same as when you call <code>VirtualAlloc</code>, with the sole exception of being reserved for the stack. 

</p><p>

At the same way, you can inspect <code>&amp;Instance</code>, <code>&amp;PrevInstance</code>, <code>&amp;CommandLine</code> and <code>&amp;ShowCode</code> and see that these are also located close to the <code>WindowClass</code> bytes and to each other.

</p>
<a class="target" name="overflowingthestack">&nbsp;</a><a class="target" name="stack/overflowingthestack">&nbsp;</a><a class="target" name="toc4.2">&nbsp;</a><h2>Overflowing the Stack</h2>
<p>


<a href="https://docs.microsoft.com/en-us/windows/win32/procthread/thread-stack-size">By default</a> on MSVC, you get 1MB of memory for your stack (you can request more or less by providing the appropriate <a href="https://docs.microsoft.com/en-us/cpp/build/reference/f-set-stack-size">compiler option</a>). Some of it is taken by your globals and the CRT right away, so you get actually even less. You can test it by allocating directly on the stack a huge structure at the beginning of your <code>WinMain</code>: 

</p><pre class="listing tilde"><code><span class="line">u8 HugeBuffer[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>] = {};</span></code></pre><center><div class="listingcaption tilde"><file>[WinMain]</file> Don't try this at home.</div></center>
<p>


If you compile it and run, you'll quickly see the error message <code>Stack Overflow</code>. We asked to put too much stuff to it, and our program crashed. 

</p><p>

<div class="admonition trivia">By <code>Stack Overflow</code> we don't mean a website where programmers exchange questions and answers (that might sometimes be correct).</div>

</p><p>

The bottom line is: memory does not come for free from thin air. Even the stack which is managed by the compiler (and Windows) is limited. Of course, you might not simply allocate such a huge structure on stack, but you might still reach Stack Overflow if you allocate a lot of things on your stack or if you go very deep in your recursive functions. We will touch the latter much later, so you don't need to worry about it just yet. 

</p><p>

<em class="underscore">(Read more: <a href="#variableinitialization">Variable Initialization</a> subsection)</em>

</p>
<a class="target" name="extractclientrectcalculations">&nbsp;</a><a class="target" name="extractclientrectcalculations">&nbsp;</a><a class="target" name="toc5">&nbsp;</a><h1>Extract <code>ClientRect</code> Calculations</h1>
<p>


You'll find by now several places in your code where we calculate the <code>ClientRect</code>, and even further, the <code>ClientRect</code>'s width and height. Let's make a small helper function that would do all these calculations for us so that we don't need to copy-paste the same chunk of code over and over again. 

</p>
<a class="target" name="createwindowdimension">&nbsp;</a><a class="target" name="extractclientrectcalculations/createwindowdimension">&nbsp;</a><a class="target" name="toc5.1">&nbsp;</a><h2>Create Window Dimension</h2>
<p>


First, we'll need to create a struct that we'll be returning from this function. We'll call this struct <code>win32_window_dimension</code> and it will have only a pair of <code>Width</code> and <code>Height</code>:
 
</p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">win32_window_dimension</span></span>
<span class="line">{</span></span>
<span class="line">    <span class="hljs-keyword">int</span> Width;</span>
<span class="line">    <span class="hljs-keyword">int</span> Height;</span>
<span class="line">};</span></div><span class="line"></span>
<span class="line">global_variable <span class="hljs-keyword">bool</span> Running;</span>
<span class="line">global_variable win32_offscreen_buffer GlobalBackbuffer;</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;12:</b> <file>[win32_handmade.cpp]</file> Defining <code>win32_window_dimension</code>.</div></center>
<p>


The code we're optimizing is the following: 

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line">RECT ClientRect;</span>
<span class="line">GetClientRect(Window, &amp;ClientRect);</span>
<span class="line"><span class="hljs-keyword">int</span> Width = ClientRect.right - ClientRect.left;</span>
<span class="line"><span class="hljs-keyword">int</span> Height = ClientRect.bottom - ClientRect.top;</span></div></code></pre><p>

So we can use this code to get our window dimension. We only need a window handle for it: 

</p><pre class="listing tilde"><code><span class="line">global_variable <span class="hljs-keyword">bool</span> Running;</span>
<span class="line">global_variable win32_offscreen_buffer GlobalBackbuffer;</span>
<span class="line"></span><div class=" add"><span class="line"><span class="hljs-function">internal win32_window_dimension</span>
<span class="line"><span class="hljs-title">Win32GetWindowDimension</span><span class="hljs-params">(HWND Window)</span></span>
<span class="line"></span>{</span>
<span class="line">    win32_window_dimension Result; </span>
<span class="line">    </span>
<span class="line">    RECT ClientRect;</span>
<span class="line">    GetClientRect(Window, &amp;ClientRect);    </span>
<span class="line">    Result.Width = ClientRect.right - ClientRect.left;</span>
<span class="line">    Result.Height = ClientRect.bottom - ClientRect.top;</span>
<span class="line">    </span>
<span class="line">    <span class="hljs-keyword">return</span>(Result);</span>
<span class="line">}</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;13:</b> <file>[win32_handmade.cpp]</file> Defining <code>Win32GetWindowDimension</code>.</div></center>

<a class="target" name="makeuseofwin32getwindowdimension">&nbsp;</a><a class="target" name="extractclientrectcalculations/makeuseofwin32getwindowdimension">&nbsp;</a><a class="target" name="toc5.2">&nbsp;</a><h2>Make Use of <code>Win32GetWindowDimension</code></h2>
<p>


We can now go to the places where we asked for <code>ClientRect</code> and replace that code. It's straightforward where we call <code>Win32ResizeDIBSection</code>:

</p><pre class="listing tilde"><code><div class=" delete"><span class="line">RECT ClientRect;</span>
<span class="line">GetClientRect(Window, &amp;ClientRect);</span>
<span class="line"><span class="hljs-keyword">int</span> Width = ClientRect.right - ClientRect.left;</span>
<span class="line"><span class="hljs-keyword">int</span> Height = ClientRect.bottom - ClientRect.top;</span></div><div class=" add"><span class="line">win32_window_dimension Dimension = Win32GetWindowDimension(Window);</span></div><div class=" edit"><span class="line">Win32ResizeDIBSection(&amp;GlobalBackbuffer, Dimension.Width, Dimension.Height);</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;14:</b> <file>[win32_handmade.cpp > Win32MainWindowCallback > WM_SIZE]</file> Start using <code>Win32GetWindowDimension</code>.</div></center>
<p>


However, our call to recently renamed <code>Win32DisplayBufferInWindow</code> is a bit different. We take the Window <code>RECT</code> and <em class="underscore">then</em> calculate the <code>WindowWidth</code> and <code>WindowHeight</code>. That's... really not what we need to do inside this function. We need to pass exactly what a function needs, no more and no less. You can read more about it in Subsection  <a href="#toc11.2">11.2</a>.

</p><p>

With this in mind, let's make our changes: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32DisplayBufferInWindow</span><span class="hljs-params">(win32_offscreen_buffer *Buffer, </span></span></span><div class=" edit"><span class="line">                           HDC DeviceContext, <span class="hljs-keyword">int</span> WindowWidth, <span class="hljs-keyword">int</span> WindowHeight)</span></div><span class="line">{</span><div class=" delete"><span class="line">    <span class="hljs-keyword">int</span> WindowWidth = ClientRect.right - ClientRect.left;</span>
<span class="line">    <span class="hljs-keyword">int</span> WindowHeight = ClientRect.bottom - ClientRect.top;</span></div><div class=" C++ "><span class="line">StretchDIBits(DeviceContext,</span>
<span class="line">                  0, 0, WindowWidth, WindowHeight,</span>
<span class="line">                  0, 0, Buffer-&gt;Width, Buffer-&gt;Height,</span>
<span class="line">                  Buffer-&gt;Memory,</span>
<span class="line">                  &amp;Buffer-&gt;Info,</span>
<span class="line">                  DIB_RGB_COLORS, SRCCOPY);</span>
<span class="line">}</span></div></code></pre><center><div class="listingcaption tilde"><file>[win32_handmade.cpp]</file></div></center>
<pre class="listing tilde"><code><div class=" delete"><span class="line">RECT ClientRect;</span>
<span class="line">GetClientRect(Window, &amp;ClientRect);</span></div><div class=" add"><span class="line">win32_window_dimension Dimension = Win32GetWindowDimension(Window);</span></div><div class=" edit"><span class="line">Win32DisplayBufferInWindow(&amp;GlobalBackbuffer, DeviceContext, Dimension.Width, Dimension.Height);</span></div></code></pre><center><div class="listingcaption tilde"><file>[win32_handmade.cpp > Win32MainWindowCallback > WM_PAINT]</file></div></center>
<pre class="listing tilde"><code><div class=" delete"><span class="line">RECT ClientRect;</span>
<span class="line">GetClientRect(Window, &amp;ClientRect);</span></div><div class=" add"><span class="line">win32_window_dimension Dimension = Win32GetWindowDimension(Window);</span></div><div class=" edit"><span class="line">Win32DisplayBufferInWindow(&amp;GlobalBackbuffer, DeviceContext, Dimension.Width, Dimension.Height);</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;15:</b> <file>[win32_handmade.cpp > WinMain]</file> Propagating <code>Win32GetWindowDimension</code> changes.</div></center>
<p>


This looks a bit messy but it has great benefits. This update makes the code go through exactly the same path as the previous code. It's always good to have the fewest <em class="underscore">code paths</em> as possible if you can avoid having them. It just means that our life will be easier if we need to change this code later (and more likely to find bugs).

</p>
<a class="target" name="settingafixedsizeforbackbuffer">&nbsp;</a><a class="target" name="settingafixedsizeforbackbuffer">&nbsp;</a><a class="target" name="toc6">&nbsp;</a><h1>Setting a Fixed Size for Backbuffer</h1>
<p>


Right now, our bitmap depends on the size of the window. But, since <code>StretchDIBits</code> allows for stretching, let's test it out! We will cut everything out from <code>WM_SIZE</code> and paste it into our <code>WinMain</code>. 

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line"><span class="hljs-keyword">case</span> WM_SIZE:</span>
<span class="line">{</span></div><div class=" delete"><span class="line">    win32_window_dimension Dimension = Win32GetWindowDimension(Window);</span>
<span class="line">    Win32ResizeDIBSection(&amp;GlobalBackbuffer, Dimension.Width, Dimension.Height);</span></div><span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;16:</b> <file>[win32_handmade.cpp > Win32MainWindowCallback > WM_SIZE]</file></div></center>
<pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">if</span> (Window)</span>
<span class="line">{</span><div class=" add"><span class="line">    win32_window_dimension Dimension = Win32GetWindowDimension(Window);</span>
<span class="line">    Win32ResizeDIBSection(&amp;GlobalBackbuffer, Dimension.Width, Dimension.Height);</span></div><span class="line">    <span class="hljs-comment">//... </span></span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;17:</b> <file>[win32_handmade.cpp > WinMain]</file> Bringing over the buffer allocation to WinMain</div></center>
<p>




<div class="admonition note"><div class="admonition-title"> Why do we keep handling messages we don't really handle? </div>

</p><p>

    The concept of &ldquo;handling a message&rdquo; is a bit fuzzy. Sometimes by leaving a message blank ourselves we prevent Windows from doing anything in response to this message.

</p><p>

    In our case, the <code>WM_SIZE</code> message can be left there or removed altogether: there is no default action that Windows takes in <code>DefWindowProc</code>. On the other hand, <code>WM_CLOSE</code> and <code>WM_DESTROY</code> do have a default behaviour that we don't want to invoke (we're also doing our own stuff in there). Same thing with <code>WM_ACTIVATEAPP</code>. 

</p><p>

    In other cases again, like <code>WM_PAINT</code>, you might want to have your own code to do some compulsory work <em class="underscore">or</em> at least invoke <code>DefWindowProc</code>. In case of <code>WM_PAINT</code>, unless you do <code>BeginPaint</code>-<code>EndPaint</code> the &ldquo;dirty&rdquo; region of the window will never be validated. Windows will continue to think the region is dirty and will continue sending <code>WM_PAINT</code> messages. Thus having an empty <code>case WM_PAINT: {} break;</code> would be bad. If you don't want to handle this message, rather delete the case entirely. Windows will clear the client area to zero and consider the region validated.

</p><p>

    If in doubt, check documentation! All the messages have detailed documentation on <a href="https://docs.microsoft.com/en-us/">MSDN</a>.</div>

</p><p>

Furthermore, we can now say that we want a fixed buffer size, for instance 1280&times;720. We won't even need <code>Dimension</code> after that!

</p><p>

if (Window)
{
</p><pre class="listing tilde"><code><div class=" delete"><span class="line">    win32_window_dimension Dimension = Win32GetWindowDimension(Window);</span></div><div class=" edit"><span class="line">    Win32ResizeDIBSection(&amp;GlobalBackbuffer, <span class="hljs-number">1280</span>, <span class="hljs-number">720</span>);</span></div><span class="line">    <span class="hljs-comment">//... </span></span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;18:</b> <file>[win32_handmade.cpp > WinMain]</file> Bringing over the buffer allocation to WinMain.</div></center>
<p>


It's not perfect and, if you resize it significantly, it produces some weird artifacts, but it works. Our <code>WeirdGradient</code> proportionally now always occupies the same amount of space inside the window. 

</p><p>

<div class="admonition tip">If you don't see the weird gradient occupying the whole window, make sure you pass the correct values to <code>StretchDIBits</code>!

</p><pre class="listing tilde"><code><span class="line">StretchDIBits(DeviceContext,</span>
<span class="line">              <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, WindowWidth, WindowHeight,    <span class="hljs-comment">// Destination (where the bitmap will be copied)</span></span>
<span class="line">              <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, Buffer-&gt;Width, Buffer-&gt;Height,  <span class="hljs-comment">// Source (from where the bitmap will be copied)</span></span>
<span class="line">              Buffer-&gt;Memory,</span>
<span class="line">              &amp;Buffer-&gt;Info,</span>
<span class="line">              DIB_RGB_COLORS, SRCCOPY);</span></code></pre><center><div class="listingcaption tilde"><file>[StretchDIBits]</file></div></center></div>

</p><p>

<p>


Of course, you'll notice that now that we have a fixed buffer size, you'll realize that the <em class="underscore">aspect ratio</em> of our image changes depending on its size: The squares of our gradient may be squashed vertically or horizontally, and it would represent any image we'd want to display on screen. This is something that we'll leave for another time. Let's leave a <code>TODO</code> in our <code>Win32DisplayBufferInWindow</code> to remind us of it for another time:

</p><pre class="listing tilde"><code><span class="line">Win32DisplayBufferInWindow(win32_offscreen_buffer *Buffer, </span>
<span class="line">                           HDC DeviceContext, <span class="hljs-keyword">int</span> WindowWidth, <span class="hljs-keyword">int</span> WindowHeight)</span>
<span class="line">{</span>
<span class="line">    <span class="hljs-comment">// TODO(casey): Aspect ratio correction</span></span>
<span class="line">    <span class="hljs-comment">// ...</span></span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;19:</b> <file>[win32_handmade.cpp]</file> Saving some work for later.</div></center>

<a class="target" name="fullprogramstep-through">&nbsp;</a><a class="target" name="fullprogramstep-through">&nbsp;</a><a class="target" name="toc7">&nbsp;</a><h1>Full Program Step-through</h1>
<p>


Today specifically we've made a <em class="underscore">lot</em> of refactoring. Let's go through the code and make sure we understand deeply what it does and how every little thing works.

</p><p>

Open your debugger, hit <code>F11</code> (or set your breakpoint at the beginning of your <code>WinMain</code>) and prepare for the ride. Each numbered step below assumes that you hit <code>F11</code> to move forward one or more times.

</p><p>

<ol start=1>
<li class="number">The first thing that happens in our program happens inside the C Runtime Library. The code that compiler added before ours makes some preparations and calls <code>WinMain</code>. 
<ul>
    <li class="asterisk">We receive <code>Instance</code>, <code>PrevInstance</code>, <code>CommandLine</code> and <code>ShowCode</code> which are allocated on stack for us.
</li></ul>
<li class="number">We pass a pointer to our <code>GlobalBackbuffer</code> (located in our Data memory) and the desired buffer width and height (as constants) to <code>Win32ResizeDIBSection</code>. 
<ol start=1>
    <li class="number">We allow this function to be called as many times as we want to, so the first thing we do is to check if we allocated any memory already. If we did, we'd clear that memory first. 
<ul>
        <li class="asterisk">If you want, you might as well remove this section for now. We're only ever planning to call this function once, and we can always return it later. Leave yourself a reminder!
                    </p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-comment">// NOTE(yakvi): Remember to VirtualFree the memory if we ever</span></span>
<span class="line"><span class="hljs-comment">// call this function more than once on the same buffer!</span></span></div><div class=" delete"><span class="line"><span class="hljs-keyword">if</span>(Buffer-&gt;Memory)</span>
<span class="line">{</span>
<span class="line">    VirtualFree(Buffer-&gt;Memory, <span class="hljs-number">0</span>, MEM_RELEASE);</span>
<span class="line">}</span></div></code></pre><p>
</li></ul>
    <li class="number">Then we fill out various fields that we will need to remember: width, height, bytes per pixel, pitch. 
<ul>
        <li class="asterisk">Our <code>Pitch</code> is the width of the bytes times the number of bytes per pixel, since this is how much we should move to advance to the next row of pixels.
</li></ul>
    <li class="number">After this, we fill out the <code>BITMAPINFO</code> structure. This one will be used by Windows at a later stage to blit the buffer. 
<ul>
        <li class="asterisk">This is a description for Windows of how it's supposed to interpret the memory that we pass to it.
</li>
        <li class="asterisk">If you fill particularly inclined so, you can change <code>biBitCount</code> to be <code>Buffer-&gt;BytesPerPixel * 8</code> instead of a constant <code>32</code>.
</li>
        <li class="asterisk">As for <code>biHeight</code>, it might become confusing to the future you why there's a <code>-</code> there, so let's add a comment to it: 
                    </p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-comment">// NOTE(casey): When the biHeight field is negative, this is the clue </span></span>
<span class="line"><span class="hljs-comment">// to Windows to treat this bitmap as top-down, not bottom-up, meaning</span></span>
<span class="line"><span class="hljs-comment">// that the first bytes of the image are the color for the top left </span></span>
<span class="line"><span class="hljs-comment">// pixel in the bitmap, not the bottom left!</span></span></div><span class="line">Buffer-&gt;Info.bmiHeader.bisize = <span class="hljs-keyword">sizeof</span>(Buffer-&gt;Info.bmiHeader);</span></code></pre><p>
</li></ul>
    <li class="number">We then compute the size and request our chunk of memory. 
<ul>
        <li class="asterisk">We do so by calling Windows function <code>VirtualAlloc</code> that reserves the pages for us to hold the size we calculated.
</li>
        <li class="asterisk">You may ask: why won't we just declare that chunk up there? We could have done that, it's totally valid, but we want to have flexibility to change the size of our bitmap. On the other hand, if we would have put the bitmap as a global, its size should've been known at <em class="underscore">compile</em> time.
</li></ul>
</li></ol>
<li class="number">We initialize and fill out our <code>WindowClass</code>, which is allocated on the stack.
<ol start=1>
    <li class="number">The <code>{}</code> symbol initially clears the structure to zero
</li>
    <li class="number">We fill out the fields allowing the window class to inform Windows of our program.
<ul>
        <li class="asterisk">The instance handle so Windows knows which virtual address space (or which process) to call.
</li>
        <li class="asterisk">A pointer to our callback function so Windows knows which function within that address space to call.
</li>
        <li class="asterisk">This is all important because a pointer <strong class="asterisk">does not uniquely identify memory in the system</strong>, only inside one process. 
</li>
        <li class="asterisk">We also give a random name to our class because we'll then need to pass it to <code>CreateWindowEx</code> call.
</li></ul>
    <li class="number">The window class is then registered with <code>RegisterClass</code> Windows call.
<ul>
        <li class="asterisk">We don't really care about <code>WindowClass</code> structure at that point. Windows will register our class in its own registries and will keep track of it that way. 
</li>
        <li class="asterisk">This is different from other times when you do care about conserving a handle that you passed to Windows, in case other things might use it. 
</li></ul>
</li></ol>
<li class="number">Once we ensure that <code>WindowClass</code> registration completed successfully, we go ahead and create our window calling <code>CreateWindowEx</code>. 
<ul>
    <li class="asterisk">We pass our window the class name so that it can intercept messages directed to our class.
</li>
    <li class="asterisk">We make sure that the window has all the standard properties (<code>WS_OVERLAPPEDWINDOW</code> is a composite set of flags), as well as it's immediately visible. 
</li>
    <li class="asterisk">We also pass our <code>Instance</code> handle to make sure Windows knows who called it.
</li></ul>
<li class="number">If the <code>Window</code> handle returns valid, we assume that we're ready to run. 
</li>
<li class="number">We next request a device context that would allow us to issue draw calls. It's a purely artificial construct by Windows because the device contexts save state of the brushes you might have used. We don't really need all this, but all the drawing should happen through this path. Usually you're supposed to release a DC once you're done with it. However, since we have specified <code>CS_OWNDC</code> we can keep one for the whole duration of our window.
</li>
<li class="number">We enter the main loop by initializing our <code>Running</code> global variable to <code>true</code> and entering the <code>while</code> loop. This loop will remain infinite until <code>Running</code> set to <code>false</code>.
<ul>
    <li class="asterisk">Since it's a global, let's actually prefix it as such. Find each reference to <code>Running</code> in your code and rename it to <code>GlobalRunning</code>. 
            </p><pre class="listing tilde"><code><div class=" edit"><span class="line">global_variable <span class="hljs-keyword">bool</span> GlobalRunning;</span>
<span class="line"><span class="hljs-comment">// we leave search and rename of the variable as the exercise for the reader</span></span></div></code></pre><p>
</li>
    <li class="asterisk">It's a good habit to keep track of our globals by their name so that we don't lose them from our view. Some use the prefix <code>g_</code>, as usual we leave the naming convention to you!
</li></ul>
<li class="number">We reserve some space on stack for our <code>Message</code> and use it to <em class="underscore">peek</em> if there're any messages (using <code>PeekMessageA</code>). If we find any: 
<ol start=1>
    <li class="number">We remove the message from the queue (<code>PM_REMOVE</code>). 
</li>
    <li class="number">We quickly check if the message is <code>WM_QUIT</code>, if so, we set <code>GlobalRunning</code> to <code>false</code>.
</li>
    <li class="number">We then call <code>TranslateMessage</code> to translate a keycode into characters. 
</li>
    <li class="number">We then dispatch the message so that it's intercepted by our <code>Win32MainWindowCallback</code> function.
<ul>
        <li class="asterisk">Remember that Windows doesn't call the callback function only through this pass!
</li></ul>
    <li class="number">We then check for the new messages until we clear the whole queue.
</li></ol>
<li class="number">After we finish processing all the messages, we call <code>RenderWeirdGradient</code>!
<ol start=1>
    <li class="number">We pass it the pointer to our <code>GlobalBackbuffer</code>, and the <code>OffsetX</code> and <code>OffsetY</code> that we initialized earlier.
</li>
    <li class="number"><code>RenderWeirdGradient</code> points at the beginning of our buffer memory.
</li>
    <li class="number">It steps through every row of this buffer. We advance each row by the buffer's <code>Pitch</code>. 
<ul>
        <li class="asterisk"><code>Pitch</code> is in single bytes, so the <code>Row</code> should be a pointer to single bytes as well, otherwise C will do the silent multiplication throwing us way out of our memory boundaries.
</li></ul>
    <li class="number">Inside each step, the function grabs a pointer to the beginning of the row as individual pixels. 
</li>
    <li class="number">We step through each 32 bits in a row. These are our pixels. 
</li>
    <li class="number">We set <code>Blue</code>, <code>Green</code> and <code>Red</code> pixels 
<ul>
        <li class="asterisk"><code>Blue</code> and <code>Green</code> receive the values of <code>X</code> and <code>Y</code>, respectively, with whatever value the offset is. The offset is what creates our animation. 
</li>
        <li class="asterisk">Red we set to <code>0</code>. 
</li>
        <li class="asterisk">Since they are all byte-long, they will <em class="underscore">overflow</em> at 255 and return to <code>0</code>. This is what creates those 256&times;256 block pattern that you see in our gradient: it's those 8 bits wrapping and overflowing every time. 
</li></ul>
    <li class="number">We set our <code>Pixel</code> in a very concise manner. <code>*Pixel++ = Red &lt;&lt; 16 | Green &lt;&lt; 8 | Blue;</code>
<ul>
        <li class="asterisk"><code>*Pixel</code> dereferences the <code>Pixel</code> (writes to whatever value <code>Pixel</code> is pointing to)
</li>
        <li class="asterisk"><code>++</code> is the post-increment operator. It says: "<em class="underscore">After</em> this statement, this value should be incremented by 1. This results in the pointer moving by its size, i.e. 4 bytes (i.e. <code>1 * sizeof(u32)</code>).
</li>
        <li class="asterisk">As the value, we pack <code>Red</code>, <code>Green</code> and <code>Blue</code> components into a single 32-bit value. Since in memory the layout <code>xx RR GG BB</code> looks like <code>BB GG RR xx</code>, we need to <em class="underscore">shift</em> <code>Red</code> by 2 bytes and <code>Green</code> by 1. There is no need to move the <code>Blue</code>. The shifting is done by the <code>&lt;&lt;</code> operator, and it shifts by bits.
</li></ul>
</li></ol>
<li class="number">We then use helper function <code>Win32GetWindowDimension</code> to get the width and height of our window (or client area, to be precise). 
<ol start=1>
    <li class="number">We ask Windows to get us the <code>ClientRect</code> which is the writable region of a window in <em class="underscore">window's space</em>. This means that <code>Left</code> and <code>Top</code> will always be <code>0</code>. 
</li>
    <li class="number">We make <code>GetClientRect</code> to get just that. 
</li>
    <li class="number"><code>Right</code> and <code>Bottom</code> should always return width and height, but we're being extra diligent and making the calculations to get the width and the height. 
</li></ol>
<li class="number">After we're out, we go straight in <code>Win32DisplayBufferInWindow</code> and ask Windows to display our buffer in our client area, by calling <code>StretchDIBits</code>. 
<ul>
    <li class="asterisk"><code>StretchDIBits</code> also stretches the buffer (increasing or decreasing its size as relevant) so that it fits in client area. 
</li>
    <li class="asterisk">We pass it the various parameters including the bitmap info that we filled out earlier, the memory, and a few flags so that the function knows what we want to do with all this. 
</li></ul>
<li class="number">We increment our gradient offset(s).</li></ol>

</p><p>

This is the end of our main loop! This program will run forever until we cancel it. Occasionally it will also hop into our <code>Win32MainWindowCallback</code> to check if there's a message that we want to process.

</p><p>

<ul>
<li class="asterisk">By now we only really process the <code>WM_CLOSE</code> and <code>WM_DESTROY</code> messages which set <code>GlobalRunning</code> to <code>false</code>. 
</li>
<li class="asterisk">We also have our <code>WM_PAINT</code> message. It still displays our buffer in window but remember: by now we're forcing the program to display the buffer each time a <code>GlobalRunning</code> loop runs. We're like a chihuahua on speed trying to blit as fast as possible. But if we, for example, try to resize the window, our update loop stops but we still repaint the window. This is what happens inside the <code>WM_PAINT</code>: we continuosly blit our buffer into newly-sized window. 
<ul>
    <li class="asterisk">You will notice <code>BeginPaint</code> and <code>EndPaint</code> calls. These happen only inside <code>WM_PAINT</code> message. You <em class="underscore">need</em> to call <code>BeginPaint</code> and <code>EndPaint</code>. If you don't, Windows will flood your message queue with <code>WM_PAINT</code> messages. 
</li></ul>
<li class="asterisk">Any time we get a message that we don't handle, we fall into our <code>default</code> case and let Windows to do whatever it thinks the way of treating that message.</li></ul>

</p><p>

And... this is the end of our program (as of today)!

</p><p>

<div class="admonition warning"><div class="admonition-title"> Recompile while running</div>

</p><p>

    You cannot recompile while the program is running! If you try to recompile, you'll get the following message: 
    </p><pre class="listing tilde"><code><span class="line">LINK : fatal error LNK1168: cannot open win32_handmade.exe for writing</span></code></pre><p>
    If you get this message, simply stop debugging and try again. This is a downside of Windows. UNIX-based systems uses a different system which allows the program to be recompiled on the fly.</div>

</p>
<a class="target" name="recap">&nbsp;</a><a class="target" name="recap">&nbsp;</a><a class="target" name="toc8">&nbsp;</a><h1>Recap</h1>
<p>


A long road lies ahead of us, but where we got so far gives us already a lot of freedom. This is where the joy of programming is coming from: by simply diving into the code and tinkering with various values to see where they bring you.

</p><p>

As this program becomes more and more complicated, we will not be offering many guided walkthroughs of the whole program. But it's a good habit to get into, of doing similar walkthroughs after you implement a new code path: go into the debugger, step into each thing, inspect it through <code>Watch</code> window and try to understand if it does what you think it does, commenting in the confusing places, and correcting things that aren't clear.

</p>
<a class="target" name="exercises">&nbsp;</a><a class="target" name="exercises">&nbsp;</a><a class="target" name="toc9">&nbsp;</a><h1>Exercises</h1>

<a class="target" name="learnmoreaboutrefactoring">&nbsp;</a><a class="target" name="exercises/learnmoreaboutrefactoring">&nbsp;</a><a class="target" name="toc9.1">&nbsp;</a><h2>Learn More About Refactoring</h2>
<p>


&ldquo;Refactoring&rdquo; is a relatively new term, but it's definitely not a new concept. Learn more about how it works and see if you can refactor something else in your program!

</p><p>

For instance, since we aren't using <code>BytesPerPixel</code> anywhere but in <code>Win32ResizeDIBSection</code>, you can also remove this variable from the <code>win32_offscreen_buffer</code>.

</p>
<a class="target" name="rewriteyourprogram">&nbsp;</a><a class="target" name="exercises/rewriteyourprogram">&nbsp;</a><a class="target" name="toc9.2">&nbsp;</a><h2>Rewrite your Program</h2>
<p>


We've said it at the beginning of this chapter: it's not a lot of code in this program! 

</p><p>

To prove it, and to make sure you understood everything so far, rename your <code>win32_handmade.cpp</code> file and create a new <code>win32_handmade.cpp</code>. Rewrite your program from scratch. If necessary, peek at this book and, if in dire need, at your renamed file's code. 

</p><p>

If you want an extra challenge, you can also redo the whole project setup from scratch.

</p>
<a class="target" name="programmingbasics">&nbsp;</a><a class="target" name="programmingbasics">&nbsp;</a><a class="target" name="toc10">&nbsp;</a><h1>Programming Basics</h1>

<a class="target" name="pointeraliasing">&nbsp;</a><a class="target" name="programmingbasics/pointeraliasing">&nbsp;</a><a class="target" name="toc10.1">&nbsp;</a><h2>Pointer Aliasing</h2>
<p>


There're many things that are called aliasing. You might be familiar with the aliasing (or even better yet, anti-aliasing) in computer graphics, here though we're talking about something specific to C and C++ languages.

</p><p>

Pointer aliasing happens when two pointers COULD point to the same memory. The compiler doesn't know if a write to one of those pointers might affect a read from the other pointer, so really it doesn't know whether or not to optimize that read.

</p><p>

To give you an example, Let's imagine you have two pointers: a <code>*A</code> and a <code>*B</code> which are pointing to somewhere in memory. These addresses might or might not be the same.

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">int</span> *A = somewhere_in_memory;</span>
<span class="line"><span class="hljs-keyword">int</span> *B = somewhere_in_memory;</span></code></pre><center><div class="listingcaption tilde"><file>[Example]</file> Your example pointers</div></center>
<p>


Let's say that we want to write something to <code>*A</code>. Similarly, you want to read something from <code>B</code>:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">int</span> X = *B;</span>
<span class="line">*A = <span class="hljs-number">5</span>;</span>
<span class="line"><span class="hljs-keyword">int</span> Y = *B;</span></code></pre><center><div class="listingcaption tilde"><file>[Example]</file> Reading and writing to the example pointers</div></center>
<p>


Now, if you take a look at this code it looks pretty obvious what's going on: 

</p><p>

<ol start=1>
<li class="number">We take whatever value <code>*B</code> was pointing to and give it to <code>X</code>.
</li>
<li class="number">We assign <code>5</code> as the new value to whichever address <code>*A</code> was pointing to.
</li>
<li class="number">We then read the value of <code>*B</code> again and give it to <code>Y</code>.</li></ol>

</p><p>

So at the end of this, we're looking at it, and saying: &ldquo;Obviously, <code>X</code> and <code>Y</code> are the same! So of course the compiler should load it once. Compiler should just convert to <code>int Y = X</code> and assign whichever value <code>X</code> was holding.&rdquo; 

</p><p>

Well... unfortunately the compiler cannot do that because we have not given enough information to the compiler to know that <code>*A</code> doesn't point to the same location as <code>*B</code>. So it could be that that assignment to <code>*A</code> overwrote whichever value <code>*B</code> held, and in reality <code>Y == 5</code> (while <code>X == whatever_value_there_was_before_5</code>). There might as well be an <code>A = B</code> somewhere in between the <code>*A</code> and <code>*B</code> initialization and our code snippet.

</p><p>

That said, there optimization modes you can put the compilers in that make it assume specific things about aliasing. Using them is generally not a good idea: it's bugs waiting to happen. Nowadays, compilers assume more and more things about aliasing that might not be true or intended by the programmer. Generally assuming that there is no aliasing is not bad, rather there should be a way for the programmer to mark the pointers that <em class="underscore">don't</em> result in the aliasing. This way is partially provided by the <code>restrict</code> and <code>assume</code> keywords. 

</p><p>

For more information about how a modern compiler approaches optimization, watch <a href="https://www.youtube.com/watch?v=FnGCDLhaxKU">this talk by Chandler Carruth</a>.

</p><p>

<em class="underscore">(back to Section  <a href="#toc2">2</a>)</em>

</p>
<a class="target" name="accessviolations">&nbsp;</a><a class="target" name="programmingbasics/accessviolations">&nbsp;</a><a class="target" name="toc10.2">&nbsp;</a><h2>Access Violations</h2>
<p>


Let's say you failed to initalize the memory properly. For instance, we can modify our program in the following way: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32ResizeDIBSection</span><span class="hljs-params">(win32_offscreen_buffer *Buffer, <span class="hljs-keyword">int</span> Width, <span class="hljs-keyword">int</span> Height)</span></span>
<span class="line"></span>{</span>
<span class="line">    <span class="hljs-comment">//...</span></span>
<span class="line">    Buffer-&gt;Width = Width;</span>
<span class="line">    Buffer-&gt;Height = Height;</span><div class=" edit"><span class="line">    <span class="hljs-comment">// Buffer-&gt;BytesPerPixel = 4;</span></span></div><span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;20:</b> <file>[win32_handmade.cpp]</file> Breaking our program.</div></center>
<p>




<div class="admonition tip">You can &ldquo;drag&rdquo; a line in <code>4coder</code> by pressing <code>Alt-Up</code> or <code>Alt-Down</code>.</div>

</p><p>

If we build and run our program now, our debugger suddenly halts the execution with the following message:

</p><p>

<center><div class="image" style=""><a href="../media/day5/access_viol.png" target="_blank"><img class="markdeep" src="../media/day5/access_viol.png" /></a><center><span class="imagecaption"><a class="target" name="figure_x">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;4:</b> Access Violation exception.</span></center></div></center>

</p><p>

What happened?

</p><p>

When we talked about virtual address space, you'll remember that by default we get no memory pages reserved or committed. So if we try to write to a pointer which point to an invalid page/address, the CPU will raise an exception and halt the program's execution. The operating system will be then notified and let the program know that it's touching invalid memory. 

</p><p>

Note that it could well be that the program is touching the memory it's allowed to. For instance, an allocated memory chunk could need to have its memory reserved somewhere else. But it's not that happened in this case: we tried to an invalid pointer and got what's known an <em class="underscore">access violation or segmentation fault</em>. Now, if you notice, this pointer is <em class="underscore">awfully</em> suspicious: it's <em class="underscore">all zeroes</em>. And what this means is that we tried to write to a pointer that we never initialized. 

</p><p>

We know what happened in this case, but let's see how we arrived to it. If we inspect our <code>Pixel</code> pointer, we'll see that it's invalid, and that probably means that the <code>Buffer.Memory</code> pointer is invalid (<code>0</code>). Halt the program's execution (<code>Ctrl-F5</code>), put a breakpoint at the start of the  <code>Win32ResizeDIBSection</code> and run again. 

</p><p>

<ol start=1>
<li class="number"><code>ResizeDIBSection</code> gets a pointer to the <code>GlobalBackbuffer</code> which, at the start of the program should be completely initialized.
</li>
<li class="number">We initialize the various values.
</li>
<li class="number">We try to calculate our memory size and... we get <code>0</code>.</li></ol>

</p><p>

Bug found! <code>BytesPerPixel</code> is not initialized, so what happens during the memory size calculation is the multiplication for <code>0</code>. You don't need any memory for something that requires <code>0</code> bytes to store.

</p><p>

This was a very simple mistake. It can happen when quickly typing and often intercepted as quickly. Unfortunately often the effects of such mistakes are not as clearly visible, and this is where <em class="underscore">assertions</em> would save the day. 

</p><p>

We will return to assertions later down the line but for now keep in mind that there're errors which you want to safeguard against at all times. The ones might be insidious and hard to find, they do not manifest themselves that often. The errors that appear every time you run our problem will always be there, but they're not as important to guard against. We'll always be able to fix those. What you need to worry about are the errors which might not appear until after you ship. 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32ResizeDIBSection</span><span class="hljs-params">(win32_offscreen_buffer *Buffer, <span class="hljs-keyword">int</span> Width, <span class="hljs-keyword">int</span> Height)</span></span>
<span class="line"></span>{</span>
<span class="line">    <span class="hljs-comment">//...</span></span>
<span class="line">    Buffer-&gt;Width = Width;</span>
<span class="line">    Buffer-&gt;Height = Height;</span><div class=" edit"><span class="line">    Buffer-&gt;BytesPerPixel = <span class="hljs-number">4</span>;</span></div><span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;21:</b> <file>[win32_handmade.cpp]</file> Fixing our program.</div></center>
<p>


<em class="underscore">(Continue to Section  <a href="#toc5">5</a>)</em>

</p>
<a class="target" name="sideconsiderations">&nbsp;</a><a class="target" name="sideconsiderations">&nbsp;</a><a class="target" name="toc11">&nbsp;</a><h1>Side Considerations</h1>

<a class="target" name="variableinitialization">&nbsp;</a><a class="target" name="sideconsiderations/variableinitialization">&nbsp;</a><a class="target" name="toc11.1">&nbsp;</a><h2>Variable Initialization</h2>
<p>


You might wonder: what is the performance difference between defining a variable within the loop vs. outside the loop? For example, see two code snippets below:  

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">while</span> (Running)</span>
<span class="line">{</span><div class=" edit"><span class="line">    MSG Message;</span></div><span class="line">    PeekMessageA(&amp;Message, ...)</span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-comment">// ... </span></span>
<span class="line">    }</span>
<span class="line">}</span></code></pre><p>
versus
</p><pre class="listing tilde"><code><div class=" edit"><span class="line">MSG Message;</span></div><span class="line"><span class="hljs-keyword">while</span> (Running)</span>
<span class="line">{</span>
<span class="line">    PeekMessageA(&amp;Message, ...)</span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-comment">// ... </span></span>
<span class="line">    }</span>
<span class="line">}</span></code></pre><p>

Is there a difference? What difference does it make for the code that gets generated? 

</p><p>

The difference is... <em class="underscore">nothing</em>. Nowadays most compilers are pretty smart about how they lay out things on the <em class="underscore">stack</em>. And where you declare your local variables is largely your convenience. 

</p><p>

There's one practical difference: when you put something inside a <code>while</code> loop, the variable's scope is only bound within that loop. If you put the variable outside, other code that you wouldn't intend to might interact with that variable. In our case, <code>Message</code> is only serving for our message loop so it's bound inside it.

</p><p>

So this <em class="underscore">lexical scoping</em> allows to prevent referrals to things that shouldn't be referred. While it seems like an odd thing to protect against, it's useful because often code gets moved around, cut and pasted in different ways inside a function, and you may accidentally leave something that moves to some place it shouldn't... and you've got a bug. Putting a variable inside helps compiler to catch a few mistakes for you. It's not really a big deal. Old-school C programmers put all their declarations on top (because you used to not be able to declare them inside the code)... but it's something to consider.

</p><p>

<div class="admonition tip">This is some great minutia that you'd want to know; once you learned it, you have a much better idea about what's going on under the hood. Nowadays people are largely detached from what's CPU is doing, and it'd be great to stop that. Reach down, figure out what's going on... it makes you a much better programmer, and your code much more powerful.</div>

</p><p>

There's another thing to watch out for if you go overboard with some C++ features: class and struct constructors and destructors. Constructors and destructors get called when a class or a struct come into existance and go out of existance, respectively. They are function calls triggered on those boundaries. 

</p><p>

So if, for example, your <code>MSG</code> structure had a constructor or a destructor, the compiler has to call them <em class="underscore">each time</em> a this variable goes in and out of the scope (created and eliminated). At that point there <em class="underscore">would</em> be a potential performance hit: putting it inside the <code>while</code> loop means that <code>MSG</code> constructor and destructor are called at each <code>while</code> cycle. That is compiler's responsibility, and it does not have flexibility to do anything else unless it can determine that it can safely defer that destruction in some way. 

</p><p>

<em class="underscore">(Continue to Section  <a href="#toc5">5</a>)</em>

</p>
<a class="target" name="passingparameterstothefunctions">&nbsp;</a><a class="target" name="sideconsiderations/passingparameterstothefunctions">&nbsp;</a><a class="target" name="toc11.2">&nbsp;</a><h2>Passing Parameters to the Functions</h2>
<p>


You may ask: why would you not pass the structure itself? The reason is that you don't want to go overboard with your <em class="underscore">type wrapping</em>. 

</p><p>

We created <code>win32_window_dimension</code> in first place for the sole reason that you cannot return two values from a C function. So when we want to return more than one value, you bundle those together. There're languages that support return of two integers, and if you're using a language using one of those, this is exactly what you should do. 

</p><p>

However, if we pass this structure as is to our <code>Win32ResizeDIBSection</code> and <code>Win32DisplayBufferInWindow</code> we will force everyone who will ever call these functions to bundle that width and height together, even if you had that width and height from something else. That is not what we want to do. 

</p><p>

When making a function you want to make it available as much as possible, in the most number of circumstances. This is what gives us leverage and allows us to reuse the code more often. The only time when you really want to bundle things together is when these types interdepend on each other. Take <code>win32_offscreen_buffer</code>: the pitch, width, height, bytes per pixel... all these value influence how the final memory would look. They go together and they cannot be used separately. But <code>win32_window_dimension</code> is some arbitrary dimension. You could have gotten it from anywhere, not necessarily from <code>Win32GetWindowDimension</code> call. 

</p><p>

<em class="underscore">(Back to Subsection  <a href="#toc5.2">5.2</a>)</em>

</p>
<a class="target" name="aboutconventions">&nbsp;</a><a class="target" name="sideconsiderations/aboutconventions">&nbsp;</a><a class="target" name="toc11.3">&nbsp;</a><h2>About Conventions</h2>
<p>


You will note that that many of the things you've encountered so are prefaced with &ldquo;this is our convention&rdquo;, &ldquo;this is how we would do&rdquo;. This is because, in programming, there's no right or wrong, even if someone tries to tell you otherwise. There're clearly inefficient practices that can make your program super slow and your life super hard, but it doesn't mean that those aren't valid if, at the end of the day, your code does what you set it up to do.

</p><p>

We could keep in mind what we said before and pass by value if we don't need to edit the structure. However, here we're falling into the realm of the premature optimization, and we won't really do it. This sort of optimizations should be profiled only at the very latest stages of development, so we'll just stick to our conventions and pass by pointer if the struct size is of any consideration (like <code>win32_offscreen_buffer</code> actually shapes out to be).

</p><p>

As everything in this program, the names are really up to you! This is your world, and you are the master of your code. 

</p><p>

However a word is in place: while we don't teach &ldquo;good ways&rdquo; of programming, when in Rome, do as Romans do! Whenever you're working on a collective project, be sure to take your time to get used to the programming conventions and style guides your team is using, even if it's not necessarily how you'd do the things!

</p>
<a class="target" name="aboutconstkeyword">&nbsp;</a><a class="target" name="sideconsiderations/aboutconstkeyword">&nbsp;</a><a class="target" name="toc11.4">&nbsp;</a><h2>About <code>const</code> Keyword</h2>
<p>


In this course, we won't be using <code>const</code> keyword. <code>const</code> is a language-specific keyword (i.e. it doesn't have any impact on the code generated) which prevents the programmer from modifying a value that normally would be read-only. As we said above, it's strictly about our own habit.

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line"><span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> BytesPerPixel = <span class="hljs-number">4</span>;</span>
<span class="line"></span>
<span class="line">BytesPerPixel = <span class="hljs-number">8</span>; <span class="hljs-comment">// error C3892: 'BytesPerPixel: you cannot assign to a variable that is const</span></span></div></code></pre><center><div class="listingcaption tilde"><file>[Example]</file> Assigning to const.</div></center>
<p>


As everything in this course, not using <code>const</code> is our own convention. If you find yourself doing many <code>const</code>-related mistakes in your code, feel free to use it!

</p>
<a class="target" name="navigation">&nbsp;</a><a class="target" name="navigation">&nbsp;</a><a class="target" name="toc12">&nbsp;</a><h1>Navigation</h1>
<p>


Previous: <a href="day4.html">Day 4. Animating the Back buffer</a>

</p><p>

Up Next: <a href="day6.html">Day 6. Gamepad and Keyboard Input</a>

</p><p>

<a href="../index.md.html">Back to Index</a>

</p>
<div class="nonumberh1">Glossary</div>
<p>


<ul>
<li class="asterisk">Access Violation/Segmentation Fault
</li>
<li class="asterisk">Inlining a function
</li>
<li class="asterisk">Pointer Aliasing
</li>
<li class="asterisk">Stack</li></ul>

</p>
<div class="nonumberh1">References</div>

<div class="nonumberh1">Talks</div>
<p>


<a href="https://www.youtube.com/watch?v=FnGCDLhaxKU">Understanding Compiler Optimization by Chandler Carruth</a>

</p>
<div class="nonumberh1">Articles</div>
<p>


<a href="https://docs.microsoft.com/en-us/windows/win32/procthread/thread-stack-size">Thread Stack Size</a>

</p>
<div class="nonumberh1">Compiler Options</div>
<p>


<a href="https://docs.microsoft.com/en-us/cpp/build/reference/f-set-stack-size">-F (Set Stack Size)</a>

</p><p>

<style class="fallback">
  body {
    visibility: hidden;
    font-family: sans-serif;
  }
</style>

</p><p>

<script>markdeepOptions = { tocStyle: 'long' }; window.alreadyProcessedMarkdeep || (document.body.style.visibility = 'visible');</script>

</p><p>

</p></span><div id="mdContextMenu" style="visibility:hidden"></div><div class="markdeepFooter"><i>formatted by <a href="https://casual-effects.com/markdeep" style="color:#999">Markdeep&nbsp;1.10&nbsp;&nbsp;</a></i><div style="display:inline-block;font-size:13px;font-family:'Times New Roman',serif;vertical-align:middle;transform:translate(-3px,-1px)rotate(135deg);">&#x2712;</div></div>