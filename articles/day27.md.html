<meta charset="utf-8" />
<link rel="stylesheet" href="../css/style.css" />

**Day 27. Exploration-based Architecture** 
_Video Length (including Q&A): [1h42](https://hero.handmade.network/episode/code/day027/)_ 

(insert intro.md.html here) 

We did quite a bit of theory last time; let's get to practice! 

# Project State Space

If we put on our fantasy hats and head into the fantasy land of unicorns, magic, and trolls called Project State Space, we will find a map showing our progress on the project. In our case, we're essentially at Day 0 of the project (if you exclude the excruciating need of having to talk to Windows), and our map looks quite empty: 

******************************************************
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                *                                   *
*                 ^                                  *
*                  \                                 *
*                   \                                *
*                    \You are here.                  *
******************************************************
[Figure [x]: You are here.]

There's also a point at which we will ship our project. We start somewhere, and that somewhere is the finish: 

******************************************************
*          Day 700? * <----- Ship                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*            Day 0 *                                 *
******************************************************
[Figure [x]: You are still down there.]

Of course, if you worked on any project, you know that the path from start to finish is _never_ straight. It's even more the case in the wonderful world of software development. This path to victory is often arduous, full of deviations and even setbacks: 

******************************************************
*           Day 700 *                                *
*                   ^           .---.                *
*                   |          |     |               *
*                    '--------'      |               *
*          .------------------------'                *
*         /         .--------.                       *
*        /         /          |                      *
*       |         /           |                      *
*        '-------'    .------'                       *
*                    /                               *
*                   /                                *
*                  |                                 *
*            Day 0 *                                 *
******************************************************
[Figure [x]: This is a map of a good project. It gets to ship.]

Often, you don't even know how the final product will look! You only have a vague idea, but unless it's anything more complex than a "hello world" project, any additional details will be revealed as the project grows stronger. It's not necessarily a "point" you're trying to reach but more of a nebulous blob of possibilities that slowly condenses into the final product.

******************************************************
*            .--.       .----.                       *
*           |    |     |      |                      *
*       .--'      '---'        '-.                   *
*      |      Day 700?  Ship      |                  *
*       '---.             .------'                   *
*            |           |                           *
*             '---------'                            *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*            Day 0 *                                 *
******************************************************
[Figure [x]: The shipping point is more of a shipping nebula when you're starting.]

Because of this, you might initially set towards a specific point in the "shipping nebula" and even progress there for a while before realizing that the actual thing you're trying to reach is further away. Eventually, the nebula will condense into a point, and you will ship your project.

## Waypoints

So how should one approach this voyage, sitting down for the new day and hoping it will bring the project (or even individual pieces of code) closer to the finish? 

At any given point in your project journey, be it day 0, day 100, etc., you would set yourself an objective for the day. Maybe it's upgrading the object system because it doesn't handle the number of objects we're trying to draw or optimizing something. Who knows? By doing this, you're effectively picking a new point on your Project State Space and advancing yourself towards that point. Thus, day by day, you'd choose new points from wherever you left the day before. The better you're at dead reckoning, the fewer switchbacks and backtraces there are, the faster you ship your project.

******************************************************
*            .--.       .----.                       *
*           |    |     |      |                      *
*       .--'      '---'        '-.                   *
*      |      Day 700?  Ship      |                  *
*       '---.             .------'                   *
*            |           |                           *
*             '---------'                            *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*                                                    *
*            Day 103 *<--.  o o                      *
*                         \ ^ ^                      *
*                   o o    \|/                       *
*                   ^ ^ .-->* Day 102                *
*                    \|/                             *
*               o  o  * Day 101                      *
*                ^ ^ ^                               *
*                 \|/                                *
*          Day 100 *---> o                           *
*                  |                                 *
******************************************************
[Figure [x]: Day after day, you build your way towards your goal.]

This is where __compression-oriented programming__ comes into play. It allows us to write code, see how it works at the low level, and eventually elevate it into more significant designs as we go without needing a lot of pre-planning.

For more information about compression-oriented programming, see Subsection [compression-oriented programming] for a broader definition. 

The main issue with pre-planning is that it assumes that you know what the final code would look like. If you have to do the pre-plan, you set your final point in advance and create the "waypoints" through which the project should go. 

******************************************************
*            .--.       .----.                       *
*           |    |     |      |                      *
*       .--'      '---'        '-.                   *
*      |    Day 700 *   Ship      |                  *
*       '---.             .------'                   *
*            |      X    |                           *
*             '---------'                            *
*                                                    *
*                   X                                *
*                                                    *
*                                                    *
*                   X                                *
*                                                    *
*                                                    *
*                   X                                *
*                                                    *
*                                                    *
*                   X                                *
*                                                    *
*             Day 0 *                                *
******************************************************
[Figure [x]: Expectation: an ideal plan everyone tries to achieve.]

But if you don't know the final point, there's no way to do the waypoints. In reality, the final point is often set way off course.

******************************************************
*    * What we plan to ship                          *
*            .--.       .----.                       *
*           |    |     |      |                      *
*       .--'      '---'        '-.                   *
*      |  X      o What we want   |                  *
*       '---.             .------'                   *
*            |           |                           *
*             '---------'                            *
*             X                                      *
*                                                    *
*                                                    *
*                                                    *
*                 X                                  *
*                                                    *
*                                                    *
*             Day 0 *                                *
******************************************************
[Figure [x]: Reality.]

So when someone tries to follow that plan, things get progressively janky, and by the time you get to a certain point and realize it's a disaster, it's usually way too late to change things. The code is awful; we're fighting the architecture the whole way, and you either ship something sub-optimal or try to course-correct toward the actual goal. 

## Explore and Lock

Thus, upfront design is about putting some waypoints on this map without knowing your destination. We showed that it doesn't work, and you should avoid looking too far ahead. What we want to encourage instead and how we'll approach everything[^win-32] will be focused on unknown (to us) problems. Hopefully, by the end of this course, you'll develop skills to approach these problems. That's the tricky thing, one that makes you a code architect. 

We'll take an "Explore and Lock" approach to achieve that. Our approach will be the opposite of these waypoints. We'll explore and see what we find around us at each point we're at. When we find something that we _feel_ is along the path that gets us to shipping the product, we will lock it in and make it our new starting location. 

******************************************************
*            .--.       .----.                       *
*           |    |     |      |                      *
*       .--'      '---'        '-.                   *
*      |         o Ship           |                  *
*       '---.             .------'                   *
*            |           |                           *
*             '---------'                            *
*                                                    *
*                                                    *
*                                                    *
*                        .                           *
*                         .                          *
*                          .                         *
*                           * <----- Rinse and repeat*
*                          /                         *
*                       .-+---.                      *
*                      / * <---\----- Lock this point*
*                     /o  \   o \                    *
*                 +--|-->o * <---|--- Start here     *
*                /    \o      o /                    *
* Explore around+-+----\-->o   /                     *
*                       '-----'                      *
******************************************************
[Figure [x]: Explore and Lock.]

In doing so, you would hopefully develop a feel for a _gradient_ along the path to shipping. This way, you'll also learn when architecture is good or bad, making you more at ease when faced with a new architecture and staying on the right track.

# Our Game Design

With this theory out of the way, let's briefly discuss the game we want to make. Specifically, we'll touch upon how our game looks and plays to see what engine we build to support it. 

It's important to note that this course doesn't focus on game design, and we're trying to make the most straightforward design possible while maintaining a complex programming challenge.

We'll take significant inspiration from the classic games like _The Legend of Zelda_, and these are the main points we'd like to focus on: 

* Tile-based map
* Things that move on the map
* Fancy renderer/compositor - a complete departure from NES/SNES-era games.
* Separation between the overworld and dungeons
* Consistent space
* Procedurally generated
* No dimension limits
* Combinatorics

All of these should be simple enough so that we can finish them but complex enough so that we can learn advanced programming techniques.

## Inspiration

The original _Legend _of Zelda_ was released to NES and other platforms in 1986 and became an instant hit. Even today, decades after its release, it's often considered one of the greatest games of all time and, even less questionably so, one of the most influential. 

![Figure [x]: The Legend of Zelda.](../media/day27/zelda.png) 

Among the things in which this game was different from its many successors was an extremely open-ended experience. The game would drop you into a rich and exciting world and allow you to explore it. There were no constraints or limitations about what you could do; no fairy told you where to go, etc. In _Handmade Hero_, we will try to capture this feeling of exploration when you don't know what's coming next. Additionally, _Zelda_, being a game limited by the technology of its time, would be a good model for us, where we would take its different system and try to modernize them.

## The Tile Map

Similarly to the old _Zelda_ games, we want to make a tile-based world grid with tiles like Water, Grass, Land, Shop, and others. Our game would have the same _feel_ as the old classics but not their tile-map graphics. While the latter might have been a necessary tool for its time, and nowadays, we can supersede it, there are real benefits to having a tile-map _design_. For instance, if a tile is blocked, the player would get a clear message that you can't go through. We want to preserve this to clarify the _game_ rules to the player.

Therefore, what we want to have is a game that has tiles but does not render them as a tile map. This would avoid repeating the same asset on a rigid grid if we, for example, want to draw several forest tiles in a row.

We will also allow certain things to float outside the rigid grid structure. For example, the player in _The Legend of Zelda__ wasn't bound to a tile grid and could move freely, the same as some enemies.

## The Game World

When we talk about the game world, once again, we're thinking about _The Legend of Zelda_. In it, the player would traverse the overworld, talk to NPCs, and find entrances to the dungeons. The player would discover enemies, traps, and treasures in the dungeons. We want to recreate some of that with one notable sidenote: consistent space. 

What do we mean by that? When you enter the dungeon, you will effectively go under the world map, and should you find another exit from it, it will bring you to another point on the map consistent with the space you traversed underground. The only departure from this would be some magical context where it would be clear that it's supposed to be this way: a teleport, a portal, and similar.

Our game would generate every new world from scratch, and nothing we do will be hardcoded, aside from a few selected rooms (start screen, end screen, maybe a few others). That said, we probably won't be able to support a fixed random seed to generate the world around like many other games do; it will have to be more involved.

We want to avoid rigid boundaries on the map. You can quickly learn a 256x256x256 world, and it could get boring. We'd be much happier with an _impractical_ world limit (like 4,000,000,000 x 4,000,000,000 x 4,000,000,000) that would make it infinite for the player.

## Combinatorics

Ultimately, our game engine would support an enormous amount of possible combinations. We call these "combinatorics" - any property you can think of can invariably deal with other properties. 

For instance, if our game has a monster that can walk around, and we have a property called "fear," we should be able to hit it with something that could inflict fear on that monster. Additionally, there would be a logical way to transmit these effects: I might have a wand that I could imbue with gems, and if one of these gems happens to be a fear gem, I can cast it to a tile, and if the monster goes through that tile it becomes fearful, and if it combines with another trait the monster might run away...

Combinatorics is not easy to implement, and we will spend a long time dealing with them in the course. That said, it's not something we'll get to anytime soon. We want to create a world where we can move around, which can drive our renderer design first. Once we get that up and running, though, we will dedicate most of our time to this.

## Into the Unknown

So, this is where we stand in terms of the game design. We start this journey together and don't know where it will lead us. The final code is unknown to us since, until now, we never really attempted a _Legend of Zelda_ **clone**, let alone a completely new thing that takes it in entirely new directions. So, we have a ton of unknown stuff, and we don't have a plan for how to write it. We don't even know how to approach the tilemap! We could brainstorm and imagine a few ways to implement something like this. Still, we don't have direct experience writing a tilemap in dozens of games or anything that would give us direct knowledge on how to do things specifically.

So here we are, on Day 0 of our project, without knowledge of the road ahead and what it looks like, and we're going to walk this road precisely like we said. Explore our space by looking at what it takes to implement the basic version. How do I get a rectangle moving around on a tile map? How do I make a tile? We'll try an approach, see how the game reacts to it, and let the architecture work itself up from there. If it feels like it's working well, we will say OK and move on.

# Back to Code

## Get Target Seconds Per Frame

It's been one and a half days since we last coded. Let's get back to it! First, a quick thing that we forgot to add was how much time we will 

------------------------
<!-- 
Useful captions
Caption under the listing: [Listing [x]: <file>[]</file> .]
Picture or gif: ![Figure [x]: .](../media/day27/.jpg) 
Chart: [Figure [x]: .]
-->
------------------------






















# Recap 

# Exercises 

# Programming Notions 

## Compression-oriented programming

We briefly mentioned [Semantic Compression][] at the end of [Day 22][]. The approach that we can coin as "Compression-oriented programming", and we define it as follows: 

> "Like a good compressor, I don’t reuse anything until I have at least two instances of it occurring. Many programmers don’t understand how important this is, and try to write “reusable” code right off the bat, but that is probably one of the biggest mistakes you can make. My mantra is, “make your code usable before you try to make it reusable”.
>
> I always begin by just typing out exactly what I want to happen in each specific case, without any regard to “correctness” or “abstraction” or any other buzzword, and I get that working. Then, when I find myself doing the same thing a second time somewhere else, that is when I pull out the reusable portion and share it, effectively “compressing” the code. I like “compress” better as an analogy, because it means something useful, as opposed to the often-used “abstracting”, which doesn’t really imply anything useful. Who cares if code is abstract?
>
> Waiting until there are (at least) two examples of a piece of code means I not only save time thinking about how to reuse it until I know I really need to, but it also means I always have at least two different real examples of what the code has to do before I try to make it reusable. This is crucial for efficiency, because if you only have one example, or worse, no examples (in the case of code written preemptively), then you are very likely to make mistakes in the way you write it and end up with code that isn’t conveniently reusable. This leads to even more wasted time once you go to use it, because either it will be cumbersome, or you will have to redo it to make it work the way you need it to. So I try very hard to never make code “prematurely reusable”, to evoke Knuth.
>
> Similarly, like a magical globally optimizing compressor [...], when you are presented with new places where a previously reused piece of code could be reused again, you make a decision: if the reusable code is already suitable, you just use it, but if it’s not, you decide whether or not you should modify how it works, or whether you should introduce a new layer on top of or underneath it. [...]
>
> Finally, the underlying assumption in all of this is, if you compress your code to a nice compact form, it is easy to read, because there’s a minimal amount of it, and the semantics tend to mirror the real “language” of the problem, because like a real language, those things that are expressed most often are given their own names and are used consistently. Well-compressed code is also easy to maintain, because all the places in the code that are doing identical things all go through the same paths, but code that is unique is not needlessly complicated or separated from its use. Finally, well-compressed code is easy to extend, because producing more code that does similar operations is simple, as all the necessary code is there in a nicely recomposable way."
>
>      -- Casey Muratori, 2014-05-28

Now, you can look at this definition at the surface and say - this is exactly what DRY (Don't Repeat Yourself) principle does! But there's a very fine line between making code that uses itself, making the maximally overlapping set of functions, that DRY recommends, and setting things up to allow quick "blast style" optimization. In the latter approach, core operations are broken out so that they can be optimized individually.

With the compression-oriented programming approach, individual operations that are super simple (4-5 lines of code maximum) but not entirely homogenous are usually not collapsed. They are left as is to leave room for eventual rewriting of individual functions in a more efficient way. Instead, we leave the patterns to emerge from the code that we're writing explicitly and with understanding that we get from it.

This is but the first glimpse into what compression-oriented programming means. It will be the backbone of how we approach code, and you will have ample opportunity to see it in action.

# Side Considerations 

[^win-32]: We could say that, to a large extent, we've already been applying this approach in the Win32 layer but in reality we've been cheating a bit. We knew what the end result would be so we could roughly set our waypoints. But that isn't an interesting architectural problem, more like cutting and pasting functions from your brain. We didn't even have the waypoints, we just knew the final destination and wrote it. 

# Navigation 

Previous: [Day 26. ][day 26]

Up Next: [Day 28. ][day 28]

[Back to Index](../index.md.html)

(#) Glossary 

(insert glossary/glossary_day27.md.html here)

(insert references/refs_day27.md.html here) 

(insert links.md.html here)

<style class="fallback">
  body {
    visibility: hidden;
    font-family: sans-serif;
  }
</style>
<!-- Markdeep: https://casual-effects.com/markdeep/ -->
<script>
  markdeepOptions = { tocStyle: 'long' };
  window.alreadyProcessedMarkdeep ||
    (document.body.style.visibility = 'visible');
</script>
<script src="../js/markdeep.min.js" charset="utf-8"></script>
