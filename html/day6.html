<meta charset="UTF-8"><meta http-equiv="content-type" content="text/html;charset=UTF-8"><meta name="viewport" content="width=600, initial-scale=1"><style>body{max-width:680px;margin:auto;padding:20px;text-align:justify;line-height:140%; -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;font-smoothing:antialiased;color:#222;font-family:Palatino,Georgia,"Times New Roman",serif}</style><style>@media print{*{-webkit-print-color-adjust:exact;text-shadow:none !important}}body{counter-reset: h1 h2 h3 h4 h5 h6 paragraph}@page{margin:0;size:auto}#mdContextMenu{position:absolute;background:#383838;cursor:default;border:1px solid #999;color:#fff;padding:4px 0px;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,"Helvetica Neue",sans-serif;font-size:85%;font-weight:600;border-radius:4px;box-shadow:0px 3px 10px rgba(0,0,0,35%)}#mdContextMenu div{padding:0px 20px}#mdContextMenu div:hover{background:#1659d1}.md code,.md pre{font-family:Menlo,Consolas,monospace;font-size:98%;text-align:left;line-height:140%}.md .mediumToc code,.md longToc code,.md .shortToc code,.md h1 code,.md h2 code,.md h3 code,.md h4 code,.md h5 code,.md h6 code{font-size:unset}.md div.title{font-size:26px;font-weight:800;line-height:120%;text-align:center}.md div.afterTitles{height:10px}.md div.subtitle{text-align:center}.md iframe.textinsert, .md object.textinsert,.md iframe:not(.markdeep){display:block;margin-top:10px;margin-bottom:10px;width:100%;height:75vh;border:1px solid #000;border-radius:4px;background:#f5f5f4}.md .image{display:inline-block}.md img{max-width:100%;page-break-inside:avoid}.md li{text-align:left;text-indent:0}.md pre.listing {width:100%;tab-size:4;-moz-tab-size:4;-o-tab-size:4;counter-reset:line;overflow-x:auto;resize:horizontal}.md pre.listing .linenumbers span.line:before{width:30px;margin-left:-28px;font-size:80%;text-align:right;counter-increment:line;content:counter(line);display:inline-block;padding-right:13px;margin-right:8px;color:#ccc}.md div.tilde{margin:20px 0 -10px;text-align:center}.md .imagecaption,.md .tablecaption,.md .listingcaption{display:inline-block;margin:7px 5px 12px;text-align:justify;font-style:italic}.md img.pixel{image-rendering:-moz-crisp-edges;image-rendering:pixelated}.md blockquote.fancyquote{margin:25px 0 25px;text-align:left;line-height:160%}.md blockquote.fancyquote::before{content:"“";color:#DDD;font-family:Times New Roman;font-size:45px;line-height:0;margin-right:6px;vertical-align:-0.3em}.md span.fancyquote{font-size:118%;color:#777;font-style:italic}.md span.fancyquote::after{content:"”";font-style:normal;color:#DDD;font-family:Times New Roman;font-size:45px;line-height:0;margin-left:6px;vertical-align:-0.3em}.md blockquote.fancyquote .author{width:100%;margin-top:10px;display:inline-block;text-align:right}.md small{font-size:60%}.md big{font-size:150%}.md div.title,contents,.md .tocHeader,.md h1,.md h2,.md h3,.md h4,.md h5,.md h6,.md .shortTOC,.md .mediumTOC,.nonumberh1,.nonumberh2,.nonumberh3,.nonumberh4,.nonumberh5,.nonumberh6{font-family:Verdana,Helvetica,Arial,sans-serif;margin:13.4px 0 13.4px;padding:15px 0 3px;border-top:none;clear:both}.md .tocTop {display:none}.md h1,.md h2,.md h3,.md h4,.md h5,.md h6,.md .nonumberh1,.md .nonumberh2,.md .nonumberh3,.md .nonumberh4,.md .nonumberh5,.md .nonumberh6{page-break-after:avoid;break-after:avoid}.md svg.diagram{display:block;font-family:Menlo,Consolas,monospace;font-size:98%;text-align:center;stroke-linecap:round;stroke-width:2px;page-break-inside:avoid;stroke:#000;fill:#000}.md svg.diagram .opendot{fill:#fff}.md svg.diagram .shadeddot{fill:#CCC}.md svg.diagram .dotteddot{stroke:#000;stroke-dasharray:4;fill:none}.md svg.diagram text{stroke:none}@media print{@page{margin:1in 5mm;transform: scale(150%)}}@media print{.md .pagebreak{page-break-after:always;visibility:hidden}}.md a{font-family:Georgia,Palatino,'Times New Roman'}.md h1,.md .tocHeader,.md .nonumberh1{border-bottom:3px solid;font-size:20px;font-weight:bold;}.md h1,.md .nonumberh1{counter-reset: h2 h3 h4 h5 h6}.md h2,.md .nonumberh2{counter-reset: h3 h4 h5 h6;border-bottom:2px solid #999;color:#555;font-weight:bold;font-size:18px;}.md h3,.md h4,.md h5,.md h6,.md .nonumberh3,.md .nonumberh4,.md .nonumberh5,.md .nonumberh6{font-family:Verdana,Helvetica,Arial,sans-serif;color:#555;font-size:16px;}.md h3{counter-reset:h4 h5 h6}.md h4{counter-reset:h5 h6}.md h5{counter-reset:h6}.md div.table{margin:16px 0 16px 0}.md table{border-collapse:collapse;line-height:140%;page-break-inside:avoid}.md table.table{margin:auto}.md table.calendar{width:100%;margin:auto;font-size:11px;font-family:Verdana,Helvetica,Arial,sans-serif}.md table.calendar th{font-size:16px}.md .today{background:#ECF8FA}.md .calendar .parenthesized{color:#999;font-style:italic}.md table.table th{color:#FFF;background-color:#AAA;border:1px solid #888;padding:8px 15px 8px 15px}.md table.table td{padding:5px 15px 5px 15px;border:1px solid #888}.md table.table tr:nth-child(even){background:#EEE}.md pre.tilde{border-top: 1px solid #CCC;border-bottom: 1px solid #CCC;padding: 5px 0 5px 20px;margin:0 0 0 0;background:#FCFCFC;page-break-inside:avoid}.md a.target{width:0px;height:0px;visibility:hidden;font-size:0px;display:inline-block}.md a:link, .md a:visited{color:#38A;text-decoration:none}.md a:link:hover{text-decoration:underline}.md dt{font-weight:700}.md dl>dd{margin-top:-8px; margin-bottom:8px}.md dl>table{margin:35px 0 30px}.md code{page-break-inside:avoid;} @media print{.md .listing code{white-space:pre-wrap}}.md .endnote{font-size:13px;line-height:15px;padding-left:10px;text-indent:-10px}.md .bib{padding-left:80px;text-indent:-80px;text-align:left}.markdeepFooter{font-size:9px;text-align:right;padding-top:80px;color:#999}.md .mediumTOC{float:right;font-size:12px;line-height:15px;border-left:1px solid #CCC;padding-left:15px;margin:15px 0px 15px 25px}.md .mediumTOC .level1{font-weight:600}.md .longTOC .level1{font-weight:600;display:block;padding-top:12px;margin:0 0 -20px}.md .shortTOC{text-align:center;font-weight:bold;margin-top:15px;font-size:14px}.md .admonition{position:relative;margin:1em 0;padding:.4rem 1rem;border-radius:.2rem;border-left:2.5rem solid rgba(68,138,255,.4);background-color:rgba(68,138,255,.15);}.md .admonition-title{font-weight:bold;border-bottom:solid 1px rgba(68,138,255,.4);padding-bottom:4px;margin-bottom:4px;margin-left: -1rem;padding-left:1rem;margin-right:-1rem;border-color:rgba(68,138,255,.4)}.md .admonition.tip{border-left:2.5rem solid rgba(50,255,90,.4);background-color:rgba(50,255,90,.15)}.md .admonition.tip::before{content:"\24d8";font-weight:bold;font-size:150%;position:relative;top:3px;color:rgba(26,128,46,.8);left:-2.95rem;display:block;width:0;height:0}.md .admonition.tip>.admonition-title{border-color:rgba(50,255,90,.4)}.md .admonition.warn,.md .admonition.warning{border-left:2.5rem solid rgba(255,145,0,.4);background-color:rgba(255,145,0,.15)}.md .admonition.warn::before,.md .admonition.warning::before{content:"\26A0";font-weight:bold;font-size:150%;position:relative;top:2px;color:rgba(128,73,0,.8);left:-2.95rem;display:block;width:0;height:0}.md .admonition.warn>.admonition-title,.md .admonition.warning>.admonition-title{border-color:rgba(255,145,0,.4)}.md .admonition.error{border-left: 2.5rem solid rgba(255,23,68,.4);background-color:rgba(255,23,68,.15)}.md .admonition.error>.admonition-title{border-color:rgba(255,23,68,.4)}.md .admonition.error::before{content: "\2612";font-family:"Arial";font-size:200%;position:relative;color:rgba(128,12,34,.8);top:-2px;left:-3rem;display:block;width:0;height:0}.md .admonition p:last-child{margin-bottom:0}.md li.checked,.md li.unchecked{list-style:none;overflow:visible;text-indent:-1.2em}.md li.checked:before,.md li.unchecked:before{content:"\2611";display:block;float:left;width:1em;font-size:120%}.md li.unchecked:before{content:"\2610"}</style><style>.md h1::before {
content:counter(h1) " ";
counter-increment: h1;margin-right:10px}.md h2::before {
content:counter(h1) "."counter(h2) " ";
counter-increment: h2;margin-right:10px}.md h3::before {
content:counter(h1) "."counter(h2) "."counter(h3) " ";
counter-increment: h3;margin-right:10px}.md h4::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) " ";
counter-increment: h4;margin-right:10px}.md h5::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) "."counter(h5) " ";
counter-increment: h5;margin-right:10px}.md h6::before {
content:counter(h1) "."counter(h2) "."counter(h3) "."counter(h4) "."counter(h5) "."counter(h6) " ";
counter-increment: h6;margin-right:10px}</style><style>.hljs{display:block;overflow-x:auto;padding:0.5em;background:#fff;color:#000;-webkit-text-size-adjust:none}.hljs-comment{color:#006a00}.hljs-keyword{color:#02E}.hljs-literal,.nginx .hljs-title{color:#aa0d91}.method,.hljs-list .hljs-title,.hljs-tag .hljs-title,.setting .hljs-value,.hljs-winutils,.tex .hljs-command,.http .hljs-title,.hljs-request,.hljs-status,.hljs-name{color:#008}.hljs-envvar,.tex .hljs-special{color:#660}.hljs-string{color:#c41a16}.hljs-tag .hljs-value,.hljs-cdata,.hljs-filter .hljs-argument,.hljs-attr_selector,.apache .hljs-cbracket,.hljs-date,.hljs-regexp{color:#080}.hljs-sub .hljs-identifier,.hljs-pi,.hljs-tag,.hljs-tag .hljs-keyword,.hljs-decorator,.ini .hljs-title,.hljs-shebang,.hljs-prompt,.hljs-hexcolor,.hljs-rule .hljs-value,.hljs-symbol,.hljs-symbol .hljs-string,.hljs-number,.css .hljs-function,.hljs-function .hljs-title,.coffeescript .hljs-attribute{color:#A0C}.hljs-function .hljs-title{font-weight:bold;color:#000}.hljs-class .hljs-title,.smalltalk .hljs-class,.hljs-type,.hljs-typename,.hljs-tag .hljs-attribute,.hljs-doctype,.hljs-class .hljs-id,.hljs-built_in,.setting,.hljs-params,.clojure .hljs-attribute{color:#5c2699}.hljs-variable{color:#3f6e74}.css .hljs-tag,.hljs-rule .hljs-property,.hljs-pseudo,.hljs-subst{color:#000}.css .hljs-class,.css .hljs-id{color:#9b703f}.hljs-value .hljs-important{color:#ff7700;font-weight:bold}.hljs-rule .hljs-keyword{color:#c5af75}.hljs-annotation,.apache .hljs-sqbracket,.nginx .hljs-built_in{color:#9b859d}.hljs-preprocessor,.hljs-preprocessor *,.hljs-pragma{color:#643820}.tex .hljs-formula{background-color:#eee;font-style:italic}.diff .hljs-header,.hljs-chunk{color:#808080;font-weight:bold}.diff .hljs-change{background-color:#bccff9}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-comment .hljs-doctag{font-weight:bold}.method .hljs-id{color:#000}</style><style>div.title { padding-top: 40px; } div.afterTitles { height: 15px; }</style><meta charset="utf-8">
<link rel="stylesheet" href="../css/style.css">

<span class="md"><p><title>Day 6. Gamepad and Keyboard Input</title><div class="title"> Day 6. Gamepad and Keyboard Input </div>

<div class="afterTitles"></div>
<em class="underscore">Video Length (includig Q&A): <a href="https://hero.handmade.network/episode/code/day006/">1h37</a></em>

</p><p>

<div class="admonition ">&ldquo;Handmade Hero Notes&rdquo; contains code from <a href="https://handmadehero.org/">Handmade Hero</a>. Preorder the game on <a href="https://handmadehero.org/">handmadehero.org</a>, and you will receive access to the GitHub repository, containing complete source code (tagged day-by-day) as well as a variety of other useful resources.</div>

</p><p>

<hr/>

</p><p>

Welcome back! Last time we mostly reviewed the work done so far, allowing us to set the groundwork for the new and exciting discoveries. And what discoveries await us! In our quest to build a game from scratch, we will be focusing on getting the user input working. Not that we have much of a plan, but we'd really like to have this done. 

</p>
<div class="longTOC"><div class="tocHeader">Contents</div><p><a href="#" class="tocTop">(Top)</a><br/>
<a href="#xinput" class="level1"><span class="tocNumber">1&nbsp; </span>XInput</a><br/>
&nbsp;&nbsp;<a href="#xinput/expandourgameloop" class="level2"><span class="tocNumber">1.1&nbsp; </span>Expand Our Game Loop</a><br/>
&nbsp;&nbsp;<a href="#xinput/markdownsomefutureconsiderations" class="level2"><span class="tocNumber">1.2&nbsp; </span>Mark Down Some Future Considerations</a><br/>
&nbsp;&nbsp;<a href="#xinput/processthecontrollerstate" class="level2"><span class="tocNumber">1.3&nbsp; </span>Process the Controller State</a><br/>
&nbsp;&nbsp;<a href="#xinput/compilewithxinputcomplication" class="level2"><span class="tocNumber">1.4&nbsp; </span>Compile With XInput Complication</a><br/>
<a href="#directlibraryloading" class="level1"><span class="tocNumber">2&nbsp; </span>Direct Library Loading</a><br/>
&nbsp;&nbsp;<a href="#directlibraryloading/inspectxinput.h" class="level2"><span class="tocNumber">2.1&nbsp; </span>Inspect <code>xinput.h</code></a><br/>
&nbsp;&nbsp;<a href="#directlibraryloading/typedefinitionofthefunctions" class="level2"><span class="tocNumber">2.2&nbsp; </span>Type Definition of the Functions</a><br/>
&nbsp;&nbsp;<a href="#directlibraryloading/createstubfunctions" class="level2"><span class="tocNumber">2.3&nbsp; </span>Create Stub Functions</a><br/>
&nbsp;&nbsp;<a href="#directlibraryloading/loadxinputlibrary" class="level2"><span class="tocNumber">2.4&nbsp; </span>Load XInput Library</a><br/>
&nbsp;&nbsp;<a href="#directlibraryloading/inspectlibraryloading" class="level2"><span class="tocNumber">2.5&nbsp; </span>Inspect Library Loading</a><br/>
&nbsp;&nbsp;<a href="#directlibraryloading/addinteractivity" class="level2"><span class="tocNumber">2.6&nbsp; </span>Add Interactivity</a><br/>
&nbsp;&nbsp;<a href="#directlibraryloading/testvibration" class="level2"><span class="tocNumber">2.7&nbsp; </span>Test Vibration</a><br/>
<a href="#keyboardinput" class="level1"><span class="tocNumber">3&nbsp; </span>Keyboard Input</a><br/>
&nbsp;&nbsp;<a href="#keyboardinput/virtual-keycodes" class="level2"><span class="tocNumber">3.1&nbsp; </span>Virtual-Key Codes</a><br/>
&nbsp;&nbsp;<a href="#keyboardinput/dissectlparam" class="level2"><span class="tocNumber">3.2&nbsp; </span>Dissect LParam</a><br/>
&nbsp;&nbsp;<a href="#keyboardinput/addsomefunctionality" class="level2"><span class="tocNumber">3.3&nbsp; </span>Add Some Functionality</a><br/>
&nbsp;&nbsp;<a href="#keyboardinput/introduceb32typeinsteadofbool" class="level2"><span class="tocNumber">3.4&nbsp; </span>Introduce <code>b32</code> type Instead of <code>bool</code></a><br/>
<a href="#recap" class="level1"><span class="tocNumber">4&nbsp; </span>Recap</a><br/>
<a href="#exercises" class="level1"><span class="tocNumber">5&nbsp; </span>Exercises</a><br/>
&nbsp;&nbsp;<a href="#exercises/convertkeyboardkeyprocessingtoaswitchstatement" class="level2"><span class="tocNumber">5.1&nbsp; </span>Convert Keyboard Key Processing to a <code>switch</code> Statement</a><br/>
&nbsp;&nbsp;<a href="#exercises/trytodosomethingwiththekeybordinput" class="level2"><span class="tocNumber">5.2&nbsp; </span>Try to do something with the keybord input</a><br/>
<a href="#programmingnotions" class="level1"><span class="tocNumber">6&nbsp; </span>Programming Notions</a><br/>
&nbsp;&nbsp;<a href="#programmingnotions/functionsignatures" class="level2"><span class="tocNumber">6.1&nbsp; </span>Function Signatures</a><br/>
&nbsp;&nbsp;<a href="#programmingnotions/readinginputdevicesstate" class="level2"><span class="tocNumber">6.2&nbsp; </span>Reading Input Devices State</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#programmingnotions/readinginputdevicesstate/interrupt" class="level3"><span class="tocNumber">6.2.1&nbsp; </span>Interrupt</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#programmingnotions/readinginputdevicesstate/polling" class="level3"><span class="tocNumber">6.2.2&nbsp; </span>Polling</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#programmingnotions/readinginputdevicesstate/operatorprecedence" class="level3"><span class="tocNumber">6.2.3&nbsp; </span>Operator Precedence</a><br/>
<a href="#sideconsiderations" class="level1"><span class="tocNumber">7&nbsp; </span>Side Considerations</a><br/>
&nbsp;&nbsp;<a href="#sideconsiderations/aboutprematureoptimization" class="level2"><span class="tocNumber">7.1&nbsp; </span>About Premature Optimization</a><br/>
<a href="#navigation" class="level1"><span class="tocNumber">8&nbsp; </span>Navigation</a><br/>
</p></div><a class="target" name="xinput">&nbsp;</a><a class="target" name="xinput">&nbsp;</a><a class="target" name="toc1">&nbsp;</a><h1>XInput</h1>
<p>


We want to focus specifically on the input from the <em class="underscore">gamepad</em> today. If you have an Xbox 360, Xbox One, a Playstation 4 controller, or another &ldquo;XInput&rdquo;-compatible device that you can plug into your pc, we'd like our game to detect that device and use it for the input. We'll also be getting input from the keyboard, so if you don't have a controller you can still control the game. 

</p><p>

The? is the controller API designed specifically for the Xbox controllers in mind. It evolved from the <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416842(v=vs.85)">DirectInput</a> API and is still largely compatible with it (albeit with some major limitations). By now every game using a controller implements this API. 

</p><p>

<div class="admonition ">XInput is not the only controller API provided by Windows. The aforementioned <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416842(v=vs.85)">DirectInput</a> API is still cosidered one of the most popular, as well as the joystick-specific <a href="https://docs.microsoft.com/en-us/windows/win32/api/joystickapi/">Joystickapi</a> and the <a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/raw-input">Raw Input</a> API.

</p><p>

    As we've seen with the GDI blit, ultimately it comes down to picking the right tool for the job. In the world of tons of legacy API, you might not even pick the best one the first time around; luckily you can always come back and change!</div>

</p><p>

Thankfully, the API is super simple: 

</p><p>

<ol start=1>
<li class="number">You loop over all the controllers that the system has found. 
</li>
<li class="number">You get the <em class="underscore">state</em> of each controller (pass a structure that is filled out by the function). 
</li>
<li class="number">That's it! You can use with this state whatever you want.</li></ol>

</p><p>

In order to get started with XInput, you simply <code>#include &lt;xinput.h&gt;</code> into your code: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span></span><div class=" add"><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;xinput.h&gt;</span></span></span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;1:</b> <file>[win32_handmade.cpp]</file> Including <code>xinput.h</code></div></center>

<a class="target" name="expandourgameloop">&nbsp;</a><a class="target" name="xinput/expandourgameloop">&nbsp;</a><a class="target" name="toc1.1">&nbsp;</a><h2>Expand Our Game Loop</h2>
<p>


We have a very simple game loop already; it's not doing much at the moment, more of a beginning of one, but a game loop nontheless. We go in, process our window messages, do our rendering and then display the rendering on the screen. 

</p><p>

XInput is a <a href="https://en.wikipedia.org/wiki/Polling_(computer_science)">polling</a>-based API, which means that it reads the state of the controller when we actually ask for it (as opposed to actively notifying of state changes).

</p><p>

<div class="admonition ">You can read more about Interrupt-based or Polling-based scheme in subsection  <a href="#toc6.2">6.2</a>.</div>

</p><p>

We have to start polling at some point, and this point is going to be right after the message processing loop. This is because the keyboard messages are coming through message the loop, and we want to capture those.

</p><p>

If you open <a href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/">XInput API homepage</a>, you will notice that it's not a very big one (compare it, for example, to <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/">winuser API</a> which we worked with earlier). And that's a pretty good thing, that's what you want. As of writing, it is composed of only six structures and eight functions.

</p><p>

At the core, we're going to use <a href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/nf-xinput-xinputgetstate">XInputGetState</a> function. You'll notice that it takes two parameters: 

</p><p>

<ul>
<li class="asterisk"><code>dwUserIndex</code> is the index of the controller, from <code>0</code> to whatever <code>XUSER_MAX_COUNT</code> is. XInput API currently only supports 4 connected controllers at a time but you never know if this number can increase.
</li>
<li class="asterisk"><code>pState</code> is the pointer to the <a href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/ns-xinput-xinput_state">XINPUTSTATE</a> structure where the state will be reported.</li></ul>

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-function">DWORD <span class="hljs-title">XInputGetState</span><span class="hljs-params">(</span>
<span class="line">  DWORD        dwUserIndex,</span>
<span class="line">  XINPUT_STATE *pState</span>
<span class="line">)</span></span>;</span></code></pre><center><div class="listingcaption tilde"><file>[MSDN]</file> <code>XInputGetState</code> signature.</div></center>
<p>


In practice, this means that we need to cycle through four indices and call <code>XInputGetState</code>. The latter will check if there is a connected controller on the given index and, if so, to poll it.

</p><pre class="listing tilde"><code><span class="line">MSG Message;</span>
<span class="line"><span class="hljs-keyword">while</span> (PeekMessageA(...))</span>
<span class="line">{</span>
<span class="line">    <span class="hljs-comment">// ...</span></span>
<span class="line">}</span><div class=" add"><span class="line"><span class="hljs-keyword">for</span> (DWORD ControllerIndex = <span class="hljs-number">0</span>;</span>
<span class="line">    ControllerIndex &lt; XUSER_MAX_COUNT;</span>
<span class="line">    ++ControllerIndex)</span>
<span class="line">{</span>
<span class="line">    XINPUT_STATE ControllerState;</span>
<span class="line">    XInputGetState(ControllerIndex, &amp;ControllerState);</span>
<span class="line">}</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;2:</b> <file>[win32_handmade.cpp > WinMain]</file> Setting up XInput loop</div></center>
<p>


Now that we potentially have controller state data, we can store and process it on our side. But first, we need to make sure that the controller we're checking is connected. <code>XInputGetState</code> will return whether or not a controller is connected to a given index, through the values <code>ERROR_SUCCESS</code> (weird name but ok) or <code>ERROR_DEVICE_NOT_CONNECTED</code>. We can easily check on this:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">for</span> (DWORD ControllerIndex = <span class="hljs-number">0</span>;</span>
<span class="line">    ControllerIndex &lt; XUSER_MAX_COUNT;</span>
<span class="line">    ++ControllerIndex)</span>
<span class="line">{</span>
<span class="line">    XINPUT_STATE ControllerState;</span><div class=" edit"><span class="line">    <span class="hljs-keyword">if</span> (XInputGetState(ControllerIndex, &amp;ControllerState) == ERROR_SUCCESS)</span></div><div class=" add"><span class="line">    {</span>
<span class="line">        <span class="hljs-comment">// NOTE(casey): This controller is plugged in</span></span>
<span class="line">    }</span>
<span class="line">    <span class="hljs-keyword">else</span></span>
<span class="line">    {</span>
<span class="line">        <span class="hljs-comment">// NOTE(casey): This controller is not available.</span></span>
<span class="line">    }</span></div><span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;3:</b> <file>[win32_handmade.cpp > WinMain]</file> Verifying the controller is connected.</div></center>
<p>


We might potentially use the &ldquo;not available&rdquo; state if, for example, we want to show to the user that the controller has been unplugged, or if we want to take any other action here. Contrary to <code>WindowClass</code> or <code>Window</code> initialization, this is not necessarily an error case. 

</p><p>

Anyhow, right now we're rather interested in what we do if the controller is actually connected, so today we'll focus on that. In the future, we may want to handle the other case, as well.

</p><p>

To recap: We go through several potential &ldquo;slots&rdquo; (<code>ControllerIndex</code>) to which a controller might be connected. If so, <code>ControllerState</code> gets filled out for us, and we may proceed.

</p>
<a class="target" name="markdownsomefutureconsiderations">&nbsp;</a><a class="target" name="xinput/markdownsomefutureconsiderations">&nbsp;</a><a class="target" name="toc1.2">&nbsp;</a><h2>Mark Down Some Future Considerations</h2>
<p>


Let's have a better look at the <code>XINPUT_STATE</code> that we're filling out. What do we get?

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">XINPUT_STATE</span> {</span></span>
<span class="line">  DWORD          dwPacketNumber;</span>
<span class="line">  XINPUT_GAMEPAD Gamepad;</span>
<span class="line">} XINPUT_STATE, *PXINPUT_STATE;</span></code></pre><center><div class="listingcaption tilde"><file>[MSDN]</file> <code>XINPUT_STATE</code> definition.</div></center>
<p>


As we can see, <code>XINPUT_STATE</code> holds two values: <a href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/ns-xinput-xinput_gamepad">XINPUT_GAMEPAD</a> structure, that we will look at in a second, and <code>dwPacketNumber</code>, the state <em class="underscore">packet</em> number.

</p><p>

Let's pause on the latter for a second. Packet number allows us to see if there has been any change in the state (a button was pressed, a stick was moved, etc.) since the last update. If the number increments, changes happened. These increments are handled between the controller and the driver, so if we missed a few... those are user inputs that we lost. 

</p><p>

Eventually we might want to have a hard look at this packet number and decide, whether or not we want to make more frequent state updates. XInput might or might not want us to poll it more often. It might well be that the sampling happens at a higher rate without a significant change at each update. We'll need to have a deeper investigation once we're done with the first round of implementation of our game. 

</p><p>

Since we're aiming to have a 60 frame-per-second game loop, it might be more than enough, or it may not be. Let's put a couple <code>TODO</code>s to actually do it later: 

</p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-comment">// TODO(casey): Should we poll this more frequently? </span></span></div><span class="line"><span class="hljs-keyword">for</span> (DWORD ControllerIndex = <span class="hljs-number">0</span>;...)</span>
<span class="line">{</span>
<span class="line">    XINPUT_STATE ControllerState;</span>
<span class="line">    <span class="hljs-keyword">if</span>(XInputGetState(...))</span>
<span class="line">    {</span><div class=" add"><span class="line">        <span class="hljs-comment">// TODO(casey): See if ControllerState.dwPacketNumber increments too rapidly</span></span></div><span class="line">    }</span>
<span class="line">    <span class="hljs-comment">// ...</span></span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;4:</b> <file>[win32_handmade.cpp > WinMain]</file> Leave a TODO for a future you.</div></center>

<a class="target" name="processthecontrollerstate">&nbsp;</a><a class="target" name="xinput/processthecontrollerstate">&nbsp;</a><a class="target" name="toc1.3">&nbsp;</a><h2>Process the Controller State</h2>
<p>


Now, let's look at the actual controller state. It's captured in the <a href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/ns-xinput-xinput_gamepad">XINPUT_GAMEPAD</a> structure:

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">XINPUT_GAMEPAD</span> {</span></span>
<span class="line">  WORD  wButtons;</span>
<span class="line">  BYTE  bLeftTrigger;</span>
<span class="line">  BYTE  bRightTrigger;</span>
<span class="line">  SHORT sThumbLX;</span>
<span class="line">  SHORT sThumbLY;</span>
<span class="line">  SHORT sThumbRX;</span>
<span class="line">  SHORT sThumbRY;</span>
<span class="line">} XINPUT_GAMEPAD, *PXINPUT_GAMEPAD;</span></code></pre><center><div class="listingcaption tilde"><file>[MSDN]</file> <code>XINPUT_GAMEPAD</code> definition.</div></center>
<p>


Seems pretty straightforward. This struct maps directly to an Xbox controller. However, the way this information is packaged is pretty interesting. The struct is very small: altogether it adds to 12 bytes. This, of course, is to allow fast uplink from the gamepad to the application. Thus: 

</p><p>

<ul>
<li class="asterisk"><code>wButtons</code>: a single 16-bit <code>WORD</code> packages the state of all the buttons in a <em class="underscore">bit field</em>. 
<ul>
    <li class="asterisk">If you check the <a href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/ns-xinput-xinput_gamepad">documentation</a>, you will quickly realize that the space is quite tight: 14 out of 16 bits are mapped to a button! 
</li>
    <li class="asterisk">If the button is currently being pressed, that bit is set, if not, it's unset.
</li></ul>
<li class="asterisk">The triggers and the thumbstics provide <em class="underscore">analogue</em> values. 
<ul>
    <li class="asterisk">The left and right trigger's values (<code>sThumbLX</code> and <code>sThumbLY</code>) take a <code>BYTE</code> each (8 bit unsigned), so their values range between <code>0</code> and <code>255</code>.
</li>
    <li class="asterisk">The thumbsticks, on the other hand, offer a much more precise control. <code>SHORT</code> is a signed 16-bit value, so the readings in X-Y direction range between between <code>-32768</code> and <code>32767</code>.</li></ul></li></ul>

</p><p>

<center><div class="image" style=""><a href="../media/day6/360_controller.svg" target="_blank"><img class="markdeep" src="../media/day6/360_controller.svg" /></a><center><span class="imagecaption"><a class="target" name="figure_x">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;1:</b> Xbox 360 controller. (<a href="https://commons.wikimedia.org/wiki/File:360_controller.svg">Wikimedia</a>)</span></center></div></center>

</p><p>

<div class="admonition ">You'll notice that the central &ldquo;Xbox&rdquo; button is not mapped. Its usage is reserved by the operating system.</div>

</p><p>

Now, which values do we need? Our game is pretty oldschool, so we might not necessarily use everything a gamepad has to offer. From <code>wButtons</code> we'll take most of the button states but we'll not have any use for the triggers. As for the thumbsticks... We might support at least one, for the character movement. 

</p><p>

Right now we don't really have anywhere to store these values in, so for now let's simply mark up the things we're interested in. We will also grab a pointer to the struct so that it's easier to type and read. 

</p><p>

But how would you <em class="underscore">read</em> values from a bit field? So far we've only passed coded bits <em class="underscore">to</em> the system, but never from. Well, while we were using the bitwise OR <code>|</code> operator to chain the values together, you can see if a byte is set by masking it out with the bitwise AND <code>&amp;</code>.

</p><pre class="listing tilde"><code><span class="line">XINPUT_STATE ControllerState;</span>
<span class="line"><span class="hljs-keyword">if</span>(XInputGetState(...))</span>
<span class="line">{</span>
<span class="line">    <span class="hljs-comment">// TODO(casey): See if ControllerState.dwPacketNumber increments too rapidly</span></span><div class=" add"><span class="line">    XINPUT_GAMEPAD *Pad = &amp;ControllerState.Gamepad;</span>
<span class="line">                        </span>
<span class="line">    <span class="hljs-keyword">bool</span> Up            = Pad-&gt;wButtons &amp; XINPUT_GAMEPAD_DPAD_UP;</span>
<span class="line">    <span class="hljs-keyword">bool</span> Down          = Pad-&gt;wButtons &amp; XINPUT_GAMEPAD_DPAD_DOWN;</span>
<span class="line">    <span class="hljs-keyword">bool</span> Left          = Pad-&gt;wButtons &amp; XINPUT_GAMEPAD_DPAD_LEFT;</span>
<span class="line">    <span class="hljs-keyword">bool</span> Right         = Pad-&gt;wButtons &amp; XINPUT_GAMEPAD_DPAD_RIGHT;</span>
<span class="line">    <span class="hljs-keyword">bool</span> Start         = Pad-&gt;wButtons &amp; XINPUT_GAMEPAD_START;</span>
<span class="line">    <span class="hljs-keyword">bool</span> Back          = Pad-&gt;wButtons &amp; XINPUT_GAMEPAD_BACK;</span>
<span class="line">    <span class="hljs-keyword">bool</span> LeftShoulder  = Pad-&gt;wButtons &amp; XINPUT_GAMEPAD_LEFT_SHOULDER;</span>
<span class="line">    <span class="hljs-keyword">bool</span> RightShoulder = Pad-&gt;wButtons &amp; XINPUT_GAMEPAD_RIGHT_SHOULDER;</span>
<span class="line">    <span class="hljs-keyword">bool</span> A             = Pad-&gt;wButtons &amp; XINPUT_GAMEPAD_A;</span>
<span class="line">    <span class="hljs-keyword">bool</span> B             = Pad-&gt;wButtons &amp; XINPUT_GAMEPAD_B;</span>
<span class="line">    <span class="hljs-keyword">bool</span> X             = Pad-&gt;wButtons &amp; XINPUT_GAMEPAD_X;</span>
<span class="line">    <span class="hljs-keyword">bool</span> Y             = Pad-&gt;wButtons &amp; XINPUT_GAMEPAD_Y;</span></div><span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;5:</b> <file>[win32_handmade.cpp > WinMain]</file> Decoding the button states.</div></center>
<p>


As for the analog values, we can get a signed 16-bit (<code>s16</code>) integer and store there the <code>X</code> and <code>Y</code> coordinates of the left thumbstick.

</p><pre class="listing tilde"><code><span class="line">XINPUT_GAMEPAD *Pad = &amp;ControllerState.Gamepad;</span>
<span class="line"></span>
<span class="line"><span class="hljs-comment">// ... </span></span>
<span class="line"></span><div class=" add"><span class="line">s16 StickX = Pad-&gt;sThumbLX;</span>
<span class="line">s16 StickY = Pad-&gt;sThumbLY;</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;6:</b> <file>[win32_handmade.cpp > WinMain]</file> Capturing the stick movement.</div></center>
<p>


This is pretty much it all the values that we'll need to capture.

</p>
<a class="target" name="compilewithxinputcomplication">&nbsp;</a><a class="target" name="xinput/compilewithxinputcomplication">&nbsp;</a><a class="target" name="toc1.4">&nbsp;</a><h2>Compile With XInput Complication</h2>
<p>


If you try to compile now, you will see a familiar error: 

</p><pre class="listing tilde"><code><span class="line">win32_handmade.obj : error LNK2019: unresolved external symbol XInputGetState referenced in function WinMain</span>
<span class="line">win32_handmade.exe : fatal error LNK1120: 1 unresolved externals</span></code></pre><p>

The problem looks simple enough, we simply need to link our <code>XInputGetState</code> with a library. The solution, however, is more complicated than anything we've seen before. 

</p><p>

Usually you would simply look at the bottom of the <a href="https://docs.microsoft.com/en-us/">MSDN</a> page of the function to find the library you need to link against. The problem here is that there're <em class="underscore">two</em> libraries, and the <code>Platform Requirements</code> line (which up until now was a simple <code>Windows 2000</code>) is a bit sketchy:

</p><pre class="listing tilde"><code><span class="line">Platform Requirements</span>
<span class="line"></span>
<span class="line">Windows 8 (XInput 1.4), DirectX SDK (XInput 1.3), Windows Vista (XInput 9.1.0) </span></code></pre><p>

We need one of the following: 

</p><p>

<ul>
<li class="asterisk"><code>Windows 8</code> or later to use XInput version 1.4
<ul>
    <li class="asterisk">Even in 2020, this is still not the case for everyone. Many people still comfortably use Windows 7.
</li></ul>
<li class="asterisk"><code>DirectX SDK</code> to use XInput version 1.3
<ul>
    <li class="asterisk">We don't really know what that means and what version do they mean, or if the user even has it installed.
</li>
    <li class="asterisk">We didn't use DirectX SDK yet, and if we ever are going to use one we're going to use a very early version of it. 
</li></ul>
<li class="asterisk"><code>Windows Vista</code> or later to use XInput version 9.1.0
<ul>
    <li class="asterisk">Technically, by now Windows XP or earlier shouldn't be of any concern for us... But you never know.</li></ul></li></ul>

</p><p>

All this said, we cannot <em class="underscore">guarantee</em> that the user's machine will have the necessary <code>.dll</code>s installed when they will run the game. We cannot simply link with <code>Xinput.lib</code> and hope for the best, because if the program can't find one of these <code>.dll</code>s on the system, our game just won't load. 

</p><p>

It will simply won't load. 

</p><p>

And that's kind of annoying because you don't <em class="underscore">need</em> a gamepad to play this game, we're going to allow at least keyboard to play the game. 

</p><p>

So what do we do? Let's talk about direct loading of functions.

</p>
<a class="target" name="directlibraryloading">&nbsp;</a><a class="target" name="directlibraryloading">&nbsp;</a><a class="target" name="toc2">&nbsp;</a><h1>Direct Library Loading</h1>
<p>


What we're going to discuss here is a concept of loading the Windows functions ourselves, without a need of an Import Library. 

</p><p>

You might remember <a href="day1.html">day 1</a> when we discussed the role of the Import Libraries in the program execution. The Import Libraries serve to put specific markers into the code which, upon the program's loading, will be found by Windows and patched with the actual functions running in memory.

</p><p>

We will get the code to skip just this step. Our executable will look for a Windows binding, then look up the function pointers so that we can call the function directly, thus eliminating the middle man.

</p><p>

This is actually a pretty simple process, especially considering we have such a small number of functions that we need to deal with. From the &ldquo;huge&rdquo; XInput API we'll probably only ever going to need two functions: <code>XInputGetState</code> and potentially <code>XInputSetState</code> to set some vibrations.

</p>
<a class="target" name="inspectxinput.h">&nbsp;</a><a class="target" name="directlibraryloading/inspectxinput.h">&nbsp;</a><a class="target" name="toc2.1">&nbsp;</a><h2>Inspect <code>xinput.h</code></h2>
<p>


If you use <a href="https://code.visualstudio.com/">VScode</a>, you can hit <code>F12</code> while your cursor is under <code>&lt;xinput.h&gt;</code> include filename to quickly open <code>xinput.h</code> (if not, you can open <a href="https://visualstudio.microsoft.com/">Visual Studio</a> and do the same thing).

</p><p>

What you can see inside that file are the DLLs that we want to link against depending on the version, and then all the defines and declarations that we can also find in <a href="https://docs.microsoft.com/en-us/">MSDN</a>. Among other things, the file contains declarations of the functions we care about: <code>XInputGetState</code> and <code>XInputSetState</code>: 

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">XInputGetState</span></span>
<span class="line"><span class="hljs-params">(</span>
<span class="line">    _In_  DWORD         dwUserIndex,  <span class="hljs-comment">// Index of the gamer associated with the device</span></span>
<span class="line">    _Out_ XINPUT_STATE* pState        <span class="hljs-comment">// Receives the current state</span></span>
<span class="line">)</span></span>;</span>
<span class="line"></span>
<span class="line"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">XInputSetState</span></span>
<span class="line"><span class="hljs-params">(</span>
<span class="line">    _In_ DWORD             dwUserIndex,  <span class="hljs-comment">// Index of the gamer associated with the device</span></span>
<span class="line">    _In_ XINPUT_VIBRATION* pVibration    <span class="hljs-comment">// The vibration information to send to the controller</span></span>
<span class="line">)</span></span>;</span>
<span class="line"></span></div></code></pre><center><div class="listingcaption tilde"><file>[xinput.h]</file></div></center>
<p>


We're going to flat-out get these ourselves. We'll try to load these functions without the Windows Executable Loader to do any of it. 

</p>
<a class="target" name="typedefinitionofthefunctions">&nbsp;</a><a class="target" name="directlibraryloading/typedefinitionofthefunctions">&nbsp;</a><a class="target" name="toc2.2">&nbsp;</a><h2>Type Definition of the Functions</h2>
<p>


We're going to copy-paste the function signatures we're interested in to our <code>win32_handmade.cpp</code> file, maybe clean them up first:

</p><pre class="listing tilde"><code><span class="line">global_variable win32_offscreen_buffer GlobalBackbuffer;</span><div class=" add"><span class="line"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">XInputGetState</span><span class="hljs-params">(DWORD dwUserIndex, XINPUT_STATE *pState)</span></span>;</span>
<span class="line"><span class="hljs-function">DWORD WINAPI <span class="hljs-title">XInputSetState</span><span class="hljs-params">(DWORD dwUserIndex, XINPUT_VIBRATION *pVibration)</span></span>;</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;7:</b> <file>[win32_handmade.cpp]</file> Adding XInput function signatures.</div></center>
<p>


Usually, leaving them at that would simply tell the compiler: &ldquo;there's an external function called this and that that you can bind against during the linker stage&rdquo;. This doesn't really help us: that's exactly what we had in <code>xinput.h</code> to begin with. 

</p><p>

However, if we change these into a <code>typedef</code>, we suddenly say: &ldquo;there is a function of this type, and I want to start declaring variables that are pointers to it&rdquo;. Think of our <code>Win32MainWindowCallback</code>: when we registered our <code>WindowClass</code>, we passed to it the <em class="underscore">pointer</em> to this function as a <em class="underscore">variable</em> (so that Windows could call us at a later stage). 

</p><p>

Because we don't want conflicts with the existing naming, we'll rename this type to something else, let's say <code>x_input_get_state</code> and <code>x_input_set_state</code>, respectively.

</p><pre class="listing tilde"><code><div class=" edit"><span class="line"><span class="hljs-comment">// Define a type of a function</span></span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">typedef</span> DWORD WINAPI <span class="hljs-title">x_input_get_state</span><span class="hljs-params">(DWORD dwUserIndex, XINPUT_STATE *pState)</span></span>;</span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">typedef</span> DWORD WINAPI <span class="hljs-title">x_input_set_state</span><span class="hljs-params">(DWORD dwUserIndex, XINPUT_VIBRATION *pVibration)</span></span>;</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;8:</b> <file>[win32_handmade.cpp]</file> Transforming signatures into types.</div></center>
<p>


We can declare variables of type <code>x_input_get_state</code> almost in the same manner you can declare an <code>u32</code>. But instead of <code>uint32_t</code>, the type of this thing is a function with that specific signature. OK, maybe in C you can't simply declare a variable <code>x_input_get_state GetState;</code>. That's illegal. But a pointer? No problem. (<code>x_input_get_state *GetState;</code>). And that's totally legal and is exactly what we want. 

</p><p>

So we can go ahead and declare a couple of these pointers, one per type: 

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line"><span class="hljs-comment">// Define a type of a function</span></span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">typedef</span> DWORD WINAPI <span class="hljs-title">x_input_get_state</span><span class="hljs-params">(DWORD dwUserIndex, XINPUT_STATE *pState)</span></span>;</span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">typedef</span> DWORD WINAPI <span class="hljs-title">x_input_set_state</span><span class="hljs-params">(DWORD dwUserIndex, XINPUT_VIBRATION *pVibration)</span></span>;</span></div><div class=" add"><span class="line"><span class="hljs-comment">// Create a pointer to function of this type</span></span>
<span class="line">global_variable x_input_get_state *XInputGetState; </span>
<span class="line">global_variable x_input_set_state *XInputSetState; </span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;9:</b> <file>[win32_handmade.cpp]</file> Transforming signatures into types.</div></center>
<p>


Unfortunately we run straight into the same problem as when we were <code>typedef</code>ing the functions: If we name something with the same name as in <code>xinput.h</code> header, the compiler is going to complain. So we have a few options: 

</p><p>

<ul>
<li class="asterisk">Name the global variables with something completely unique: <code>DynamicXInputGetState</code>, <code>HandmadeXInputGetState</code>.
</li>
<li class="asterisk">Go full-on C++ and set a different <code>namespace</code> for our program
</li>
<li class="asterisk">Simply remove the <code>xinput.h</code> header. This will force us however to copy over the struct definitions, as well. Might as well use this at some point.
</li>
<li class="asterisk">Or we could cheese our way into preserving the same name anyway.</li></ul>

</p><p>

Let's go crazy and try the last option. In order for this trick to work, this is what we need to do: 

</p><p>

<ol start=1>
<li class="number">Give our global variable a random name. <code>global... XInputGetState_</code>.
</li>
<li class="number"><code>#define</code> the name we want to use. <code>#define XInputGetState XInputGetState_</code>.
</li>
<li class="number">At the compile time, preprocessor will translate any <code>XInputGetState</code> it encounters into <code>XInputGetState_</code>. 
</li>
<li class="number">Repeat the same for <code>x_input_set_state</code>.</li></ol>

</p><p>

Thus we have no naming conflict and we don't run the risk of calling the function we don't want by mistake. 

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line"><span class="hljs-comment">// Define a type of a function</span></span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">typedef</span> DWORD WINAPI <span class="hljs-title">x_input_get_state</span><span class="hljs-params">(DWORD dwUserIndex, XINPUT_STATE *pState)</span></span>;</span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">typedef</span> DWORD WINAPI <span class="hljs-title">x_input_set_state</span><span class="hljs-params">(DWORD dwUserIndex, XINPUT_VIBRATION *pVibration)</span></span>;</span></div><div class=" edit"><span class="line"><span class="hljs-comment">// Create a pointer to function of this type</span></span>
<span class="line">global_variable x_input_get_state *XInputGetState_; </span>
<span class="line">global_variable x_input_set_state *XInputSetState_; </span></div><div class=" add"><span class="line"><span class="hljs-comment">// Create an "alias" to be able to call it with its old name</span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> XInputGetState XInputGetState_ </span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> XInputSetState XInputSetState_ </span></span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;10:</b> <file>[win32_handmade.cpp]</file> Cheesing our way to using the name we want.</div></center>

<a class="target" name="createstubfunctions">&nbsp;</a><a class="target" name="directlibraryloading/createstubfunctions">&nbsp;</a><a class="target" name="toc2.3">&nbsp;</a><h2>Create Stub Functions</h2>
<p>


Now you should be able to compile your program. Action we've taken will resolve the linker error, even if the <code>XInputGetState</code> call in <code>WinMain</code> never went anywhere. That function is now actually <code>#define</code>d to be <code>XInputGetState_</code>, and it will call a function pointer. 

</p><p>

However, if we try to run, we will get an Access Execution Violation while trying to run <code>XInputGetState</code>(<code>_</code>). 

</p><p>

We've discussed Access Violations in the <a href="day5.html">previous chapter</a>. These happen when we try to read from a pointer addressing invalid (unaccessible) memory. Access Execution Violation is different in that not only it tries to read (or write) a page, but also to <em class="underscore">call the code</em> on it.

</p><p>

We defined <code>XInputGetState</code> and <code>SetState</code> as global variable function pointers. And being a <code>static</code> global variable, they are cleared to <code>0</code>, so in fact by calling <code>XInputGetState</code> we try to access and execute a function located at the address <code>0</code>. And that's very much illegal. 

</p><p>

Now let's think for a moment. We started this whole process to make sure that our program <em class="underscore">doesn't</em> crash if it fails to load XInput <code>.dll</code>. And, as we're right now, we will crash anyway unless we load the correct function. Therefore, we need to define a dummy, a stub function to call if we can't load the correct one. For this to work, our stub has to have the same <em class="underscore">function signature</em> as the real thing. 

</p><p>

<div class="admonition ">You can read about how the function signatures actually defined in subsection  <a href="#toc6.1">6.1</a>.</div>

</p><p>

We can simply copy and paste the same <code>DWORD WINAPI blablabla</code> but it's ugly and prone to error. Also, if we ever want to update that signature, we need to update it in all locations. Alternatively, we can step up our compiler preprocessor game even further, and <code>#define</code> a function of this exact signature. 

</p><p>

If you use the form <code>#define NAME(param)</code> you can use one or more <code>param</code>s you <code>#define</code> inside your macro. In the example we've seen, <code>#define Square(number)</code> allows us to define a macro like <code>(number * number)</code>. It's almost like a function, but not. 

</p><p>

<div class="admonition warning"><div class="admonition-title"> Warning</div>

</p><p>

    That said, do not use <code>#define</code> when a function can do the same job!</div>

</p><p>

We <a href="day3.html">talked about it</a> before but never really saw it in action. let's do this now! Let's create a <code>#define</code> which would create a new function with that return type, provided <code>name</code>, and specific signature each time we call that macro. Remember <em class="underscore">not</em> to put the semicolon at the end!

</p><p>

We will then define our <code>typedef</code> in terms of that macro. 

</p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-comment">// Define a function macro</span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X_INPUT_GET_STATE(name) DWORD WINAPI name(DWORD dwUserIndex, XINPUT_STATE *pState)</span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X_INPUT_SET_STATE(name) DWORD WINAPI name(DWORD dwUserIndex, XINPUT_VIBRATION *pVibration)</span></span></div><div class=" edit"><span class="line"><span class="hljs-comment">// Define a type of a function</span></span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">X_INPUT_GET_STATE</span><span class="hljs-params">(x_input_get_state)</span></span>;</span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">X_INPUT_SET_STATE</span><span class="hljs-params">(x_input_set_state)</span></span>;</span></div><div class=" C++ "><span class="line">global_variable ...</span>
<span class="line">#define ...</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;11:</b> <file>[win32_handmade.cpp]</file> Defining a function prototype.</div></center>
<p>


Now we can also create our stub function! It does nothing and simply returns <code>ERROR_DEVICE_NOT_CONNECTED</code>. We will name our functions <code>XInputGetStateStub</code> and <code>XInputSetStateStub</code>, respectively. We will also assign these stubs as the default value of the global variables.

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X_INPUT_SET_STATE(name) ...</span></span>
<span class="line"><span class="hljs-keyword">typedef</span> X_INPUT_SET_STATE... </span></div><div class=" add"><span class="line">X_INPUT_GET_STATE(XInputGetStateStub) </span>
<span class="line">{ </span>
<span class="line">    <span class="hljs-keyword">return</span> (ERROR_DEVICE_NOT_CONNECTED); </span>
<span class="line">}</span>
<span class="line">X_INPUT_SET_STATE(XInputSetStateStub) </span>
<span class="line">{ </span>
<span class="line">    <span class="hljs-keyword">return</span> (ERROR_DEVICE_NOT_CONNECTED); </span>
<span class="line">}</span></div><div class=" edit"><span class="line">global_variable x_input_get_state *XInputGetState_ = XInputGetStateStub; </span>
<span class="line">global_variable x_input_set_state *XInputSetState_ = XInputSetStateStub; </span></div><div class=" C++ "><span class="line">#define ...</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;12:</b> <file>[win32_handmade.cpp]</file> Defining function stubs.</div></center>
<p>


We hope that you can see what we did there. For each of our two calls: 

</p><p>

<ol start=1>
<li class="number">We defined a function prototype. 
</li>
<li class="number">Defined a type of that, so that you can use it from now on as a pointer. 
</li>
<li class="number">Created a stub function to use in case we fail to properly load the actual functions.
</li>
<li class="number">Set up a permanent reference for the function of that type in a global variable. By default it points to the stub function.
</li>
<li class="number">Defined the same name as the original function for that variable.</li></ol>

</p><p>

To make things a bit clearer, let's group the two calls together to map exactly to these steps: 

</p><pre class="listing tilde"><code><div class=" edit"><span class="line"><span class="hljs-comment">// NOTE(casey): XInputGetInputState</span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X_INPUT_GET_STATE(name) DWORD WINAPI name(DWORD dwUserIndex, XINPUT_STATE *pState)</span></span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">X_INPUT_GET_STATE</span><span class="hljs-params">(x_input_get_state)</span></span>;</span>
<span class="line">X_INPUT_GET_STATE(XInputGetStateStub) </span>
<span class="line">{ </span>
<span class="line">    <span class="hljs-keyword">return</span> (ERROR_DEVICE_NOT_CONNECTED); </span>
<span class="line">}</span>
<span class="line">global_variable x_input_get_state *XInputGetState_ = XInputGetStateStub;</span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> XInputGetState XInputGetState_</span></span>
<span class="line"></span>
<span class="line"><span class="hljs-comment">// NOTE(casey): XInputSetInputState</span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> X_INPUT_SET_STATE(name) DWORD WINAPI name(DWORD dwUserIndex, XINPUT_VIBRATION *pVibration)</span></span>
<span class="line"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">X_INPUT_SET_STATE</span><span class="hljs-params">(x_input_set_state)</span></span>;</span>
<span class="line">X_INPUT_SET_STATE(XInputSetStateStub) </span>
<span class="line">{  </span>
<span class="line">    <span class="hljs-keyword">return</span> (ERROR_DEVICE_NOT_CONNECTED); </span>
<span class="line">}</span>
<span class="line">global_variable x_input_set_state *XInputSetState_ = XInputSetStateStub;</span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> XInputSetState XInputSetState_</span></span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;13:</b> <file>[win32_handmade.cpp]</file> Regrouping the supports per function.</div></center>
<p>


Now, if you compile and run, you should <em class="underscore">not</em> crash and just do what you used to do. Furthermore, if you step into <code>XInputGetState</code> inside your <code>WinMain</code>, you will jump into your stub function, return your error and continue. 

</p><p>

<div class="admonition note">All this is a good practice to initialize function pointers in general. By pointing to a stub, if you never end up initializing them, you'll still be able to continue your program's execution where possible.</div>

</p>
<a class="target" name="loadxinputlibrary">&nbsp;</a><a class="target" name="directlibraryloading/loadxinputlibrary">&nbsp;</a><a class="target" name="toc2.4">&nbsp;</a><h2>Load XInput Library</h2>
<p>


We laid down the groundwork, now let's do the thing! We will try to get XInput. If we succeed, we'll change our function pointers, if we don't, we simply proceed with the stubs. Let's start off with defining a new function. We don't expect to need anything nor return anything for it.

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line">// XInput <span class="hljs-meta">function</span> definitions above</span>
<span class="line"></span></div><div class=" add"><span class="line"><span class="hljs-function">internal <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32LoadXInput</span><span class="hljs-params">()</span></span>
<span class="line"></span>{</span>
<span class="line">}</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;14:</b> <file>[win32_handmade.cpp]</file> Initializing the library-loading function.</div></center>
<p>


Inside <code>Win32LoadXInput</code>, We are going to essentially do the same steps that the Windows <a href="https://en.wikipedia.org/wiki/Loader_(computing)">loader</a> does. As the first step, it will mean calling <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibraryA</a>, which loads the loads a <code>.dll</code>, the thing that Windows uses when it gives us functions. 

</p><p>

<code>LoadLibrary</code> takes only a filename, which is the name of the <code>.dll</code> we're trying to load, and that's going to give us back a module, simply a handle to our code not dissimilar to what <code>HINSTANCE</code> was. This will be our <code>XInputLibrary</code>.

</p><p>

Assuming that we get back a valid library (that is, a non-zero handle), we're going to load functions out of it, <code>XInputGetState</code> and <code>XInputSetState</code>. The function that will take care of that is called <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>, and we'll see how it works in a second.

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line"><span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32LoadXInput</span>(<span class="hljs-params"></span>)</span></span>
<span class="line">{</span>
<span class="line">    HMODULE XInputLibrary = LoadLibraryA(<span class="hljs-string">""</span>); </span></div><div class=" add"><span class="line">    <span class="hljs-keyword">if</span>(XInputLibrary)</span>
<span class="line">    {</span>
<span class="line">        XInputGetState = GetProcAddress();</span>
<span class="line">        XInputSetState = GetProcAddress();</span>
<span class="line">    }</span></div><span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;15:</b> <file>[win32_handmade.cpp]</file> Drafting out <code>Win32LoadXInput</code></div></center>
<p>


Now, to filling out the details. As the <a href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/nf-xinput-xinputgetstate">documentation</a> for <code>XInputGetState</code> says, we need one of the following libraries: &ldquo;Xinput1_3.dll&rdquo;, &ldquo;Xinput1_4.dll&rdquo; or &ldquo;Xinput9_1_0.dll&rdquo;. You can see more details on?.

</p><p>

Since &ldquo;Xinput1_3.dll&rdquo; should be available on most machines, let's start with it. <code>LoadLibraryA</code> will go through a series of steps to try and find the <code>.dll</code> you requested it and, if found, will try to load it.

</p><p>

<div class="admonition ">To learn more about how the system looks for a <code>.dll</code>, check out the <a href="https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a> article on MSDN.</div>

</p><p>

If the library is loaded and we get a valid handle, we'll pass it into the <code>GetProcAddress</code>. 

</p><p>

<code>GetProcAddress</code>, on the other hand, requires a module handle and the name of a function to get. This function does exactly what it says to do: it returns the address of a procedure (function). We're trying to get <code>XInputGetState</code> and <code>XInputSetState</code>, so we pass these along.

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line"><span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32LoadXInput</span>(<span class="hljs-params"></span>)</span></span>
<span class="line">{</span></div><div class=" edit"><span class="line">    HMODULE XInputLibrary = LoadLibraryA(<span class="hljs-string">"Xinput1_3.dll"</span>); </span></div><span class="line">    <span class="hljs-keyword">if</span>(XInputLibrary)</span>
<span class="line">    {</span><div class=" edit"><span class="line">        XInputGetState = GetProcAddress(XInputLibrary, <span class="hljs-string">"XInputGetState"</span>);</span>
<span class="line">        XInputSetState = GetProcAddress(XInputLibrary, <span class="hljs-string">"XInputSetState"</span>);</span></div><span class="line">    }</span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;16:</b> <file>[win32_handmade.cpp]</file> Loading functions to our variables, draft</div></center>
<p>


If you try and compile now, you will notice that the compiler will throw errors at you. This is because <code>GetProcAddres</code> doesn't know which function signature it's loading. It can load anything, and returns what basically is a <code>void *</code>, a pointer to memory. So we need to <em class="underscore">cast</em> the return of this to the type that we actually want. Luckily we know exactly what type do we want, so it's pretty easy. 

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line"><span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32LoadXInput</span>(<span class="hljs-params"></span>)</span></span>
<span class="line">{</span>
<span class="line">    HMODULE XInputLibrary = LoadLibraryA(<span class="hljs-string">"Xinput1_3.dll"</span>); </span>
<span class="line">    <span class="hljs-keyword">if</span>(XInputLibrary)</span>
<span class="line">    {</span></div><div class=" edit"><span class="line">        XInputGetState = (x_input_get_state *)GetProcAddress(XInputLibrary, <span class="hljs-string">"XInputGetState"</span>);</span>
<span class="line">        XInputSetState = (x_input_set_state *)GetProcAddress(XInputLibrary, <span class="hljs-string">"XInputSetState"</span>);</span></div><span class="line">    }</span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;17:</b> <file>[win32_handmade.cpp]</file> Fixing the compiler errors.</div></center>
<p>


Now, someone's machine might not have one <code>Xinput</code> version but have another. So we could attempt to load one <code>.dll</code>, if it fails try to load another... until finally there're no <code>.dll</code>s that we're aware of. This gives us more chances to load <em class="underscore">anything</em>. Let's start from the most recent version (<code>1_4</code>) and go down through <code>1_3</code> and <code>9_1_0</code>:

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line"><span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">void</span></span>
<span class="line"><span class="hljs-title">Win32LoadXInput</span>(<span class="hljs-params"></span>)</span></span>
<span class="line">{</span></div><div class=" edit"><span class="line">    HMODULE XInputLibrary = LoadLibraryA(<span class="hljs-string">"Xinput1_4.dll"</span>); </span></div><div class=" add"><span class="line">    <span class="hljs-keyword">if</span> (!XInputLibrary)</span>
<span class="line">    {</span>
<span class="line">        XInputLibrary = LoadLibraryA(<span class="hljs-string">"Xinput1_3.dll"</span>); </span>
<span class="line">    }</span>
<span class="line">    <span class="hljs-keyword">if</span> (!XInputLibrary)</span>
<span class="line">    {</span>
<span class="line">        XInputLibrary = LoadLibraryA(<span class="hljs-string">"Xinput9_1_0.dll"</span>); </span>
<span class="line">    }</span></div><span class="line"></span>
<span class="line">    <span class="hljs-keyword">if</span>(XInputLibrary)</span>
<span class="line">    {</span>
<span class="line">        XInputGetState = (x_input_get_state *)GetProcAddress(XInputLibrary, <span class="hljs-string">"XInputGetState"</span>);</span>
<span class="line">        XInputSetState = (x_input_set_state *)GetProcAddress(XInputLibrary, <span class="hljs-string">"XInputSetState"</span>);</span>
<span class="line">    }</span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;18:</b> <file>[win32_handmade.cpp]</file> Checking for multiple versions</div></center>
<p>


We are now compiling, but we won't even attempt to load the file unless you ask it to! Simply add the call to <code>Win32LoadXInput</code> somewhere on top of your <code>WinMain</code>: 

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> CALLBACK</span>
<span class="line"><span class="hljs-title">WinMain</span><span class="hljs-params">(...)</span></span>
<span class="line"></span>{</span></div><div class=" add"><span class="line">    Win32LoadXInput();</span></div><div class=" C++ "><span class="line">    // ... </span>
<span class="line">}</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;19:</b> <file>[win32_handmade.cpp]</file> Fixing the compiler errors.</div></center>

<a class="target" name="inspectlibraryloading">&nbsp;</a><a class="target" name="directlibraryloading/inspectlibraryloading">&nbsp;</a><a class="target" name="toc2.5">&nbsp;</a><h2>Inspect Library Loading</h2>
<p>


Let's inspect if what we did works correctly. Compile another time, open your debugger and set a breakpoint at the start of <code>Win32LoadXInput</code>. Hit <code>F5</code> to get until your breakpoint and start debugging: 

</p><p>

<ol start=1>
<li class="number">We attempt to load the library <code>xinput1_3.dll</code>. 
</li>
<li class="number">If you have it on your machine (and it loaded correctly), you start loading the function pointers.
</li>
<li class="number">If they load correctly, you will see in the Watch window the address to change from your stub function to the correct one. 
<ul>
    <li class="asterisk">Additionally, in Visual Studio debugger you will even see that these functions are loaded from <code>xinput1_3.dll</code>.
</li>
    <li class="asterisk">Remember that, in the debugger, <code>#define</code>s are not captured! You'll need to search for <code>XInputGetState_</code> and <code>XInputSetState_</code> variables.</li></ul></li></ol>

</p>
<a class="target" name="addinteractivity">&nbsp;</a><a class="target" name="directlibraryloading/addinteractivity">&nbsp;</a><a class="target" name="toc2.6">&nbsp;</a><h2>Add Interactivity</h2>
<p>


Assuming you have a controller connected to your machine, at each loop the game will try to read the controller state. Let's do something fun and use the controller state to move our gradient! For instance, we can move it upwards each time you press the <code>A</code> button on your controller. 

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line"><span class="hljs-comment">// Assigning input reads to various variables</span></span>
<span class="line">s16 StickY = Pad-&gt;sThumbLY;</span></div><div class=" add"><span class="line"><span class="hljs-keyword">if</span> (AButton)</span>
<span class="line">{</span>
<span class="line">    YOffset += <span class="hljs-number">2</span>;</span>
<span class="line">}</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;20:</b> <file>[win32_handmade.cpp > WinMain]</file> Adding some interactivity.</div></center>
<p>


If you compile and test now, each time you push the <code>A</code> button on your controller the grid moves up! 

</p><p>

We can go even full crazy and bind the movement of our grid directly to the stick. We just need to tone it down <em class="underscore">quite</em> significantly by shifting the stick value down.

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line"><span class="hljs-comment">// Assigning input reads to various variables</span></span>
<span class="line">s16 StickY = Pad-&gt;sThumbLY;</span></div><div class=" edit"><span class="line">XOffset += StickX &gt;&gt; <span class="hljs-number">12</span>;</span>
<span class="line">YOffset += StickY &gt;&gt; <span class="hljs-number">12</span>;</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;21:</b> <file>[win32_handmade.cpp > WinMain]</file> Adding more interactivity.</div></center>
<p>


Look at code you've just written, and you'll see there's not a lot of it. Even further than that, we went the hard way and fetched all the functions ourselves.

</p><p>

That's a benefit of a good API. XInput has a few annoying things about itself, but look how easy it is to program it!

</p>
<a class="target" name="testvibration">&nbsp;</a><a class="target" name="directlibraryloading/testvibration">&nbsp;</a><a class="target" name="toc2.7">&nbsp;</a><h2>Test Vibration</h2>
<p>


Let's go and quickly make sure that the vibration works properly, as well. <code>XInputSetState</code> takes the controller ID and a pointer to the <code>XINPUT_VIBRATION</code> struct. The latter is simply two <code>WORD</code>s (unsigned 16-bit integers) which allows to set the left and right motor speed.

</p><p>

Add the following code just outside your controller loop:

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line"><span class="hljs-keyword">for</span> (DWORD ControllerIndex = <span class="hljs-number">0</span>; <span class="hljs-keyword">...</span>)</span>
<span class="line">{</span>
<span class="line">    // <span class="hljs-keyword">...</span></span>
<span class="line">}</span></div><div class=" add"><span class="line">XINPUT_VIBRATION Vibration;</span>
<span class="line">Vibration.wLeftMotorSpeed = <span class="hljs-number">60000</span>;</span>
<span class="line">Vibration.wRightMotorSpeed = <span class="hljs-number">60000</span>;</span>
<span class="line">XInputSetState(<span class="hljs-number">0</span>, &amp;Vibration);</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;22:</b> <file>[win32_handmade.cpp > WinMain]</file> Adding rumble.</div></center>

<a class="target" name="keyboardinput">&nbsp;</a><a class="target" name="keyboardinput">&nbsp;</a><a class="target" name="toc3">&nbsp;</a><h1>Keyboard Input</h1>
<p>


In our game, we'd like to handle keyboard input as well, not only a controller. Not everyone has a controller! 

</p><p>

Luckily, handling basic keyboard messages is even simpler than XInput. There is a thing called <a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/raw-input">Raw Input</a> which allows to fetch more advanced input, multiple keyboards, etc. It's definitely something much more complex, and we'll handle it much later down the line. In the meantime, let's focus on the simple thing. 

</p><p>

Unlike XInput, keyboard is handled directly in the <code>Win32MainWindowCallback</code>, alongside the other messages. You don't need to register anything, it <em class="underscore">just happens</em>. 

</p><p>

The messages that we're looking for are <code>WM_SYSKEYDOWN, WM_SYSKEYUP, WM_KEYDOWN</code> and <code>WM_KEYUP</code>. Before they were eaten up by <code>DefWindowProc</code>, but now we'll start handling them. Since we'll be handling them all together, we can &ldquo;stack&rdquo; them one on top the other so that they will all handle the same <code>switch</code> block.

</p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-keyword">case</span> WM_SYSKEYDOWN:</span>
<span class="line"><span class="hljs-keyword">case</span> WM_SYSKEYUP:</span>
<span class="line"><span class="hljs-keyword">case</span> WM_KEYDOWN:</span>
<span class="line"><span class="hljs-keyword">case</span> WM_KEYUP:</span>
<span class="line">{</span>
<span class="line">    <span class="hljs-comment">// Handle keyboard messages here</span></span>
<span class="line">}</span></div><span class="line"><span class="hljs-keyword">case</span> WM_PAINT: </span>
<span class="line">{</span>
<span class="line">    <span class="hljs-comment">//... </span></span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;23:</b> <file>[win32_handmade.cpp > Win32MainWindowCallback]</file> Adding a case for keyboard messages processing.</div></center>

<a class="target" name="virtual-keycodes">&nbsp;</a><a class="target" name="keyboardinput/virtual-keycodes">&nbsp;</a><a class="target" name="toc3.1">&nbsp;</a><h2>Virtual-Key Codes</h2>
<p>


In order to process our message, we need to make use of the <code>WParam</code> and <code>LParam</code> values. This is the first case when we will make use of the mysterious <code>WParam</code> or <code>LParam</code> that we get alongside our message, so let's dive a bit into them. 

</p><p>

The names <code>WParam</code> and <code>LParam</code>, as it is usual on Windows, have historic reason. Very simply, <code>WParam</code> was a <code>WORD</code> long (16 bits), while the <code>LParam</code> was a <code>LONG</code> long (32 bits). Now there's no practical distinction. Both of these are now pointer long (so 64 bit on 64-bit systems), albeit <code>LParam</code> being signed while the <code>WParam</code> isn't, and are used in a variety of ways, depending on the message. 

</p><p>

Both of these will be useful for the purposes of translating our keyboard message, so let's look at the <code>WParam</code> first. 

</p><p>

<code>WParam</code> represents the <em class="underscore">Virtual-Key Code</em> of the key pressed. We can actually capture store it as <code>VKCode</code> for clarity. Testing if the key is one of the letters is super simple - every (standard latin) letter maps direclty to the correspondent capital letter in ASCII. 

</p><p>

Let's quickly throw down a test for <code>W, A, S</code> and <code>D</code>. We will simply check if the code corresponds to a character and, if so, output it to the console. Note that we must use single quotes (<code>'</code>) to get a single <code>char</code> value, while to <code>OutputDebugStringA</code> we pass a C string, in double quotes (<code>&quot;</code>).

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">case</span> WM_SYSKEYDOWN:</span>
<span class="line"><span class="hljs-keyword">case</span> WM_SYSKEYUP:</span>
<span class="line"><span class="hljs-keyword">case</span> WM_KEYDOWN:</span>
<span class="line"><span class="hljs-keyword">case</span> WM_KEYUP:</span>
<span class="line">{</span><div class=" add"><span class="line">    u32 VKCode = WParam;</span>
<span class="line"></span>
<span class="line">    <span class="hljs-keyword">if</span> (VKCode == <span class="hljs-string">'W'</span>)</span>
<span class="line">    {</span>
<span class="line">        OutputDebugStringA(<span class="hljs-string">"W\n"</span>);</span>
<span class="line">    } </span>
<span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VKCode == <span class="hljs-string">'A'</span>)</span>
<span class="line">    {</span>
<span class="line">        OutputDebugStringA(<span class="hljs-string">"A\n"</span>);</span>
<span class="line">    } </span>
<span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VKCode == <span class="hljs-string">'S'</span>)</span>
<span class="line">    {</span>
<span class="line">        OutputDebugStringA(<span class="hljs-string">"S\n"</span>);</span>
<span class="line">    } </span>
<span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VKCode == <span class="hljs-string">'D'</span>)</span>
<span class="line">    {</span>
<span class="line">        OutputDebugStringA(<span class="hljs-string">"D\n"</span>);</span>
<span class="line">    } </span></div><span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;24:</b> <file>[win32_handmade.cpp > Win32MainWindowCallback]</file> Testing input from letters.</div></center>
<p>


If you compile and run, you should see the corresponding messages appear in the <code>Output</code> console when you hit the keys! Make sure your program is in focus (and not the debugger).

</p><p>

<div class="admonition ">Keep in mind that, if you use a non-latin keyboard (for instance, Russian), the ASCII keys codes will be mapped to the ANSI Keyboard Layout.

</p><p>

    <center><div class="image" style=""><a href="../media/day6/ansi_keyboard.svg" target="_blank"><img class="markdeep" src="../media/day6/ansi_keyboard.svg" /></a><center><span class="imagecaption"><a class="target" name="figure_x">&nbsp;</a><b style="font-style:normal;">Figure&nbsp;2:</b> ANSI Keyboard Layout Diagram. Percentages and relevant values of keys denote the presence of keys at common keyboard sizes. (<a href="https://commons.wikimedia.org/wiki/File:ANSI_Keyboard_Layout_Diagram_with_Form_Factor.svg">Wikimedia</a>)</span></center></div></center>

</p><p>

    However, if you use an AZERTY, QWERTZ or another non-ANSI latin-script keyboard layout, your key position will correspond to the key location in your layout.</div>

</p><p>

As for the non-letter characters (the arrows, spacebar, etc.), each of those has a corresponding virtual code symbol defined. You will find these <a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes">on MSDN</a>. 

</p><p>

We can imagine that, for now, we'll want our game to handle the following keys: <code>W</code>, <code>A</code>, <code>S</code>, <code>D</code>, <code>Q</code>, <code>E</code>, <code>VK_UP</code>, <code>VK_DOWN</code>, <code>VK_LEFT</code>, <code>VK_RIGHT</code>, <code>VK_ESCAPE</code> and <code>VK_SPACE</code>.

</p><p>

Let's quickly stub these into our program. We won't do anything with them today as it's a topic for another day. Let's also remove our test strings for now.

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line"><span class="hljs-built_in">u32</span> VKCode = WParam;</span>
<span class="line"></span>
<span class="line"><span class="hljs-keyword">if</span> (VKCode == <span class="hljs-string">'W'</span>)</span>
<span class="line">{</span></div><div class=" delete"><span class="line">    OutputDebugStringA(<span class="hljs-string">"W\n"</span>);</span></div><span class="line">} </span>
<span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VKCode == <span class="hljs-string">'A'</span>)</span>
<span class="line">{</span><div class=" delete"><span class="line">    OutputDebugStringA(<span class="hljs-string">"A\n"</span>);</span></div><div class=" C++ "><span class="line">} </span>
<span class="line">else if (VKCode == 'S')</span>
<span class="line">{</span></div><div class=" delete"><span class="line">    OutputDebugStringA(<span class="hljs-string">"S\n"</span>);</span></div><div class=" C++ "><span class="line">} </span>
<span class="line">else if (VKCode == 'D')</span>
<span class="line">{</span></div><div class=" delete"><span class="line">    OutputDebugStringA(<span class="hljs-string">"D\n"</span>);</span></div><div class=" C++ "><span class="line">} </span></div><div class=" add"><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VKCode == <span class="hljs-string">'Q'</span>)</span>
<span class="line">{</span>
<span class="line">} </span>
<span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VKCode == <span class="hljs-string">'E'</span>)</span>
<span class="line">{</span>
<span class="line">} </span>
<span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VKCode == VK_UP)</span>
<span class="line">{</span>
<span class="line">} </span>
<span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VKCode == VK_DOWN)</span>
<span class="line">{</span>
<span class="line">} </span>
<span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VKCode == VK_LEFT)</span>
<span class="line">{</span>
<span class="line">} </span>
<span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VKCode == VK_RIGHT)</span>
<span class="line">{</span>
<span class="line">} </span>
<span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VKCode == VK_ESCAPE)</span>
<span class="line">{</span>
<span class="line">} </span>
<span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VKCode == VK_SPACE)</span>
<span class="line">{</span>
<span class="line">} </span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;25:</b> <file>[win32_handmade.cpp > Win32MainWindowCallback]</file> Stubbing keyboard messages of our interest.</div></center>

<a class="target" name="dissectlparam">&nbsp;</a><a class="target" name="keyboardinput/dissectlparam">&nbsp;</a><a class="target" name="toc3.2">&nbsp;</a><h2>Dissect LParam</h2>
<p>


Now, if you noticed, each time you pressed a <code>W</code> on your keyboard, you got two <code>W</code> messages to your console. This is because Windows sends us (and we capture) both the messages when the key was pressed, and when a key was released. That's perfect for our purposes. However, we can also check if the button was already down before the message fired. For that, we can use our <code>LParam</code>.

</p><p>

If you look the documentation for <a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/wm-keydown">WM_KEYDOWN</a>, you will see that the 32 bits of the <code>LParam</code> pack a lot of information. It's also a bit field. The first 16 bits are used to count how many repetions there were, the 24th bit is set if the &ldquo;Extended&rdquo; key has been hit (right-hand <code>ALT</code> or <code>CTRL</code>), etc. 

</p><p>

At this moment, we want to check if the <em class="underscore">30th bit</em> is set. This bit corresponds exactly to the state of the button before the message fired: if set to 1, the key was down before the message was sent, if zero, the key was up. We might do the same thing we did earlier above for the gamepad buttons, and <code>&amp;</code> it against some value provided by Windows. Unfortunatley, Windows does not provide a define for the 30th bit of the keyboard <code>LParam</code>, so we need to do some bit shifting:

</p><p>

We've seen bit shifting on <a href="day4.html">Day 4</a>, when we were shifting the red, green and blue bytes to their place inside the pixel. Our task is the following:

</p><p>

<ol start=1>
<li class="number">Shift a <code>1</code> by 30 to the &ldquo;left&rdquo;: <code>(1 &lt;&lt; 30)</code>
</li>
<li class="number">Use it to bitwise AND the <code>LParam</code>: <code>LParam &amp; (1 &lt;&lt; 30)</code>
</li>
<li class="number">If the resulting value is <code>0</code>, the bit #30 wasn't set.
</li>
<li class="number">We can store this value in a <code>bool</code>: <code>bool WasDown = LParam &amp; (1 &lt;&lt; 30)</code>.</li></ol>

</p><p>

We can leave it at that, but if <code>WasDown</code> is not <code>0</code> it will not be <code>1</code> but <code>1 &lt;&lt; 30</code> (<code>0x4000000</code> or <code>1073741824</code>). If we want a <code>0-1</code> pair, we can further check if that result is not equal to <code>0</code>: <code>bool WasDown = ((LParam &amp; (1 &lt;&lt; 30)) != 0)</code>.

</p><p>

Let's add this line at the beginning of our key processing section:

</p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-keyword">bool</span> WasDown = ((LParam &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>)) != <span class="hljs-number">0</span>);</span></div><span class="line">u32 VKCode = WParam;</span>
<span class="line"><span class="hljs-comment">// ... </span></span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;26:</b> <file>[win32_handmade.cpp > Win32MainWindowCallback]</file> Checking if the key was down.</div></center>
<p>




<div class="admonition ">All these parenthesis matter! Read more about the operator precedence in subsection  <a href="#toc6.2.3">6.2.3</a></div>

</p><p>

Similarly, we want to check if the key <em class="underscore">is</em> down right now, at the moment of the message submission. This is the &ldquo;Transition state&rdquo;, specified in the bit 31. However, contrary to the &ldquo;Previous key state&rdquo;, if the key is down, this bit will <em class="underscore">not</em> be set. So we must check if the bit in the <code>LParam</code> IS <code>0</code>:

</p><pre class="listing tilde"><code><div class=" add"><span class="line"><span class="hljs-keyword">bool</span> IsDown = ((LParam &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>)) == <span class="hljs-number">0</span>);</span></div><span class="line"><span class="hljs-keyword">bool</span> WasDown = ((LParam &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>)) != <span class="hljs-number">0</span>);</span>
<span class="line">u32 VKCode = WParam;</span>
<span class="line"><span class="hljs-comment">// ... </span></span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;27:</b> <file>[win32_handmade.cpp > Win32MainWindowCallback]</file> Checking if the key is down.</div></center>
<p>


As a quick test, let's add a few strings of text depending on whether or not the <code>VK_ESCAPE</code> key was pressed: 

</p><pre class="listing tilde"><code><div class=" C++ "><span class="line"><span class="hljs-comment">// Other key codes</span></span></div><div class=" add"><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (VKCode == VK_ESCAPE)</span>
<span class="line">{</span>
<span class="line">    OutputDebugStringA(<span class="hljs-string">"ESCAPE: "</span>);</span>
<span class="line">    <span class="hljs-keyword">if</span> (IsDown)</span>
<span class="line">    {</span>
<span class="line">        OutputDebugStringA(<span class="hljs-string">"IsDown "</span>);</span>
<span class="line">    }</span>
<span class="line">    <span class="hljs-keyword">if</span> (WasDown)</span>
<span class="line">    {</span>
<span class="line">        OutputDebugStringA(<span class="hljs-string">"WasDown"</span>);</span>
<span class="line">    }</span>
<span class="line">    OutputDebugStringA(<span class="hljs-string">"\n"</span>);</span>
<span class="line">}</span></div><span class="line"><span class="hljs-comment">// ... </span></span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;28:</b> <file>[win32_handmade.cpp > Win32MainWindowCallback]</file> Checking if the key is down.</div></center>
<p>




<div class="admonition tip">You might have noticed the <code>\n</code> symbol already. This is simply the &ldquo;new line&rdquo; character which tells the console to return to the new line.</div>

</p><p>

If you compile and run, you'll notice a pattern similar to this:
</p><pre class="listing tilde"><code><span class="line">ESCAPE: IsDown</span>
<span class="line">ESCAPE: WasDown</span>
<span class="line">ESCAPE: IsDown</span>
<span class="line">ESCAPE: WasDown</span>
<span class="line">ESCAPE: IsDown</span>
<span class="line">ESCAPE: WasDown</span>
<span class="line">ESCAPE: IsDown WasDown</span>
<span class="line">ESCAPE: IsDown WasDown</span>
<span class="line">ESCAPE: IsDown WasDown</span>
<span class="line">ESCAPE: WasDown</span></code></pre><p>

If you quickly hit and release <code>Escape</code> button, Windows will send two separate messages. One will have <code>IsDown</code> when the button is hit, and the other <code>WasDown</code> is released. However, if you hold <code>Escape</code> for a few seconds, Windows will start sending the <code>VK_ESCAPE</code> message again. It will remind you that the key is currently pressed, and was pressed the last time Windows has checked. Once you release the key, a final message with <code>WasDown</code> will be sent.

</p><p>

Now, we're not interested in the repeat messages. We want to prevent a situation when a button press is sent more than once, so we can just check if <code>WasDown</code> and <code>IsDown</code> are both <code>true</code>, and only proceed if they are not.

</p><p>

Now that we've captured them both, it's trivial: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">bool</span> IsDown = ((LParam &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>)) == <span class="hljs-number">0</span>);</span>
<span class="line"><span class="hljs-keyword">bool</span> WasDown = ((LParam &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>)) != <span class="hljs-number">0</span>);</span>
<span class="line">u32 VKCode = WParam;</span><div class=" add"><span class="line"><span class="hljs-keyword">if</span> (IsDown != WasDown)</span>
<span class="line">{</span>
<span class="line">    <span class="hljs-comment">// Deal with the key codes</span></span>
<span class="line">}</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;29:</b> <file>[win32_handmade.cpp > Win32MainWindowCallback]</file> Skipping the duplicate messages.</div></center>
<p>


If you recompile and run your program now, you will notice that it now only sends <code>IsDown</code> and <code>WasDown</code> messages separately, even if you hold <code>Escape</code> button for a few seconds.

</p>
<a class="target" name="addsomefunctionality">&nbsp;</a><a class="target" name="keyboardinput/addsomefunctionality">&nbsp;</a><a class="target" name="toc3.3">&nbsp;</a><h2>Add Some Functionality</h2>
<p>


To add some actual functionality, let's try to close our window with the usual <code>Alt-F4</code> combination. We can achieve it by simply setting <code>GlobalRunning</code> to false. But now a new question arises: how can we test for two keys at once? 

</p><p>

Let's say we primarily test for <code>VK_F4</code> key and get <code>Alt</code> value from somewhere else and stored in <code>AltKeyWasDown</code>:

</p><p>

if (IsDown != WasDown)
{
    // ...
    else if (VKCode == VK_SPACE)
    {
    }

</p><p>

    bool AltKeyWasDown = ???;
    if((VKCode == VK_F4) && AltKeyWasDown)
    {
        GlobalRunning = false;
    }
}
</p><pre class="listing tilde"><code><span class="line">[<span class="hljs-symbol">Listing [x</span>]: <span class="hljs-link">&lt;file&gt;[win32_handmade.cpp &gt; Win32MainWindowCallback]&lt;/file&gt; Skipping the duplicate messages.]</span></span>
<span class="line"></span>
<span class="line">How do we get the value of <span class="hljs-code">`Alt`</span>? Well for a [<span class="hljs-string">WM_SYSKEYDOWN</span>][<span class="hljs-symbol"></span>] message, such as <span class="hljs-code">`F4`</span>, it's actually much simpler since it sets the 29th bit of <span class="hljs-code">`LParam`</span>, and we know how to extract that!</span>
<span class="line"></span><div class=" edit"><span class="line"><span class="hljs-keyword">bool</span> AltKeyWasDown = ((LParam &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">29</span>)) != <span class="hljs-number">0</span>);</span></div><span class="line"><span class="hljs-keyword">if</span>((VKCode == VK_F4) &amp;&amp; AltKeyWasDown)</span>
<span class="line">{</span>
<span class="line">    GlobalRunning = <span class="hljs-literal">false</span>;</span>
<span class="line">}</span></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;30:</b> <file>[win32_handmade.cpp > Win32MainWindowCallback]</file> Skipping the duplicate messages.</div></center>

<a class="target" name="introduceb32typeinsteadofbool">&nbsp;</a><a class="target" name="keyboardinput/introduceb32typeinsteadofbool">&nbsp;</a><a class="target" name="toc3.4">&nbsp;</a><h2>Introduce <code>b32</code> type Instead of <code>bool</code></h2>
<p>


In C++, <code>bool</code> is defined with some odd semantics. It should be either <code>0</code> or <code>1</code> while remaining a 32-bit value. This is why, if you noticed, we had to go through the additional checks <code>!= 0</code> for our <code>LParam</code> bit extraction. 

</p><p>

If you were to remove it and compile with additional warnings enabled (<code>-Wall</code> in <code>cl</code> line of the <code>build.bat</code>), you would get a &ldquo;performance warning&rdquo;.

</p><p>

Truth is, quite often we don't care if the value is <code>1</code> or anything else rather than zero. Sure, for <code>IsDown</code> and <code>WasDown</code> we do, because we compare the two values right after, but in many places, like in <code>AltKeyWasDown</code> we won't. So we're actually wasting some time to do the comparison and properly convert to <code>bool</code>.

</p><p>

So what we'd do typically is to simply <code>typedef</code> our own type <code>b32</code> in the same vein we defined our integer types. This would be a simple <code>s32</code>, which in turn, as a reminder, is signed 32-bit integer. Let's add it just below the other ones: 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint8_t</span> u8;</span>
<span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint16_t</span> u16;</span>
<span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint32_t</span> u32;</span>
<span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">uint64_t</span> u64;</span>
<span class="line"></span>
<span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int8_t</span> s8;</span>
<span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int16_t</span> s16;</span>
<span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int32_t</span> s32;</span>
<span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int64_t</span> s64;</span>
<span class="line"></span><div class=" add"><span class="line"><span class="hljs-keyword">typedef</span> s32 b32;</span></div></code></pre><center><div class="listingcaption tilde"><a class="target" name="listing_x">&nbsp;</a><b style="font-style:normal;">Listing&nbsp;31:</b> <file>[win32_handmade.cpp]</file> Adding a new <code>b32</code> type.</div></center>
<p>


By using this type, we basically say: &ldquo;I want this value to be 0 or non-zero&rdquo;. This means we can change our <code>AltKeyWasDown</code> to this: 

</p><pre class="listing tilde"><code><div class=" edit"><span class="line">b32 AltKeyWasDown = (LParam &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">29</span>));</span></div></code></pre>
<a class="target" name="recap">&nbsp;</a><a class="target" name="recap">&nbsp;</a><a class="target" name="toc4">&nbsp;</a><h1>Recap</h1>
<p>


And this is it! We're now capturing the input from keyboard and controllers. We aren't doing anything with it, besides closing our window. Everything that we're doing is just sketching out our future territory.

</p><p>

Tomorrow we will embark on the journey of getting the sound working. It will be a tougher nut to crack than anything we've dealt with so far!

</p>
<a class="target" name="exercises">&nbsp;</a><a class="target" name="exercises">&nbsp;</a><a class="target" name="toc5">&nbsp;</a><h1>Exercises</h1>

<a class="target" name="convertkeyboardkeyprocessingtoaswitchstatement">&nbsp;</a><a class="target" name="exercises/convertkeyboardkeyprocessingtoaswitchstatement">&nbsp;</a><a class="target" name="toc5.1">&nbsp;</a><h2>Convert Keyboard Key Processing to a <code>switch</code> Statement</h2>
<p>


You will notice that our key code processing uses quite a long <code>if</code> chain. Try to convert it to a <code>switch</code> statement similar to our message processing! No need to have a <code>default</code> case here.

</p>
<a class="target" name="trytodosomethingwiththekeybordinput">&nbsp;</a><a class="target" name="exercises/trytodosomethingwiththekeybordinput">&nbsp;</a><a class="target" name="toc5.2">&nbsp;</a><h2>Try to do something with the keybord input</h2>
<p>


Experiment with the keyboard buttons available! Maybe hitting a button will affect your gradient? Something else? It'll be a bit more complicated than using XInput since it's not captured in your <code>WinMain</code>! 

</p>
<a class="target" name="programmingnotions">&nbsp;</a><a class="target" name="programmingnotions">&nbsp;</a><a class="target" name="toc6">&nbsp;</a><h1>Programming Notions</h1>

<a class="target" name="functionsignatures">&nbsp;</a><a class="target" name="programmingnotions/functionsignatures">&nbsp;</a><a class="target" name="toc6.1">&nbsp;</a><h2>Function Signatures</h2>
<p>


What is a function signature? We've talked about it a lot but never in detail. 

</p><p>

In C, a function signature is defined simply by the type of the parameters that function takes in. It serves as a validation (a signature, in fact), that the name defined outside and the call happening inside the code refer to the same entity. 

</p><p>

Why is this important? Well, among other things, to make sure that the parameters passed to the function correspond to the space allocated for them on the stack. 

</p><p>

It also enables defining functions as a type and passing them around. You don't even need the parameter names! For a function <code>int CalculateArea (int Width, int Height)</code>, it's signature is simply <code>(int,int)</code>. 

</p><p>

In C++, more factors come into play when defining a function signature, but the base definition used in C also works.

</p><p>

<em class="underscore">(Back to subsection  <a href="#toc2.3">2.3</a>)</em>

</p>
<a class="target" name="readinginputdevicesstate">&nbsp;</a><a class="target" name="programmingnotions/readinginputdevicesstate">&nbsp;</a><a class="target" name="toc6.2">&nbsp;</a><h2>Reading Input Devices State</h2>
<p>


There are two main ways of reading input from an input device (controller, mouse, keyboard, etc.). There's <a href="https://en.wikipedia.org/wiki/Interrupt">Interrupt</a> and there's <a href="https://en.wikipedia.org/wiki/Polling_(computer_science)">Polling</a>. 

</p>
<a class="target" name="interrupt">&nbsp;</a><a class="target" name="programmingnotions/readinginputdevicesstate/interrupt">&nbsp;</a><a class="target" name="toc6.2.1">&nbsp;</a><h3>Interrupt</h3>
<p>


An interrupt-based scheme is driven by the external device itself. Whenever the device needs to tell you that something happened (a button got pressed, a stick wiggled), it will send the processor a <em class="underscore">trigger signal</em>. This, depending on the type of the interrupt, might or might not result in actually blocking whatever the processor was doing and reacting to that interrupt. 

</p><p>

Eventually the operating system is notified, which communicates the interrupt to the interested application/s and therefore to the user. We've seen these under the form of Windows Messages.

</p><p>

The big thing about the interrupts that they are useful only when in low quantity. The more interrupts the system receives, the more time the system gets to cycle through all of them, eventually arriving to a so-called <a href="https://en.wikipedia.org/wiki/Interrupt_storm">Interrupt storm</a> where the processor ends up spending most of its time processing all the interrupts.

</p><p>

Interrupts were used a lot more historically, and is still used to push mouse or keyboard input. A modern adaptation of the hardware interrupt system are the data interrupts, when the data is packaged and sent through, for instance, Ethernet. However, rather being an actual hardware interrupts, these packets get buffered up and become a <em class="underscore">stream</em> of data which you read, rather than be interrupted by a single event. 

</p>
<a class="target" name="polling">&nbsp;</a><a class="target" name="programmingnotions/readinginputdevicesstate/polling">&nbsp;</a><a class="target" name="toc6.2.2">&nbsp;</a><h3>Polling</h3>
<p>


A polling operation is a synchronous activity, where the program &ldquo;syncs up&rdquo; and checks the state of the input hardware at that particular moment. Whereby the interrupt is triggered by the input device, polling is initialized by the application, usually at regular intervals. This results in <em class="underscore">sampling</em> of the state of the device over time.

</p><p>

The disadvantage of polling is somewhat inverse to that of the interrupts. Interrupts allow for having many &ldquo;relatively quiet&rdquo; devices connected to it, while potentially suffering from their activity. Polling allows to have an extremely busy device (think of all the button mashing on a game controller) while potentially suffering if the system has many devices to poll.

</p><p>

<em class="underscore">(Back to subsection ?)</em>

</p>
<a class="target" name="operatorprecedence">&nbsp;</a><a class="target" name="programmingnotions/readinginputdevicesstate/operatorprecedence">&nbsp;</a><a class="target" name="toc6.2.3">&nbsp;</a><h3>Operator Precedence</h3>
<p>


As in basic arithmetics, in C certain operators will take precendence over the other. Thus, multiplication happens before addition, division before substraction.... Well, the same is true for any other operator in C and C++. If we look at the code

</p><p>

<code>LParam &amp; 1 &lt;&lt; 30 != 0;</code>

</p><p>

we see the operators <code>&amp;</code>, <code>&lt;&lt;</code> and <code>!=</code>, and they all are executed in a certain order. Same as in arithmetics, in order to prevent any ambiguity on what comes first, wrapping things in parenthesis prevents this issue altogether. 

</p><p>

<code>((LParam &amp; (1 &lt;&lt; 30)) != 0);</code>

</p><p>

<em class="underscore">(Back to subsection  <a href="#toc3.2">3.2</a>)</em>

</p>
<a class="target" name="sideconsiderations">&nbsp;</a><a class="target" name="sideconsiderations">&nbsp;</a><a class="target" name="toc7">&nbsp;</a><h1>Side Considerations</h1>

<a class="target" name="aboutprematureoptimization">&nbsp;</a><a class="target" name="sideconsiderations/aboutprematureoptimization">&nbsp;</a><a class="target" name="toc7.1">&nbsp;</a><h2>About Premature Optimization</h2>
<p>


When we say &ldquo;Premature Optimization&rdquo; we intend thinking about optimization at a low level. While again it's up to you, we discourage looking into optmizing on low level until you're actually doing it across the whole program. The reason for it is that probably you're wasting your time. Optimizing at low level is actually very difficult and very specific. Often, when you are making some decisions assuming that it's faster... you don't really know if it is. Sometimes you might make things actually worse, assuming that you're helping but you're actually hurting, and you don't know it.

</p><p>

So we are trying to emphasize programming in a way that <em class="underscore">obviously</em> doesn't create disastrously bad things, and you'll think about refining once you've set everything in stone. You want to be coding nice and clean and simple, because that is what will be easier to optimize later. You should be thinking about that, rather than crazy little optimizations. You should be writing code in a way that makes it easier for you to read and understand it. 

</p><p>

For instance, while you were working on the keyboard input, you could have compressed <code>LParam</code>, i.e. transform, for example, <code>IsDown</code> to <code>(LParam &gt;&gt; 31)</code> but that's just plainly a bad idea. You'd rather want to create a <code>#define</code> for the <code>(1 &lt;&lt; 31)</code> and <code>(1 &lt;&lt; 30)</code> as 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KeyMessageWasDownBit (1 &lt;&lt; 30)</span></span>
<span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KeyMessageIsDownBit (1 &lt;&lt; 31)</span></span></code></pre><p>

and then use it in code as 

</p><pre class="listing tilde"><code><span class="line"><span class="hljs-keyword">bool</span> WasDown = ((LParam &amp; KeyMessageWasDownBit) != <span class="hljs-number">0</span>);</span>
<span class="line"><span class="hljs-keyword">bool</span> IsDown = ((LParam &amp; KeyMessageIsDownBit) == <span class="hljs-number">0</span>);</span></code></pre><p>

Because this makes your life easier and makes you understand the code better when you return to it later. Optimizations like the other one shouldn't be done at this stage of the code. It's quite probable that a) compiler will be smart enough to understand what you want from it and optimize things no matter what you write on that line and b) rather than <em class="underscore">guessing</em> what will be the right thing to do, you should look at the assemly, verify that the machine code generated is faster (or not), and then you'll <em class="underscore">know</em>.

</p><p>

Besides, if you're in the exploration phase, all of the code you're writing is probably going to be thrown away, so all the minute optimizations won't really matter. 

</p><p>

To recap, you'll need to know what you want to be doing, to know what the CPU will do, but between you and the CPU there's always the compiler which will not always do the optimal things, and you might to pick your battles whether or not you want to wrestle with it. 

</p>
<a class="target" name="navigation">&nbsp;</a><a class="target" name="navigation">&nbsp;</a><a class="target" name="toc8">&nbsp;</a><h1>Navigation</h1>
<p>


Previous: <a href="day5.html">Day 5. Windows Graphics Review</a>

</p><p>

Up Next: <a href="day7.html">Day 7. Initializing DirectSound</a>

</p><p>

<a href="../index.md.html">Back to Index</a>

</p>
<div class="nonumberh1">Glossary</div>
<p>


<ul>
<li class="asterisk">Function Signatures</li></ul>

</p>
<div class="nonumberh1">References</div>

<div class="nonumberh1">Articles</div>
<p>


<a href="https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee416842(v=vs.85)">DirectInput</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/joystickapi/">Joystickapi</a>

</p><p>

<a href="https://en.wikipedia.org/wiki/Interrupt">Interrupt</a>

</p><p>

<a href="https://en.wikipedia.org/wiki/Loader_(computing)">Loaders</a>

</p><p>

<a href="https://en.wikipedia.org/wiki/Polling_(computer_science)">Polling</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/raw-input">Raw Input</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/">XInput API</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/xinput/xinput-versions">XInput Versions</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/">Winuser API</a>

</p>
<div class="nonumberh1">MSDN</div>
<p>


<a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibraryA</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes">virtualkeys</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/wm-keydown">WM_KEYDOWN</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/wm-syskeydown">WM_SYSKEYDOWN</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/nf-xinput-xinputgetstate">XInputGetState</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/nf-xinput-xinputsetstate">XInputSetState</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/ns-xinput-xinput_state">XINPUTSTATE</a>

</p><p>

<a href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/ns-xinput-xinput_gamepad">XINPUT_GAMEPAD</a>

</p><p>

<style class="fallback">
  body {
    visibility: hidden;
    font-family: sans-serif;
  }
</style>

</p><p>

<script>markdeepOptions = { tocStyle: 'long' }; window.alreadyProcessedMarkdeep || (document.body.style.visibility = 'visible');</script>
</xinput.h></xinput.h></stdint.h></windows.h></xinput.h></p></span><div id="mdContextMenu" style="visibility:hidden"></div><div class="markdeepFooter"><i>formatted by <a href="https://casual-effects.com/markdeep" style="color:#999">Markdeep&nbsp;1.10&nbsp;&nbsp;</a></i><div style="display:inline-block;font-size:13px;font-family:'Times New Roman',serif;vertical-align:middle;transform:translate(-3px,-1px)rotate(135deg);">&#x2712;</div></div>